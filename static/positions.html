<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Positions - Trade Journal</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Shared CSS -->
    <link rel="stylesheet" href="/static/css/shared.css">
    
    <!-- Alpine.js for interactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Inline positions app -->
    <script>
        function positionsApp() {
            return {
                // Basic state
                allPositions: [],
                filteredPositions: [],
                accounts: [],
                accountBalances: {},
                underlyingQuotes: {},
                quoteUpdateCounter: 0,  // Increment this whenever quotes change to trigger re-renders
                positionComments: {},
                selectedAccount: '',
                selectedInstrumentType: '',
                selectedUnderlying: '',
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                cacheInfo: null,
                ws: null,
                username: null,
                
                
                // Computed properties
                get currentAccountBalance() {
                    if (!this.selectedAccount || this.selectedAccount === '') {
                        const values = Object.values(this.accountBalances);
                        if (values.length === 0) return null;
                        
                        return values.reduce((acc, balance) => ({
                            cash_balance: (acc.cash_balance || 0) + (balance.cash_balance || 0),
                            derivative_buying_power: (acc.derivative_buying_power || 0) + (balance.derivative_buying_power || 0),
                            net_liquidating_value: (acc.net_liquidating_value || 0) + (balance.net_liquidating_value || 0)
                        }), { cash_balance: 0, derivative_buying_power: 0, net_liquidating_value: 0 });
                    }
                    return this.accountBalances[this.selectedAccount] || null;
                },
                
                get groupedPositions() {
                    try {
                        if (this.isLoading || !this.allPositions || this.allPositions.length === 0) {
                            return [];
                        }

                        const groups = new Map();

                        // Debug: Log all SPY positions to check chain_id distribution
                        const spyPositions = this.filteredPositions.filter(p => this.getUnderlyingSymbol(p) === 'SPY');
                        if (spyPositions.length > 0) {
                            const spyChainIds = spyPositions.map(p => p.chain_id);
                            const uniqueChainIds = [...new Set(spyChainIds)];
                            console.log(`Found ${spyPositions.length} SPY positions`);
                            console.log(`Unique chain_ids: ${uniqueChainIds.length}`, uniqueChainIds);
                            spyPositions.forEach((p, i) => {
                                console.log(`  SPY[${i}]: ${p.symbol} -> chain_id: ${p.chain_id}`);
                            });
                        }

                        this.filteredPositions.forEach(position => {
                            const underlying = this.getUnderlyingSymbol(position);
                            if (!underlying || underlying === 'Unknown') {
                                return;
                            }

                            // Group strategy:
                            // - Enriched positions (with chain_id): group by chain_id
                            // - Unenriched positions (without chain_id): group by expiration date
                            const chainId = position.chain_id;
                            const strategyType = position.strategy_type || 'Unknown';

                            let groupKey;
                            let displayKey;

                            if (chainId) {
                                // Enriched position - group by chain_id and strategy
                                groupKey = `${underlying}|${chainId}|${strategyType}`;
                                displayKey = underlying;  // Don't include strategy in header; show in indicator area
                            } else {
                                // Unenriched position - group by expiration only
                                const expiration = position.expires_at || position.expiration || 'Unknown';
                                groupKey = `${underlying}|unenriched|${expiration}`;
                                displayKey = underlying;
                            }

                            if (!groups.has(groupKey)) {
                                groups.set(groupKey, {
                                    displayKey,
                                    underlying,
                                    chainId: chainId || 'unenriched',
                                    strategyType,
                                    positions: []
                                });
                            }
                            groups.get(groupKey).positions.push(position);
                        });

                        // Convert to array and sort
                        const result = Array.from(groups.values()).sort((a, b) => {
                            // Sort by underlying first
                            if (a.underlying !== b.underlying) {
                                return a.underlying.localeCompare(b.underlying);
                            }
                            // Then by whether enriched or not
                            if ((a.chainId === 'unenriched') !== (b.chainId === 'unenriched')) {
                                return a.chainId === 'unenriched' ? 1 : -1;
                            }
                            // Then by chain_id/expiration
                            const aKey = a.positions[0]?.chain_id || a.positions[0]?.expires_at || '';
                            const bKey = b.positions[0]?.chain_id || b.positions[0]?.expires_at || '';
                            return (aKey || '').localeCompare(bKey || '');
                        });

                        return result;
                    } catch (error) {
                        console.error('Error in groupedPositions:', error);
                        return [];
                    }
                },

                get underlyings() {
                    return [...new Set(this.filteredPositions.map(p => this.getUnderlyingSymbol(p)).filter(s => s && s !== 'Unknown'))];
                },

                // Initialize
                async init() {
                    console.log('Initializing positions page...');
                    // Check authentication first
                    try {
                        const authResponse = await fetch('/api/auth/verify');
                        if (!authResponse.ok) {
                            window.location.href = '/login';
                            return;
                        }
                        const authData = await authResponse.json();
                        this.username = authData.username;
                    } catch (error) {
                        console.error('Auth check failed:', error);
                        window.location.href = '/login';
                        return;
                    }

                    this.loadComments();
                    await this.fetchAccounts();
                    this.loadFilterPreferences();
                    await this.loadAccountBalances();
                    await this.fetchPositions();  // This calls applyFilters() internally
                    await this.loadCachedQuotes();  // Load cached quotes immediately (from previous session)
                    this.initializeWebSocket();  // WebSocket will stream fresh quotes
                },
                

                // Basic methods (just essential ones for now)
                async fetchAccounts() {
                    try {
                        const response = await fetch('/api/accounts');
                        const data = await response.json();
                        this.accounts = data.accounts || [];
                        console.log('Loaded accounts:', this.accounts);
                    } catch (error) {
                        console.error('Failed to load accounts:', error);
                    }
                },
                
                async fetchPositions(includeSync = false, fastMode = true) {
                    this.isLoading = true;
                    this.error = null;
                    
                    try {
                        if (includeSync) {
                            // Use fast sync for positions page by default
                            const endpoint = fastMode ? '/api/sync-positions-only' : '/api/sync';
                            await fetch(endpoint, { method: 'POST' });
                        }
                        
                        const response = await fetch('/api/positions');
                        const data = await response.json();
                        
                        // Flatten positions from accounts
                        this.allPositions = [];
                        if (typeof data === 'object' && !Array.isArray(data)) {
                            Object.entries(data).forEach(([accountNumber, accountPositions]) => {
                                if (Array.isArray(accountPositions)) {
                                    // Add account_number to each position
                                    accountPositions.forEach(position => {
                                        position.account_number = accountNumber;
                                        this.allPositions.push(position);
                                    });
                                }
                            });
                        } else {
                            this.allPositions = Array.isArray(data) ? data : [];
                        }
                        
                        console.log('Sample position:', this.allPositions[0]);
                        console.log('Total positions loaded:', this.allPositions.length);
                        console.log('Accounts in positions:', [...new Set(this.allPositions.map(p => p.account_number))]);
                        this.applyFilters();
                        
                    } catch (error) {
                        console.error('Failed to load positions:', error);
                        this.error = 'Failed to load positions';
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                async loadAccountBalances() {
                    try {
                        const response = await fetch('/api/account-balances');
                        const data = await response.json();
                        const balances = data.balances || data;
                        
                        this.accountBalances = {};
                        if (Array.isArray(balances)) {
                            balances.forEach(balance => {
                                this.accountBalances[balance.account_number] = balance;
                            });
                        }
                    } catch (error) {
                        console.error('Failed to load account balances:', error);
                    }
                },

                async loadCachedQuotes() {
                    try {
                        // Get unique underlying symbols from positions
                        const underlyings = [...new Set(this.filteredPositions.map(p => this.getUnderlyingSymbol(p)).filter(s => s && s !== 'Unknown'))];

                        console.log('loadCachedQuotes: filteredPositions.length =', this.filteredPositions.length);
                        console.log('loadCachedQuotes: underlyings =', underlyings);

                        if (underlyings.length === 0) {
                            console.log('No underlyings to load quotes for');
                            return;
                        }

                        // Fetch cached quotes for all underlyings
                        const url = `/api/quotes?symbols=${encodeURIComponent(underlyings.join(','))}`;
                        console.log('loadCachedQuotes: fetching', url);

                        const response = await fetch(url);
                        console.log('*** loadCachedQuotes: response status =', response.status);
                        console.log('*** loadCachedQuotes: response.ok =', response.ok);

                        if (response.ok) {
                            const quotes = await response.json();
                            console.log('*** loadCachedQuotes: received quotes from API:', quotes);
                            console.log('*** loadCachedQuotes: quotes is type:', typeof quotes);
                            console.log('*** loadCachedQuotes: quotes keys:', Object.keys(quotes));

                            if (Object.keys(quotes).length === 0) {
                                console.warn('*** loadCachedQuotes: API returned empty quotes object!');
                                return;
                            }

                            // Store quotes using direct property assignment for Alpine.js reactivity
                            console.log('*** loadCachedQuotes: BEFORE assignment, this.underlyingQuotes =', this.underlyingQuotes);
                            for (const [symbol, quoteData] of Object.entries(quotes)) {
                                if (quoteData && typeof quoteData === 'object') {
                                    this.underlyingQuotes[symbol] = quoteData;
                                }
                            }
                            console.log('*** loadCachedQuotes: AFTER assignment, this.underlyingQuotes =', this.underlyingQuotes);
                            console.log('*** loadCachedQuotes: AFTER assignment, keys =', Object.keys(this.underlyingQuotes));

                            this.lastQuoteUpdate = new Date().toLocaleTimeString();
                            this.quoteUpdateCounter++;

                            console.log(`*** loadCachedQuotes: Successfully loaded ${Object.keys(quotes).length} cached quotes`);
                            console.log('*** loadCachedQuotes: underlyingQuotes now contains:', Object.keys(this.underlyingQuotes).join(', '));
                        } else {
                            const errorText = await response.text();
                            console.warn('*** Failed to load cached quotes: status=' + response.status + ', response=' + errorText);
                        }
                    } catch (error) {
                        console.error('Error loading cached quotes:', error);
                    }
                },

                initializeWebSocket() {
                    console.log('>>> initializeWebSocket() called');
                    try {
                        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                        const wsUrl = `${protocol}//${location.host}/ws/quotes`;
                        console.log('>>> Creating WebSocket to:', wsUrl);
                        this.ws = new WebSocket(wsUrl);
                        console.log('>>> WebSocket created:', this.ws);
                        console.log('>>> About to set onopen handler');

                        this.ws.onopen = () => {
                            console.log('WebSocket connected successfully');
                            console.log('WebSocket readyState:', this.ws.readyState);
                            this.liveQuotesActive = true;
                        };

                        console.log('>>> onopen handler set, now setting onmessage handler');
                        this.ws.onmessage = (event) => {
                            const message = JSON.parse(event.data);
                            console.log('[WS] Message received:', message.type);

                            if (message.type === 'connected') {
                                console.log('[WS] Connected - requesting quotes in 100ms');
                                setTimeout(() => {
                                    console.log('[WS] Timeout fired - calling requestLiveQuotes');
                                    this.requestLiveQuotes();
                                }, 100);
                            }
                            else if (message.type === 'quotes' && message.data) {
                                for (const [symbol, quoteData] of Object.entries(message.data)) {
                                    if (quoteData && typeof quoteData === 'object') {
                                        this.underlyingQuotes[symbol] = quoteData;
                                    }
                                }
                                this.quoteUpdateCounter++;
                                this.lastQuoteUpdate = new Date().toLocaleTimeString();
                                console.log('[WS] Updated', Object.keys(message.data).length, 'quotes');
                            }
                            else if (message.error) {
                                console.error('[WS] Error:', message.error);
                            }
                        };
                        
                        this.ws.onclose = (event) => {
                            console.log('WebSocket closed. Code:', event.code, 'Reason:', event.reason);
                            this.liveQuotesActive = false;
                            setTimeout(() => this.initializeWebSocket(), 5000);
                        };
                        
                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                        };
                        
                    } catch (error) {
                        console.error('WebSocket error:', error);
                    }
                },
                
                getPositionSymbol(position) {
                    // For options, return the full symbol; for equities, return the stock symbol
                    // Note: instrument_type can be "InstrumentType.EQUITY_OPTION" or "InstrumentType.EQUITY"
                    const isOption = position.instrument_type && position.instrument_type.includes('OPTION');

                    if (isOption) {
                        // For options, use the full symbol
                        return position.symbol;
                    } else {
                        // For equities and unknown types, use the underlying symbol
                        return this.getUnderlyingSymbol(position);
                    }
                },

                requestLiveQuotes() {
                    console.log('requestLiveQuotes() called');
                    console.log('  this.ws:', this.ws);
                    console.log('  this.ws.readyState:', this.ws ? this.ws.readyState : 'NO WS');
                    console.log('  WebSocket.OPEN:', WebSocket.OPEN);

                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                        console.log('  Skipping - WebSocket not ready');
                        return;
                    }

                    // Subscribe to all position symbols (both equities and options)
                    const symbols = [...new Set(this.filteredPositions.map(p => this.getPositionSymbol(p)).filter(s => s && s !== 'Unknown'))];

                    console.log('  filteredPositions.length:', this.filteredPositions.length);
                    console.log('  symbols to subscribe to:', symbols);

                    if (symbols.length > 0) {
                        console.log('  Sending subscribe message for:', symbols);
                        this.ws.send(JSON.stringify({
                            subscribe: symbols
                        }));
                    } else {
                        console.log('  No symbols to subscribe to');
                    }
                },
                
                // Filtering
                applyFilters() {
                    console.log('=== applyFilters called ===');
                    console.log('selectedAccount:', this.selectedAccount);
                    console.log('allPositions.length:', this.allPositions.length);

                    this.filteredPositions = this.allPositions.filter(position => {
                        if (this.selectedAccount && position.account_number !== this.selectedAccount) {
                            return false;
                        }
                        if (this.selectedInstrumentType && position.instrument_type !== this.selectedInstrumentType) {
                            return false;
                        }
                        if (this.selectedUnderlying) {
                            const underlying = this.getUnderlyingSymbol(position);
                            if (underlying !== this.selectedUnderlying) {
                                return false;
                            }
                        }
                        return true;
                    });

                    // If the selectedAccount filter resulted in no positions, reset it
                    // This handles the case where a saved account preference doesn't have any positions
                    if (this.selectedAccount && this.filteredPositions.length === 0 && this.allPositions.length > 0) {
                        console.log(`Account ${this.selectedAccount} has no positions, clearing filter`);
                        this.selectedAccount = '';
                        // Re-apply filters without the account restriction
                        this.filteredPositions = this.allPositions.filter(position => {
                            if (this.selectedInstrumentType && position.instrument_type !== this.selectedInstrumentType) {
                                return false;
                            }
                            if (this.selectedUnderlying) {
                                const underlying = this.getUnderlyingSymbol(position);
                                if (underlying !== this.selectedUnderlying) {
                                    return false;
                                }
                            }
                            return true;
                        });
                    }

                    console.log('filteredPositions.length:', this.filteredPositions.length);
                    if (this.filteredPositions.length > 0) {
                        console.log('Sample filtered position:', this.filteredPositions[0]);
                    }
                },
                
                filterPositions() {
                    this.applyFilters();
                },
                
                saveFilterPreferences() {
                    // Save account selection to localStorage
                    localStorage.setItem('positionsSelectedAccount', this.selectedAccount || '');
                },

                loadFilterPreferences() {
                    // Load account selection from localStorage
                    const savedAccount = localStorage.getItem('positionsSelectedAccount');
                    if (savedAccount) {
                        this.selectedAccount = savedAccount;
                        console.log('Restored account selection from localStorage:', savedAccount);
                    }
                },

                onAccountChange() {
                    // Handle account filter change with proper quote refresh
                    console.log('=== onAccountChange triggered ===');

                    // Step 1: Clear old quotes
                    console.log('Clearing old quotes');
                    this.underlyingQuotes = {};

                    // Step 2: Apply filters
                    console.log('Applying filters for account:', this.selectedAccount);
                    this.applyFilters();

                    // Step 3: Save preferences
                    this.saveFilterPreferences();

                    // Step 4: Load cached quotes for new filtered positions
                    // Use a small timeout to ensure filteredPositions is updated in Alpine.js reactivity
                    setTimeout(async () => {
                        console.log('Loading cached quotes for new filtered positions');
                        await this.loadCachedQuotes();

                        // Step 5: Request live quotes via WebSocket
                        console.log('Requesting live quotes via WebSocket');
                        this.requestLiveQuotes();
                    }, 50);
                },

                // Utility methods
                getUnderlyingSymbol(position) {
                    if (position.underlying) {
                        return position.underlying;
                    }
                    
                    if (position.symbol) {
                        if (position.instrument_type === 'EQUITY') {
                            return position.symbol;
                        } else {
                            return position.symbol.split(' ')[0] || position.symbol.split('_')[0];
                        }
                    }
                    
                    return 'Unknown';
                },
                
                formatNumber(value, decimals = 2) {
                    if (value === null || value === undefined || isNaN(value)) return '0';
                    return new Intl.NumberFormat('en-US', {
                        minimumFractionDigits: decimals,
                        maximumFractionDigits: decimals
                    }).format(value);
                },
                
                // Position calculation functions
                getGroupCostBasis(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                },
                getGroupNetLiq(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.market_value || 0), 0);
                },
                getGroupPnL(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.unrealized_pnl || 0), 0);
                },
                getGroupPnLPercent(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    // Use signed cost basis (not absolute), and use live PnL
                    const totalCostBasis = positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                    const totalPnL = this.getGroupPnLWithLiveQuotes(positions);
                    if (totalCostBasis === 0) return null;
                    // % Return = PnL / |CostBasis| * 100
                    return ((totalPnL / Math.abs(totalCostBasis)) * 100).toFixed(2);
                },
                getGroupDaysOpen(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    const firstPos = positions[0];
                    if (!firstPos.opened_at) return null;
                    const openedDate = new Date(firstPos.opened_at);
                    const now = new Date();
                    const days = Math.floor((now - openedDate) / (1000 * 60 * 60 * 24));
                    return days > 0 ? days : 0;
                },
                getGroupMaxPercent(positions) {
                    // For spread strategies, calculate current P&L as percentage of max profit
                    // % Max = (Current P&L / Max Profit) × 100
                    // Where Max Profit = (Spread Width × 100 × Num Contracts) - Debit Paid
                    const totalCostBasis = positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                    if (totalCostBasis === 0) return '—';

                    // Extract strike prices from option symbols
                    const strikes = positions
                        .map(p => {
                            // Symbol format: "HOOD  251219C00135000" -> extract 135
                            const match = (p.symbol || '').match(/([CP])(\d{8})$/);
                            if (match) {
                                // Strike is in the last 8 digits, divide by 1000 to get actual strike
                                return parseInt(match[2]) / 1000;
                            }
                            return p.strike_price;
                        })
                        .filter(s => s !== null && s !== undefined)
                        .sort((a, b) => a - b);

                    if (strikes.length < 2) {
                        // Can't calculate spread width with less than 2 strikes
                        return '—';
                    }

                    // Calculate spread width (difference between highest and lowest strike)
                    const spreadWidth = strikes[strikes.length - 1] - strikes[0];

                    // For a spread, the number of contracts is the absolute quantity of one leg
                    // (both long and short should have same quantity)
                    const numContracts = Math.abs(positions[0].quantity || 0);

                    // Max profit = (spread width × 100 × num contracts) - absolute debit paid
                    const maxProfit = (spreadWidth * 100 * numContracts) - Math.abs(totalCostBasis);

                    if (maxProfit <= 0) return '—';

                    // Current P&L using live market values
                    // Use the same calculation as getGroupPnLWithLiveQuotes for consistency
                    const currentPnL = this.getGroupPnLWithLiveQuotes(positions);

                    // Only show % Max if we have a profit (positive P&L)
                    if (currentPnL <= 0) return '—';

                    // % Max = (Current P&L / Max Profit) × 100
                    const maxPercent = ((currentPnL / maxProfit) * 100).toFixed(1);

                    return maxPercent + '%';
                },
                getMinDTE(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    let minDTE = null;
                    for (const pos of positions) {
                        if (pos.expires_at) {
                            const expDate = new Date(pos.expires_at);
                            const now = new Date();
                            const dte = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
                            if (minDTE === null || dte < minDTE) {
                                minDTE = dte;
                            }
                        }
                    }
                    return minDTE;
                },
                getGroupStrategyLabel(group) {
                    // Prioritize strategy_type from API enrichment data
                    if (group.strategyType && group.strategyType !== 'Unknown') {
                        return group.strategyType;
                    }
                    // Fall back to inferring from position types
                    return this.getStrategyLabel(group.positions);
                },
                getStrategyLabel(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return 'Unknown';
                    // Check if positions include both calls and puts (Iron Condor style)
                    const hasCall = positions.some(p => p.option_type === 'Call' || p.symbol.includes('C'));
                    const hasPut = positions.some(p => p.option_type === 'Put' || p.symbol.includes('P'));
                    if (hasCall && hasPut) return 'Spread';
                    if (hasCall) return 'Call';
                    if (hasPut) return 'Put';
                    return 'Stock';
                },
                shouldShowMaxPercent(positions) {
                    if (!Array.isArray(positions) || positions.length <= 1) return false;
                    // Show max percent for multi-leg strategies (spreads, covered calls, etc.)
                    // Check if this is a multi-leg option strategy
                    const hasOptions = positions.some(p => {
                        const isOption = p.instrument_type && p.instrument_type.includes('OPTION');
                        const symbolHasOption = (p.symbol || '').match(/[CP]\d+/);
                        return isOption || symbolHasOption;
                    });

                    // If we have multiple positions with options, show max percent
                    return hasOptions && positions.length > 1;
                },
                calculateLiveMarketValue(position) {
                    // Force reactivity by accessing quoteUpdateCounter
                    this.quoteUpdateCounter;

                    // Market value is stored in the database with correct sign:
                    // Long positions: positive
                    // Short positions: negative
                    let marketValue = position.market_value || 0;

                    // Check if this is an option or equity position
                    // Note: instrument_type can be "InstrumentType.EQUITY_OPTION" or "InstrumentType.EQUITY"
                    // Check for OPTION first before checking for EQUITY (since EQUITY_OPTION contains "EQUITY")
                    const isOption = position.instrument_type && position.instrument_type.includes('OPTION');
                    const isEquity = !isOption && (!position.instrument_type ||
                                   position.instrument_type === 'EQUITY' ||
                                   position.instrument_type.includes('EQUITY'));

                    // For equity positions, update with live quote if available
                    if (isEquity) {
                        const underlying = this.getUnderlyingSymbol(position);
                        const quote = this.underlyingQuotes[underlying];
                        if (quote && quote.price) {
                            // Stock: market_value = price × quantity (NO multiplier for stocks)
                            // Apply correct sign based on position direction
                            const absValue = quote.price * position.quantity;
                            marketValue = position.quantity_direction === 'Short' ? -absValue : absValue;
                        }
                    } else {
                        // For option positions, update with live option quote (NOT underlying quote)
                        const optionSymbol = position.symbol.trim();
                        const optionQuote = this.underlyingQuotes[optionSymbol];
                        if (optionQuote && optionQuote.mark !== undefined) {
                            // Options: market_value = mark price * quantity * 100 (options are quoted per share, 100 shares per contract)
                            const absValue = optionQuote.mark * position.quantity * 100;
                            marketValue = position.quantity_direction === 'Short' ? -absValue : absValue;
                        } else {
                            // Debug: log if we're missing a quote for an option
                            if (!optionQuote && position.quantity > 0) {
                                console.debug(`No quote found for option ${optionSymbol}. Available quotes: ${Object.keys(this.underlyingQuotes).filter(k => k.includes('C') || k.includes('P')).slice(0, 3).join(', ')}`);
                            }
                        }
                    }

                    return marketValue;
                },
                calculateLivePositionPnL(position) {
                    // Calculate unrealized P&L as the gain/loss from current price vs entry price
                    // Formula: P&L = |CurrentPrice - EntryPrice| × Quantity
                    // Which equals: |MarketValue| - |CostBasis|
                    //
                    // Long: (current_price - entry_price) × qty = |MV| - |CB|
                    // Short: (entry_price - current_price) × qty = |CB| - |MV|
                    //
                    // For display:
                    // Long: positive when profitable (current > entry)
                    // Short: negative when current > entry (losing money), positive when current < entry

                    const liveMarketValue = this.calculateLiveMarketValue(position);
                    const costBasis = position.cost_basis || 0;

                    const absMarketValue = Math.abs(liveMarketValue);
                    const absCostBasis = Math.abs(costBasis);

                    if (position.quantity_direction === 'Short') {
                        // Short: P&L = entry_price - current_price = |CB| - |MV|
                        return absCostBasis - absMarketValue;
                    } else {
                        // Long: P&L = current_price - entry_price = |MV| - |CB|
                        return absMarketValue - absCostBasis;
                    }
                },
                getGroupNetLiqWithLiveQuotes(positions) {
                    // Force reactivity by accessing quoteUpdateCounter
                    this.quoteUpdateCounter;

                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + this.calculateLiveMarketValue(pos), 0);
                },
                getGroupPnLWithLiveQuotes(positions) {
                    // Force reactivity by accessing quoteUpdateCounter
                    this.quoteUpdateCounter;

                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + this.calculateLivePositionPnL(pos), 0);
                },
                shouldShowPriceIndicator(positions) {
                    if (!Array.isArray(positions)) return false;
                    // Show price indicator for all option positions (anything with a strike price)
                    return positions.some(p => {
                        // Check if it's an option position
                        if (p.instrument_type && p.instrument_type.includes('OPTION')) {
                            return true;
                        }
                        // Check if symbol contains a call or put indicator
                        const match = (p.symbol || '').match(/([CP])(\d+)/);
                        return match !== null;
                    });
                },
                getPricePositionIndicator(positions, underlying) {
                    // Visual semi-graphical representation of price relative to strikes
                    // Example: ◆65.2——70——75 or 70——◆72.5——75
                    const underlyingQuote = this.getUnderlyingQuote(underlying);
                    const currentPrice = underlyingQuote ? underlyingQuote.price : null;

                    if (!currentPrice) {
                        return '<span class="text-slate-500">Price N/A</span>';
                    }

                    // Get all strikes from option positions
                    const getStrike = (p) => {
                        if (p.strike_price && p.strike_price > 0) return p.strike_price;
                        const match = (p.symbol || '').match(/([CP])(\d+)/);
                        if (match) {
                            const priceStr = match[2];
                            if (priceStr.length >= 3) {
                                return parseFloat(priceStr.slice(0, -3) + '.' + priceStr.slice(-3));
                            }
                        }
                        return null;
                    };

                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    const strikes = optionPositions.map(getStrike).filter(s => s !== null && s > 0).sort((a, b) => a - b);

                    if (strikes.length < 2) {
                        return '<span class="text-slate-500">—</span>';
                    }

                    // Format strikes and price for display
                    const formatStrike = (strike) => strike % 1 === 0 ? strike.toString() : strike.toFixed(1);
                    const formatPrice = (price) => price.toFixed(1);
                    const currentPriceFormatted = formatPrice(currentPrice);

                    if (strikes.length === 2) {
                        // Two-leg spread
                        const [low, high] = strikes;
                        if (currentPrice < low) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line">——</span><span class="strike-marker">${formatStrike(low)}</span><span class="price-line">——</span><span class="strike-marker">${formatStrike(high)}</span>`;
                        } else if (currentPrice > high) {
                            return `<span class="strike-marker">${formatStrike(low)}</span><span class="price-line">——</span><span class="strike-marker">${formatStrike(high)}</span><span class="price-line">——</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(low)}</span><span class="price-line">——</span><span class="price-marker price-between">◆${currentPriceFormatted}</span><span class="price-line">——</span><span class="strike-marker">${formatStrike(high)}</span>`;
                        }
                    } else if (strikes.length === 4) {
                        // Iron Condor: 4 strikes
                        const [s1, s2, s3, s4] = strikes;
                        if (currentPrice < s1) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line">——</span><span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else if (currentPrice > s4) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span><span class="price-line">——</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else if (currentPrice >= s2 && currentPrice <= s3) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span><span class="price-marker price-between">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else if (currentPrice < s2) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s4)}</span>`;
                        }
                    } else if (strikes.length === 3) {
                        // Butterfly: 3 strikes
                        const [s1, s2, s3] = strikes;
                        if (currentPrice < s1) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line">——</span><span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        } else if (currentPrice > s3) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span><span class="price-line">——</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else if (Math.abs(currentPrice - s2) < Math.min(Math.abs(currentPrice - s1), Math.abs(currentPrice - s3))) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="price-marker price-between">◆${currentPriceFormatted}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(s1)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        }
                    }

                    return '<span class="text-slate-500">Complex</span>';
                },
                getUnderlyingQuote(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    if (!quote && underlying) {
                        const availableKeys = Object.keys(this.underlyingQuotes);
                        console.warn(`getUnderlyingQuote called for '${underlying}', but no quote found.`);
                        console.warn(`Available keys (${availableKeys.length}):`, availableKeys);
                        console.warn(`Full underlyingQuotes object:`, this.underlyingQuotes);
                    }
                    return quote || null;
                },
                getUnderlyingIV(underlying) {
                    const quote = this.getUnderlyingQuote(underlying);
                    if (!quote || !quote.iv) return null;
                    return quote.iv.toFixed(1);  // IV is already in percentage form from TT
                },
                getUnderlyingIVR(underlying) {
                    const quote = this.getUnderlyingQuote(underlying);
                    if (!quote || !quote.ivr) return null;
                    return Math.round(quote.ivr * 100);  // IVR is 0-1 range, convert to integer percentage
                },
                getOptionType(position) {
                    if (position.option_type) return position.option_type.charAt(0).toUpperCase();
                    if (position.symbol.includes('C')) return 'C';
                    if (position.symbol.includes('P')) return 'P';
                    return '—';
                },
                getSignedQuantity(position) {
                    const qty = position.quantity || 0;
                    if (position.quantity_direction === 'Short') return -qty;
                    return qty;
                },
                getExpirationDate(position) {
                    if (!position.expires_at) return '';
                    const date = new Date(position.expires_at);
                    return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                },
                getStrikePrice(position) {
                    // First try the strike_price field
                    if (position.strike_price && position.strike_price > 0) {
                        return position.strike_price.toFixed(2);
                    }

                    // Fall back to parsing from symbol if strike_price is missing
                    // Symbol format: "SPY  251115C00550000" -> strike is 550.00
                    const symbol = position.symbol || '';
                    const match = symbol.match(/([CP])(\d+)/);
                    if (match) {
                        const priceStr = match[2];
                        if (priceStr.length >= 3) {
                            const strike = parseFloat(priceStr.slice(0, -3) + '.' + priceStr.slice(-3));
                            return strike.toFixed(2);
                        }
                    }

                    return '';
                },
                getDTE(position) {
                    if (!position.expires_at) return null;
                    const expDate = new Date(position.expires_at);
                    const now = new Date();
                    const dte = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
                    return dte > 0 ? dte : 0;
                },
                getLiveUnrealizedPnL(position) {
                    return position.unrealized_pnl || 0;
                },
                getLivePnLPercent(position) {
                    if (!position.cost_basis || position.cost_basis === 0) return 0;
                    return ((position.unrealized_pnl || 0) / Math.abs(position.cost_basis) * 100);
                },
                getMaxPercentColor(value) {
                    if (value >= 50) return 'text-yellow-400 font-bold';
                    if (value >= 30) return 'text-white';
                    return 'text-slate-400';
                },
                getMaxPercentTooltip(positions) {
                    return 'Max percent of max loss';
                },
                
                // Comments - now per-position/chain instead of per-underlying
                loadComments() {
                    try {
                        this.positionComments = JSON.parse(localStorage.getItem('positionComments') || '{}');
                    } catch (error) {
                        this.positionComments = {};
                    }
                },

                getCommentKey(group) {
                    // Use chain_id if available (enriched positions), otherwise use symbol + account
                    if (group.chainId && group.chainId !== 'unenriched') {
                        return `chain_${group.chainId}`;
                    }
                    // For unenriched positions, use symbol + expiration + account to be unique
                    const symbol = group.underlying;
                    const account = this.selectedAccount || 'default';
                    // Find first position's expiration in this group
                    const expiration = group.positions[0]?.expires_at || group.positions[0]?.expiration || 'noexp';
                    return `pos_${symbol}_${expiration}_${account}`;
                },

                getPositionComment(group) {
                    const key = this.getCommentKey(group);
                    return this.positionComments[key] || '';
                },

                updatePositionComment(group, value) {
                    const key = this.getCommentKey(group);
                    this.positionComments[key] = value;
                    localStorage.setItem('positionComments', JSON.stringify(this.positionComments));
                },

                async logout() {
                    try {
                        const response = await fetch('/api/auth/logout', { method: 'POST' });
                        if (response.ok) {
                            // Logout successful, redirect to login page
                            window.location.href = '/login';
                        } else {
                            console.error('Logout failed');
                        }
                    } catch (error) {
                        console.error('Logout error:', error);
                        // Force redirect to login page even if request fails
                        window.location.href = '/login';
                    }
                }
            };
        }
    </script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Page-specific styles -->
    <style>
        /* Price position indicator styles */
        .price-marker {
            font-weight: bold;
            font-size: 1.1em;
        }

        .price-marker.price-between {
            color: #10b981;
        }

        .price-marker.price-outside {
            color: #ef4444;
        }

        .strike-marker {
            color: #94a3b8;
            font-weight: 600;
        }

        .price-line {
            color: #64748b;
            margin: 0 2px;
        }

        .price-below {
            color: #ef4444;
        }

        .price-above {
            color: #ef4444;
        }

        .price-between {
            color: #10b981;
        }

        .price-outside {
            color: #ef4444;
        }
        
        /* Strategy badge styles */
        .strategy-badge-complex {
            background: #7C3AED;
            border-color: #8B5CF6;
            color: #DDD6FE;
        }
        
        .strategy-badge-spread {
            background: #0891B2;
            border-color: #0EA5E9;
            color: #BFDBFE;
        }
        
        .strategy-badge-covered {
            background: #059669;
            border-color: #10B981;
            color: #A7F3D0;
        }
        
        .strategy-badge-single {
            background: #DC2626;
            border-color: #EF4444;
            color: #FECACA;
        }
        
        .strategy-badge-stock {
            background: #374151;
            border-color: #6B7280;
            color: #D1D5DB;
        }
        
        /* Aligned header grid */
        .header-stats-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.3rem;
            align-items: center;
            width: 100%;
        }
        
        .header-stat-column {
            flex-shrink: 0;
        }
        
        /* Strict column alignment - optimized for Comments space */
        .header-stats-grid > div:nth-child(1) { width: 100px; flex-shrink: 0; }  /* Symbol + chevron */
        .header-stats-grid > div:nth-child(2) { width: 160px; flex-shrink: 0; }  /* Price boxes */
        .header-stats-grid > div:nth-child(3) { width: 40px; flex-shrink: 0; }   /* Chain link */
        .header-stats-grid > div:nth-child(4) { width: 80px; flex-shrink: 0; }   /* Cost Basis */
        .header-stats-grid > div:nth-child(5) { width: 80px; flex-shrink: 0; }   /* Net Liq */
        .header-stats-grid > div:nth-child(6) { width: 70px; flex-shrink: 0; }   /* P&L */
        .header-stats-grid > div:nth-child(7) { width: 60px; flex-shrink: 0; }   /* % Ret */
        .header-stats-grid > div:nth-child(8) { width: 55px; flex-shrink: 0; }   /* % Max */
        .header-stats-grid > div:nth-child(9) { width: 50px; flex-shrink: 0; }   /* Days */
        .header-stats-grid > div:nth-child(10) { width: 50px; flex-shrink: 0; }  /* DTE */
        .header-stats-grid > div:nth-child(11) { width: 150px; flex-shrink: 0; } /* Strategy */
        .header-stats-grid > div:nth-child(12) { flex: 1; min-width: 200px; margin-left: 20px; }    /* Comments */
        
        .header-stat-column {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
    </style>
</head>

<body class="min-h-screen bg-slate-900 text-slate-100">
    <div x-data="positionsApp()" x-init="init()">
        <!-- Navigation Header -->
        <nav class="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
            <div class="w-full mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center space-x-8">
                        <div class="flex-shrink-0">
                            <h1 class="text-xl font-bold text-blue-400">
                                <i class="fas fa-chart-line mr-2"></i>
                                Trade Journal
                            </h1>
                        </div>
                        
                        <div class="hidden sm:flex space-x-4">
                            <a href="/chains"
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-link mr-1"></i>
                                Order Chains
                            </a>
                            <a href="/screener"
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-search mr-1"></i>
                                Options Screener
                            </a>
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-4">
                        <button @click="fetchPositions(true)" 
                                :disabled="isLoading"
                                class="bg-green-600 hover:bg-green-700 disabled:bg-green-800 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center">
                            <i class="fas fa-sync-alt mr-2" :class="{'loading-spinner': isLoading}"></i>
                            <span x-text="isLoading ? 'Syncing...' : 'Sync Positions'"></span>
                        </button>
                        
                        <!-- Last Synced Timestamp -->
                        <div class="text-xs text-slate-400" x-show="lastSyncTimestamp">
                            <i class="fas fa-clock mr-1"></i>
                            Last synced: <span x-text="lastSyncTimestamp"></span>
                        </div>
                        
                        <!-- Cache Freshness Indicator -->
                        <div class="text-xs" x-show="cacheInfo && cacheInfo.cached">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-database" 
                                   :class="cacheInfo && cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo && cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')"></i>
                                <span :class="cacheInfo && cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo && cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')">
                                    <span x-show="cacheInfo && cacheInfo.is_fresh">Fresh data</span>
                                    <span x-show="cacheInfo && !cacheInfo.is_fresh && cacheInfo.data_age_minutes < 360">
                                        <span x-text="cacheInfo ? Math.round(cacheInfo.data_age_minutes) : ''"></span>m old
                                    </span>
                                    <span x-show="cacheInfo && !cacheInfo.is_fresh && cacheInfo.data_age_minutes >= 360">
                                        <span x-text="cacheInfo ? Math.round(cacheInfo.data_age_minutes / 60) : ''"></span>h old
                                    </span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- Account Selector -->
                        <div class="flex items-center space-x-2">
                            <label for="account-select" class="text-sm font-medium text-slate-300">Account:</label>
                            <select
                                id="account-select"
                                x-model="selectedAccount"
                                @change="onAccountChange()"
                                class="bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2"
                            >
                                <option value="">All Accounts</option>
                                <template x-for="account in accounts" :key="account.account_number">
                                    <option
                                        :value="account.account_number"
                                        x-text="account.account_name || account.account_number"
                                    ></option>
                                </template>
                            </select>
                        </div>

                        <!-- User Menu with Logout -->
                        <div class="flex items-center space-x-4 ml-4 pl-4 border-l border-slate-600">
                            <div class="text-sm text-slate-300">
                                <i class="fas fa-user mr-1"></i>
                                <span x-text="username || 'User'"></span>
                            </div>
                            <button @click="logout()"
                                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                                <i class="fas fa-sign-out-alt mr-1"></i>
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <div class="w-full mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Header Section -->
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-slate-100 mb-2">Open Positions</h2>
                <p class="text-slate-400">Current positions from your Tastytrade accounts</p>
            </div>

            <!-- Filters and Summary -->
            <div class="bg-slate-800 rounded-lg p-6 mb-6">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <!-- Account Balances (Left Side) -->
                    <div class="flex flex-wrap items-center gap-6 text-sm">
                        <template x-if="currentAccountBalance">
                            <div class="flex items-center gap-6">
                                <div>
                                    <div class="text-slate-400 text-xs">Cash</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.cash_balance)"></div>
                                </div>
                                <div>
                                    <div class="text-slate-400 text-xs">Option BP</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.derivative_buying_power)"></div>
                                </div>
                                <div>
                                    <div class="text-slate-400 text-xs">NetLiq</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.net_liquidating_value)"></div>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- Filters (Right Side) -->
                    <div class="flex flex-wrap items-center gap-4">
                        <!-- Instrument Type Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Type:</label>
                            <select x-model="selectedInstrumentType" @change="filterPositions(); requestLiveQuotes()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Types</option>
                                <option value="EQUITY">Stocks</option>
                                <option value="EQUITY_OPTION">Options</option>
                            </select>
                        </div>

                        <!-- Underlying Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Underlying:</label>
                            <select x-model="selectedUnderlying" @change="filterPositions(); requestLiveQuotes()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Underlyings</option>
                                <template x-for="underlying in underlyings" :key="underlying">
                                    <option :value="underlying" x-text="underlying"></option>
                                </template>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div x-show="isLoading" class="text-center py-12">
                <i class="fas fa-spinner fa-spin text-4xl text-blue-400 mb-4"></i>
                <p class="text-slate-400">Loading positions...</p>
            </div>

            <!-- Error State -->
            <div x-show="error && !isLoading" class="bg-red-900/20 border border-red-700 rounded-lg p-4 mb-6">
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-red-400 mr-3"></i>
                    <span class="text-red-200" x-text="error"></span>
                </div>
            </div>

            <!-- Empty State -->
            <div x-show="!isLoading && !error && filteredPositions.length === 0" class="text-center py-12">
                <i class="fas fa-layer-group text-4xl text-slate-600 mb-4"></i>
                <p class="text-slate-400 mb-4">No open positions found</p>
                <button @click="fetchPositions()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    <i class="fas fa-sync-alt mr-2"></i>
                    Refresh Positions
                </button>
            </div>

            <!-- Grouped Positions -->
            <div x-show="!isLoading && !error && filteredPositions.length > 0 && allPositions.length > 0" class="space-y-3">
                <template x-for="group in groupedPositions" :key="`${group.underlying}|${group.chainId}|${group.positions[0]?.expires_at || group.positions[0]?.opened_at}`">
                    <div class="bg-slate-800 rounded-lg overflow-hidden" x-data="{ expanded: false }">
                        <!-- Group Header (Clickable) -->
                        <div class="bg-slate-700 px-6 py-2 border-b border-slate-600 cursor-pointer hover:bg-slate-600 transition-colors" 
                             @click="expanded = !expanded">
                            <div class="header-stats-grid">
                                <!-- Symbol Column -->
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-chevron-right text-slate-400 transition-transform duration-200"
                                       :class="{ 'rotate-90': expanded }"></i>
                                    <div class="flex flex-col">
                                        <h3 class="text-lg font-semibold text-slate-100" x-text="group.displayKey"></h3>
                                        <span x-show="getUnderlyingIVR(group.underlying) !== null"
                                              class="text-sm -mt-1"
                                              :class="getUnderlyingIVR(group.underlying) >= 50 ? 'font-bold text-yellow-400' : (getUnderlyingIVR(group.underlying) >= 30 ? 'font-normal text-white' : 'font-normal text-slate-400')"
                                              x-text="getUnderlyingIVR(group.underlying)"></span>
                                    </div>
                                </div>
                                
                                <!-- Price Column -->
                                <div class="flex items-center space-x-2" :key="`price-${group.underlying}-${quoteUpdateCounter}`">
                                    <template x-if="getUnderlyingQuote(group.underlying)">
                                        <div class="flex items-center space-x-2">
                                            <!-- Price with colored background -->
                                            <div class="px-3 py-1 rounded-lg font-medium"
                                                 :class="getUnderlyingQuote(group.underlying).change >= 0 ? 'bg-green-800 hover:bg-green-900' : 'bg-red-700 hover:bg-red-800'">
                                                <span class="text-lg font-semibold text-white"
                                                      x-text="formatNumber(getUnderlyingQuote(group.underlying).price)"></span>
                                            </div>
                                            <!-- Change data with black background - 2 lines -->
                                            <div class="px-3 py-1 rounded-lg bg-black">
                                                <div class="text-xs font-medium leading-tight"
                                                     :class="getUnderlyingQuote(group.underlying).change >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(group.underlying).change >= 0 ? '+' : '') + formatNumber(getUnderlyingQuote(group.underlying).change)">
                                                </div>
                                                <div class="text-xs font-medium leading-tight"
                                                     :class="getUnderlyingQuote(group.underlying).changePercent >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(group.underlying).changePercent >= 0 ? '+' : '') + getUnderlyingQuote(group.underlying).changePercent.toFixed(2) + '%'">
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <template x-if="!getUnderlyingQuote(group.underlying)">
                                        <span class="text-sm text-slate-400">
                                            <i class="fas fa-spinner fa-spin mr-1"></i>
                                            Loading...
                                        </span>
                                    </template>
                                </div>
                                
                                <!-- Order Chains Link Column -->
                                <div class="flex items-center">
                                    <a :href="'/chains?underlying=' + encodeURIComponent(group.underlying) + (selectedAccount ? '&account=' + encodeURIComponent(selectedAccount) : '')"
                                       @click.stop
                                       class="inline-flex items-center px-2 py-1 text-xs font-medium text-blue-300 hover:text-blue-200 bg-blue-900/30 hover:bg-blue-900/50 rounded border border-blue-700/50 hover:border-blue-600 transition-colors"
                                       title="View order chains for this symbol">
                                        <i class="fas fa-link"></i>
                                    </a>
                                </div>

                                <!-- Aligned stat columns -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">Cost Basis</div>
                                    <div class="font-semibold text-sm text-right"
                                         :class="getGroupCostBasis(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupCostBasis(group.positions))"></div>
                                </div>

                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">NetLiq</div>
                                    <div class="font-semibold text-sm text-slate-100 text-right"
                                         x-text="formatNumber(getGroupNetLiqWithLiveQuotes(group.positions))"></div>
                                </div>

                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">P&L</div>
                                    <div class="font-semibold text-sm text-right"
                                         :class="getGroupPnLWithLiveQuotes(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupPnLWithLiveQuotes(group.positions))"></div>
                                </div>

                                <!-- P&L Percent Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">% Ret</div>
                                    <div class="font-semibold text-sm text-center"
                                         :class="getGroupPnLPercent(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="getGroupPnLPercent(group.positions) !== null ? getGroupPnLPercent(group.positions) + '%' : ''"></div>
                                </div>

                                <!-- % Max Column -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowMaxPercent(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs text-center">% Max</div>
                                            <div class="font-semibold text-sm text-center"
                                                 :class="getMaxPercentColor(getGroupMaxPercent(group.positions))"
                                                 :title="getMaxPercentTooltip(group.positions)"
                                                 x-text="getGroupMaxPercent(group.positions)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowMaxPercent(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs text-center">—</div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Days Open Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">Days</div>
                                    <div class="text-sm text-center font-semibold text-slate-300"
                                         x-text="getGroupDaysOpen(group.positions) || ''"></div>
                                </div>

                                <!-- DTE Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">DTE</div>
                                    <div class="text-sm text-center"
                                         :class="getMinDTE(group.positions) <= 21 ? 'font-bold text-yellow-400' : 'font-semibold text-slate-300'"
                                         x-text="getMinDTE(group.positions) || ''"></div>
                                </div>

                                <!-- Strategy and Price Position Indicator (always present for consistent alignment) -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowPriceIndicator(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs font-semibold" x-text="getGroupStrategyLabel(group)"></div>
                                            <div class="price-position-indicator" x-html="getPricePositionIndicator(group.positions, group.underlying)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowPriceIndicator(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs font-semibold" x-text="getGroupStrategyLabel(group)"></div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Comments Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-left">Comments</div>
                                    <input type="text"
                                           :value="getPositionComment(group)"
                                           @input="updatePositionComment(group, $event.target.value)"
                                           @click.stop
                                           class="bg-transparent text-slate-100 text-sm border-none outline-none focus:bg-slate-700/30 rounded px-2 py-1 w-full"
                                           placeholder="">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Positions Table (Collapsible) -->
                        <div x-show="expanded"
                             class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead class="bg-slate-700/50">
                                    <tr>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Type</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Qty</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Exp</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">DTE</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Strike</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Cost Basis</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">NetLiq</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Unrealized P&L</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">P&L %</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-slate-800 divide-y divide-slate-700/50">
                                    <template x-for="position in group.positions" :key="position.symbol + position.account_number">
                                        <tr class="table-row-hover">
                                            <!-- Option Type (C/P) - moved to first -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-bold" 
                                                      :class="getOptionType(position) === 'C' ? 'text-green-400' : getOptionType(position) === 'P' ? 'text-red-400' : 'text-slate-400'"
                                                      x-text="getOptionType(position)"></span>
                                            </td>
                                            
                                            <!-- Quantity (negative for short positions) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-medium" 
                                                      :class="getSignedQuantity(position) > 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getSignedQuantity(position).toFixed(0)"></span>
                                            </td>
                                            
                                            <!-- Expiration Date -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getExpirationDate(position)"></span>
                                            </td>
                                            
                                            <!-- DTE (Days to Expiration) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs font-medium" 
                                                      :class="getDTE(position) <= 7 ? 'text-red-400' : getDTE(position) <= 30 ? 'text-yellow-400' : 'text-slate-300'"
                                                      x-text="getDTE(position)"></span>
                                            </td>
                                            
                                            <!-- Strike Price (options only) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getStrikePrice(position)"></span>
                                            </td>
                                            
                                            <!-- Cost Basis -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium"
                                                      :class="position.cost_basis >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(position.cost_basis)"></span>
                                            </td>

                                            <!-- NetLiq (mark price, negative for short positions) -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm text-slate-300" x-text="formatNumber(calculateLiveMarketValue(position))"></span>
                                            </td>

                                            <!-- Unrealized P&L -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium"
                                                      :class="calculateLivePositionPnL(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(calculateLivePositionPnL(position))"></span>
                                            </td>

                                            <!-- P&L % -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium"
                                                      :class="(calculateLivePositionPnL(position) / Math.abs(position.cost_basis || 1) * 100) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="(calculateLivePositionPnL(position) / Math.abs(position.cost_basis || 1) * 100).toFixed(1) + '%'"></span>
                                            </td>
                                        </tr>
                                    </template>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

</body>
</html>
