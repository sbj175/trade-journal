<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Positions - Trade Journal</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Shared CSS -->
    <link rel="stylesheet" href="/static/css/shared.css">
    
    <!-- Alpine.js for interactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Inline positions app -->
    <script>
        function positionsApp() {
            return {
                // Basic state
                allPositions: [],
                filteredPositions: [],
                accounts: [],
                accountBalances: {},
                underlyingQuotes: {},
                positionComments: {},
                selectedAccount: '',
                selectedInstrumentType: '',
                selectedUnderlying: '',
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                cacheInfo: null,
                ws: null,
                username: null,
                
                
                // Computed properties
                get currentAccountBalance() {
                    if (!this.selectedAccount || this.selectedAccount === '') {
                        const values = Object.values(this.accountBalances);
                        if (values.length === 0) return null;
                        
                        return values.reduce((acc, balance) => ({
                            cash_balance: (acc.cash_balance || 0) + (balance.cash_balance || 0),
                            derivative_buying_power: (acc.derivative_buying_power || 0) + (balance.derivative_buying_power || 0),
                            net_liquidating_value: (acc.net_liquidating_value || 0) + (balance.net_liquidating_value || 0)
                        }), { cash_balance: 0, derivative_buying_power: 0, net_liquidating_value: 0 });
                    }
                    return this.accountBalances[this.selectedAccount] || null;
                },
                
                get groupedPositions() {
                    if (this.isLoading || !this.allPositions || this.allPositions.length === 0) {
                        return [];
                    }

                    const groups = new Map();
                    this.filteredPositions.forEach(position => {
                        const underlying = this.getUnderlyingSymbol(position);
                        if (!underlying || underlying === 'Unknown') return;

                        // Group by (underlying, chain_id, strategy_type) for intelligent multi-chain display
                        // If position has chain_id (enriched), use it; otherwise group separately as "unenriched"
                        const chainId = position.chain_id || 'unenriched';
                        const strategyType = position.strategy_type || 'Unknown';

                        // Create a unique key combining underlying, chain_id, and strategy
                        const groupKey = `${underlying}|${chainId}|${strategyType}`;

                        // Create a display key that includes strategy for ambiguous underlyings
                        const displayKey = chainId !== 'unenriched' ? `${underlying} (${strategyType})` : underlying;

                        if (!groups.has(groupKey)) {
                            groups.set(groupKey, {
                                displayKey,
                                underlying,
                                chainId,
                                strategyType,
                                positions: []
                            });
                        }
                        groups.get(groupKey).positions.push(position);
                    });

                    // Convert to array and sort by underlying, then by chain_id
                    const result = Array.from(groups.values())
                        .sort((a, b) => {
                            if (a.underlying !== b.underlying) {
                                return a.underlying.localeCompare(b.underlying);
                            }
                            // Secondary sort by chain_id (unenriched last)
                            if (a.chainId === 'unenriched') return 1;
                            if (b.chainId === 'unenriched') return -1;
                            return (a.chainId || '').localeCompare(b.chainId || '');
                        });

                    return result;
                },
                
                // Initialize
                async init() {
                    console.log('Initializing positions page...');
                    // Check authentication first
                    try {
                        const authResponse = await fetch('/api/auth/verify');
                        if (!authResponse.ok) {
                            window.location.href = '/login';
                            return;
                        }
                        const authData = await authResponse.json();
                        this.username = authData.username;
                    } catch (error) {
                        console.error('Auth check failed:', error);
                        window.location.href = '/login';
                        return;
                    }

                    this.loadComments();
                    await this.fetchAccounts();
                    await this.fetchPositions();
                    this.initializeWebSocket();
                },
                

                // Basic methods (just essential ones for now)
                async fetchAccounts() {
                    try {
                        const response = await fetch('/api/accounts');
                        this.accounts = await response.json();
                        console.log('Loaded accounts:', this.accounts);
                    } catch (error) {
                        console.error('Failed to load accounts:', error);
                    }
                },
                
                async fetchPositions(includeSync = false, fastMode = true) {
                    this.isLoading = true;
                    this.error = null;
                    
                    try {
                        if (includeSync) {
                            // Use fast sync for positions page by default
                            const endpoint = fastMode ? '/api/sync-positions-only' : '/api/sync';
                            await fetch(endpoint, { method: 'POST' });
                        }
                        
                        const response = await fetch('/api/positions');
                        const data = await response.json();
                        
                        // Flatten positions from accounts
                        this.allPositions = [];
                        if (typeof data === 'object' && !Array.isArray(data)) {
                            Object.entries(data).forEach(([accountNumber, accountPositions]) => {
                                if (Array.isArray(accountPositions)) {
                                    // Add account_number to each position
                                    accountPositions.forEach(position => {
                                        position.account_number = accountNumber;
                                        this.allPositions.push(position);
                                    });
                                }
                            });
                        } else {
                            this.allPositions = Array.isArray(data) ? data : [];
                        }
                        
                        console.log('Sample position:', this.allPositions[0]);
                        console.log('Total positions loaded:', this.allPositions.length);
                        console.log('Accounts in positions:', [...new Set(this.allPositions.map(p => p.account_number))]);
                        this.applyFilters();
                        
                    } catch (error) {
                        console.error('Failed to load positions:', error);
                        this.error = 'Failed to load positions';
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                async loadAccountBalances() {
                    try {
                        const response = await fetch('/api/account-balances');
                        const data = await response.json();
                        const balances = data.balances || data;
                        
                        this.accountBalances = {};
                        if (Array.isArray(balances)) {
                            balances.forEach(balance => {
                                this.accountBalances[balance.account_number] = balance;
                            });
                        }
                    } catch (error) {
                        console.error('Failed to load account balances:', error);
                    }
                },
                
                initializeWebSocket() {
                    try {
                        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                        const wsUrl = `${protocol}//${location.host}/ws/quotes`;
                        
                        this.ws = new WebSocket(wsUrl);
                        
                        this.ws.onopen = () => {
                            console.log('WebSocket connected successfully');
                            this.liveQuotesActive = true;
                        };
                        
                        this.ws.onmessage = (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                console.log('WebSocket message received:', message);
                                
                                if (message.type === 'connected') {
                                    console.log('WebSocket connection confirmed, requesting quotes...');
                                    this.requestLiveQuotes();
                                } else if (message.type === 'quotes' && message.data) {
                                    for (const [symbol, quoteData] of Object.entries(message.data)) {
                                        if (quoteData && typeof quoteData === 'object') {
                                            this.underlyingQuotes[symbol] = quoteData;
                                        }
                                    }
                                    this.lastQuoteUpdate = new Date().toLocaleTimeString();
                                    console.log('Updated quotes for:', Object.keys(message.data));
                                } else if (message.error) {
                                    console.error('WebSocket error from server:', message.error);
                                }
                            } catch (error) {
                                console.error('Failed to parse WebSocket message:', error);
                            }
                        };
                        
                        this.ws.onclose = (event) => {
                            console.log('WebSocket closed. Code:', event.code, 'Reason:', event.reason);
                            this.liveQuotesActive = false;
                            setTimeout(() => this.initializeWebSocket(), 5000);
                        };
                        
                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                        };
                        
                    } catch (error) {
                        console.error('WebSocket error:', error);
                    }
                },
                
                requestLiveQuotes() {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                    
                    const underlyings = [...new Set(this.filteredPositions.map(p => this.getUnderlyingSymbol(p)).filter(s => s && s !== 'Unknown'))];
                    
                    if (underlyings.length > 0) {
                        console.log('Requesting quotes for:', underlyings);
                        this.ws.send(JSON.stringify({
                            subscribe: underlyings
                        }));
                    }
                },
                
                // Filtering
                applyFilters() {
                    console.log('Applying filters with selectedAccount:', this.selectedAccount);
                    console.log('All positions count:', this.allPositions.length);
                    
                    this.filteredPositions = this.allPositions.filter(position => {
                        if (this.selectedAccount && position.account_number !== this.selectedAccount) {
                            console.log(`Filtering out position ${position.symbol} - account ${position.account_number} != ${this.selectedAccount}`);
                            return false;
                        }
                        if (this.selectedInstrumentType && position.instrument_type !== this.selectedInstrumentType) {
                            return false;
                        }
                        if (this.selectedUnderlying) {
                            const underlying = this.getUnderlyingSymbol(position);
                            if (underlying !== this.selectedUnderlying) {
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    console.log('Filtered positions count:', this.filteredPositions.length);
                },
                
                filterPositions() {
                    this.applyFilters();
                },
                
                saveFilterPreferences() {
                    // Save filters to localStorage
                },
                
                // Utility methods
                getUnderlyingSymbol(position) {
                    if (position.underlying) {
                        return position.underlying;
                    }
                    
                    if (position.symbol) {
                        if (position.instrument_type === 'EQUITY') {
                            return position.symbol;
                        } else {
                            return position.symbol.split(' ')[0] || position.symbol.split('_')[0];
                        }
                    }
                    
                    return 'Unknown';
                },
                
                formatNumber(value, decimals = 2) {
                    if (value === null || value === undefined || isNaN(value)) return '0';
                    return new Intl.NumberFormat('en-US', {
                        minimumFractionDigits: decimals,
                        maximumFractionDigits: decimals
                    }).format(value);
                },
                
                // Position calculation stubs (minimal for now)
                getGroupCostBasis(positions) { return 0; },
                getGroupNetLiq(positions) { return 0; },
                getGroupPnL(positions) { return 0; },
                getGroupPnLPercent(positions) { return null; },
                getGroupDaysOpen(positions) { return null; },
                getGroupMaxPercent(positions) { return '—'; },
                getMinDTE(positions) { return null; },
                getStrategyLabel(positions) { return 'Strategy'; },
                shouldShowMaxPercent(positions) { return false; },
                shouldShowPriceIndicator(positions) { return false; },
                getPricePositionIndicator(positions, underlying) { return ''; },
                getUnderlyingQuote(underlying) { return null; },
                getUnderlyingIV(underlying) { return null; },
                getOptionType(position) { return 'Option'; },
                getSignedQuantity(position) { return position.quantity || 0; },
                getExpirationDate(position) { return position.expires_at || ''; },
                getStrikePrice(position) { return position.strike_price || ''; },
                getDTE(position) { return null; },
                getLivePnLPercent(position) { return 0; },
                
                // Comments
                loadComments() {
                    try {
                        this.positionComments = JSON.parse(localStorage.getItem('positionComments') || '{}');
                    } catch (error) {
                        this.positionComments = {};
                    }
                },
                
                getPositionComment(underlying) {
                    const key = `${underlying}_${this.selectedAccount || 'default'}`;
                    return this.positionComments[key] || '';
                },
                
                updatePositionComment(underlying, value) {
                    const key = `${underlying}_${this.selectedAccount || 'default'}`;
                    this.positionComments[key] = value;
                    localStorage.setItem('positionComments', JSON.stringify(this.positionComments));
                },

                async logout() {
                    try {
                        const response = await fetch('/api/auth/logout', { method: 'POST' });
                        if (response.ok) {
                            // Logout successful, redirect to login page
                            window.location.href = '/login';
                        } else {
                            console.error('Logout failed');
                        }
                    } catch (error) {
                        console.error('Logout error:', error);
                        // Force redirect to login page even if request fails
                        window.location.href = '/login';
                    }
                }
            };
        }
    </script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Page-specific styles -->
    <style>
        /* Price position specific styles */
        .price-between {
            color: #10b981;
        }
        
        .price-outside {
            color: #ef4444;
        }
        
        /* Strategy badge styles */
        .strategy-badge-complex {
            background: #7C3AED;
            border-color: #8B5CF6;
            color: #DDD6FE;
        }
        
        .strategy-badge-spread {
            background: #0891B2;
            border-color: #0EA5E9;
            color: #BFDBFE;
        }
        
        .strategy-badge-covered {
            background: #059669;
            border-color: #10B981;
            color: #A7F3D0;
        }
        
        .strategy-badge-single {
            background: #DC2626;
            border-color: #EF4444;
            color: #FECACA;
        }
        
        .strategy-badge-stock {
            background: #374151;
            border-color: #6B7280;
            color: #D1D5DB;
        }
        
        /* Aligned header grid */
        .header-stats-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.3rem;
            align-items: center;
            width: 100%;
        }
        
        .header-stat-column {
            flex-shrink: 0;
        }
        
        /* Strict column alignment - optimized for Comments space */
        .header-stats-grid > div:nth-child(1) { width: 100px; flex-shrink: 0; }  /* Symbol + chevron */
        .header-stats-grid > div:nth-child(2) { width: 160px; flex-shrink: 0; }  /* Price boxes */
        .header-stats-grid > div:nth-child(3) { width: 40px; flex-shrink: 0; }   /* Chain link */
        .header-stats-grid > div:nth-child(4) { width: 80px; flex-shrink: 0; }   /* Cost Basis */
        .header-stats-grid > div:nth-child(5) { width: 80px; flex-shrink: 0; }   /* Net Liq */
        .header-stats-grid > div:nth-child(6) { width: 70px; flex-shrink: 0; }   /* P&L */
        .header-stats-grid > div:nth-child(7) { width: 60px; flex-shrink: 0; }   /* % Ret */
        .header-stats-grid > div:nth-child(8) { width: 55px; flex-shrink: 0; }   /* % Max */
        .header-stats-grid > div:nth-child(9) { width: 50px; flex-shrink: 0; }   /* Days */
        .header-stats-grid > div:nth-child(10) { width: 50px; flex-shrink: 0; }  /* DTE */
        .header-stats-grid > div:nth-child(11) { width: 150px; flex-shrink: 0; } /* Strategy */
        .header-stats-grid > div:nth-child(12) { flex: 1; min-width: 200px; }    /* Comments */
        
        .header-stat-column {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
    </style>
</head>

<body class="min-h-screen bg-slate-900 text-slate-100">
    <div x-data="positionsApp()" x-init="init()">
        <!-- Navigation Header -->
        <nav class="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center space-x-8">
                        <div class="flex-shrink-0">
                            <h1 class="text-xl font-bold text-blue-400">
                                <i class="fas fa-chart-line mr-2"></i>
                                Trade Journal
                            </h1>
                        </div>
                        
                        <div class="hidden sm:flex space-x-4">
                            <a href="/chains"
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-link mr-1"></i>
                                Order Chains
                            </a>
                            <a href="/screener"
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-search mr-1"></i>
                                Options Screener
                            </a>
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-4">
                        <button @click="fetchPositions(true)" 
                                :disabled="isLoading"
                                class="bg-green-600 hover:bg-green-700 disabled:bg-green-800 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center">
                            <i class="fas fa-sync-alt mr-2" :class="{'loading-spinner': isLoading}"></i>
                            <span x-text="isLoading ? 'Syncing...' : 'Sync Positions'"></span>
                        </button>
                        
                        <!-- Last Synced Timestamp -->
                        <div class="text-xs text-slate-400" x-show="lastSyncTimestamp">
                            <i class="fas fa-clock mr-1"></i>
                            Last synced: <span x-text="lastSyncTimestamp"></span>
                        </div>
                        
                        <!-- Cache Freshness Indicator -->
                        <div class="text-xs" x-show="cacheInfo && cacheInfo.cached">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-database" 
                                   :class="cacheInfo && cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo && cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')"></i>
                                <span :class="cacheInfo && cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo && cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')">
                                    <span x-show="cacheInfo && cacheInfo.is_fresh">Fresh data</span>
                                    <span x-show="cacheInfo && !cacheInfo.is_fresh && cacheInfo.data_age_minutes < 360">
                                        <span x-text="cacheInfo ? Math.round(cacheInfo.data_age_minutes) : ''"></span>m old
                                    </span>
                                    <span x-show="cacheInfo && !cacheInfo.is_fresh && cacheInfo.data_age_minutes >= 360">
                                        <span x-text="cacheInfo ? Math.round(cacheInfo.data_age_minutes / 60) : ''"></span>h old
                                    </span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- Account Selector -->
                        <div class="flex items-center space-x-2">
                            <label for="account-select" class="text-sm font-medium text-slate-300">Account:</label>
                            <select
                                id="account-select"
                                x-model="selectedAccount"
                                @change="filterPositions(); saveFilterPreferences()"
                                class="bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2"
                            >
                                <option value="">All Accounts</option>
                                <template x-for="account in accounts" :key="account.account_number">
                                    <option
                                        :value="account.account_number"
                                        x-text="account.account_name || account.account_number"
                                    ></option>
                                </template>
                            </select>
                        </div>

                        <!-- User Menu with Logout -->
                        <div class="flex items-center space-x-4 ml-4 pl-4 border-l border-slate-600">
                            <div class="text-sm text-slate-300">
                                <i class="fas fa-user mr-1"></i>
                                <span x-text="username || 'User'"></span>
                            </div>
                            <button @click="logout()"
                                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                                <i class="fas fa-sign-out-alt mr-1"></i>
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Header Section -->
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-slate-100 mb-2">Open Positions</h2>
                <p class="text-slate-400">Current positions from your Tastytrade accounts</p>
            </div>

            <!-- Filters and Summary -->
            <div class="bg-slate-800 rounded-lg p-6 mb-6">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <!-- Account Balances (Left Side) -->
                    <div class="flex flex-wrap items-center gap-6 text-sm">
                        <template x-if="currentAccountBalance">
                            <div class="flex items-center gap-6">
                                <div>
                                    <div class="text-slate-400 text-xs">Cash</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.cash_balance)"></div>
                                </div>
                                <div>
                                    <div class="text-slate-400 text-xs">Option BP</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.derivative_buying_power)"></div>
                                </div>
                                <div>
                                    <div class="text-slate-400 text-xs">NetLiq</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.net_liquidating_value)"></div>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- Filters (Right Side) -->
                    <div class="flex flex-wrap items-center gap-4">
                        <!-- Instrument Type Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Type:</label>
                            <select x-model="selectedInstrumentType" @change="filterPositions()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Types</option>
                                <option value="EQUITY">Stocks</option>
                                <option value="EQUITY_OPTION">Options</option>
                            </select>
                        </div>

                        <!-- Underlying Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Underlying:</label>
                            <select x-model="selectedUnderlying" @change="filterPositions()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Underlyings</option>
                                <template x-for="underlying in underlyings" :key="underlying">
                                    <option :value="underlying" x-text="underlying"></option>
                                </template>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div x-show="isLoading" class="text-center py-12">
                <i class="fas fa-spinner fa-spin text-4xl text-blue-400 mb-4"></i>
                <p class="text-slate-400">Loading positions...</p>
            </div>

            <!-- Error State -->
            <div x-show="error && !isLoading" class="bg-red-900/20 border border-red-700 rounded-lg p-4 mb-6">
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-red-400 mr-3"></i>
                    <span class="text-red-200" x-text="error"></span>
                </div>
            </div>

            <!-- Empty State -->
            <div x-show="!isLoading && !error && filteredPositions.length === 0" class="text-center py-12">
                <i class="fas fa-layer-group text-4xl text-slate-600 mb-4"></i>
                <p class="text-slate-400 mb-4">No open positions found</p>
                <button @click="fetchPositions()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    <i class="fas fa-sync-alt mr-2"></i>
                    Refresh Positions
                </button>
            </div>

            <!-- Grouped Positions -->
            <div x-show="!isLoading && !error && filteredPositions.length > 0 && allPositions.length > 0" class="space-y-3">
                <template x-for="group in groupedPositions" :key="`${group.underlying}|${group.chainId}|${group.strategyType}`">
                    <div class="bg-slate-800 rounded-lg overflow-hidden" x-data="{ expanded: false }">
                        <!-- Group Header (Clickable) -->
                        <div class="bg-slate-700 px-6 py-2 border-b border-slate-600 cursor-pointer hover:bg-slate-600 transition-colors" 
                             @click="expanded = !expanded">
                            <div class="header-stats-grid">
                                <!-- Symbol Column -->
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-chevron-right text-slate-400 transition-transform duration-200"
                                       :class="{ 'rotate-90': expanded }"></i>
                                    <div class="flex flex-col">
                                        <h3 class="text-lg font-semibold text-slate-100" x-text="group.displayKey"></h3>
                                        <span x-show="getUnderlyingIV(group.underlying)"
                                              class="text-sm -mt-1"
                                              :class="getUnderlyingIV(group.underlying) >= 30 ? 'font-bold text-yellow-400' : (getUnderlyingIV(group.underlying) >= 20 ? 'font-normal text-white' : 'font-normal text-slate-400')"
                                              x-text="getUnderlyingIV(group.underlying)"></span>
                                    </div>
                                </div>
                                
                                <!-- Price Column -->
                                <div class="flex items-center space-x-2">
                                    <template x-if="getUnderlyingQuote(group.underlying)">
                                        <div class="flex items-center space-x-2">
                                            <!-- Price with colored background -->
                                            <div class="px-3 py-1 rounded-lg font-medium"
                                                 :class="getUnderlyingQuote(group.underlying).change >= 0 ? 'bg-green-800 hover:bg-green-900' : 'bg-red-700 hover:bg-red-800'">
                                                <span class="text-lg font-semibold text-white"
                                                      x-text="formatNumber(getUnderlyingQuote(group.underlying).price)"></span>
                                            </div>
                                            <!-- Change data with black background - 2 lines -->
                                            <div class="px-3 py-1 rounded-lg bg-black">
                                                <div class="text-xs font-medium leading-tight"
                                                     :class="getUnderlyingQuote(group.underlying).change >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(group.underlying).change >= 0 ? '+' : '') + formatNumber(getUnderlyingQuote(group.underlying).change)">
                                                </div>
                                                <div class="text-xs font-medium leading-tight"
                                                     :class="getUnderlyingQuote(group.underlying).changePercent >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(group.underlying).changePercent >= 0 ? '+' : '') + getUnderlyingQuote(group.underlying).changePercent.toFixed(2) + '%'">
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <template x-if="!getUnderlyingQuote(group.underlying)">
                                        <span class="text-sm text-orange-400" title="Live price data not available">
                                            <i class="fas fa-exclamation-triangle mr-1"></i>
                                            Price N/A
                                        </span>
                                    </template>
                                </div>
                                
                                <!-- Order Chains Link Column -->
                                <div class="flex items-center">
                                    <a :href="'/chains?underlying=' + encodeURIComponent(group.underlying) + (selectedAccount ? '&account=' + encodeURIComponent(selectedAccount) : '')"
                                       @click.stop
                                       class="inline-flex items-center px-2 py-1 text-xs font-medium text-blue-300 hover:text-blue-200 bg-blue-900/30 hover:bg-blue-900/50 rounded border border-blue-700/50 hover:border-blue-600 transition-colors"
                                       title="View order chains for this symbol">
                                        <i class="fas fa-link"></i>
                                    </a>
                                </div>

                                <!-- Aligned stat columns -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">Cost Basis</div>
                                    <div class="font-semibold text-sm text-right"
                                         :class="getGroupCostBasis(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupCostBasis(group.positions))"></div>
                                </div>

                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">NetLiq</div>
                                    <div class="font-semibold text-sm text-slate-100 text-right"
                                         x-text="formatNumber(getGroupNetLiq(group.positions))"></div>
                                </div>

                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">P&L</div>
                                    <div class="font-semibold text-sm text-right"
                                         :class="getGroupPnL(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupPnL(group.positions))"></div>
                                </div>

                                <!-- P&L Percent Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">% Ret</div>
                                    <div class="font-semibold text-sm text-center"
                                         :class="getGroupPnLPercent(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="getGroupPnLPercent(group.positions) !== null ? getGroupPnLPercent(group.positions) + '%' : ''"></div>
                                </div>

                                <!-- % Max Column -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowMaxPercent(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs text-center">% Max</div>
                                            <div class="font-semibold text-sm text-center"
                                                 :class="getMaxPercentColor(getGroupMaxPercent(group.positions))"
                                                 :title="getMaxPercentTooltip(group.positions)"
                                                 x-text="getGroupMaxPercent(group.positions)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowMaxPercent(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs text-center">—</div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Days Open Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">Days</div>
                                    <div class="text-sm text-center font-semibold text-slate-300"
                                         x-text="getGroupDaysOpen(group.positions) || ''"></div>
                                </div>

                                <!-- DTE Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">DTE</div>
                                    <div class="text-sm text-center"
                                         :class="getMinDTE(group.positions) <= 21 ? 'font-bold text-yellow-400' : 'font-semibold text-slate-300'"
                                         x-text="getMinDTE(group.positions) || ''"></div>
                                </div>

                                <!-- Strategy and Price Position Indicator (always present for consistent alignment) -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowPriceIndicator(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs" x-text="getStrategyLabel(group.positions)"></div>
                                            <div class="price-position-indicator" x-html="getPricePositionIndicator(group.positions, group.underlying)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowPriceIndicator(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs" x-text="getStrategyLabel(group.positions)"></div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Comments Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-left">Comments</div>
                                    <input type="text"
                                           :value="getPositionComment(group.underlying)"
                                           @input="updatePositionComment(group.underlying, $event.target.value)"
                                           @click.stop
                                           class="bg-transparent text-slate-100 text-sm border-none outline-none focus:bg-slate-700/30 rounded px-2 py-1 w-full"
                                           placeholder="">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Positions Table (Collapsible) -->
                        <div x-show="expanded"
                             class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead class="bg-slate-700/50">
                                    <tr>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Type</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Qty</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Exp</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">DTE</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Strike</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Cost Basis</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">NetLiq</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Unrealized P&L</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">P&L %</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-slate-800 divide-y divide-slate-700/50">
                                    <template x-for="position in group.positions" :key="position.symbol + position.account_number">
                                        <tr class="table-row-hover">
                                            <!-- Option Type (C/P) - moved to first -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-bold" 
                                                      :class="getOptionType(position) === 'C' ? 'text-green-400' : getOptionType(position) === 'P' ? 'text-red-400' : 'text-slate-400'"
                                                      x-text="getOptionType(position)"></span>
                                            </td>
                                            
                                            <!-- Quantity (negative for short positions) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-medium" 
                                                      :class="getSignedQuantity(position) > 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getSignedQuantity(position).toFixed(0)"></span>
                                            </td>
                                            
                                            <!-- Expiration Date -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getExpirationDate(position)"></span>
                                            </td>
                                            
                                            <!-- DTE (Days to Expiration) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs font-medium" 
                                                      :class="getDTE(position) <= 7 ? 'text-red-400' : getDTE(position) <= 30 ? 'text-yellow-400' : 'text-slate-300'"
                                                      x-text="getDTE(position)"></span>
                                            </td>
                                            
                                            <!-- Strike Price (options only) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getStrikePrice(position)"></span>
                                            </td>
                                            
                                            <!-- Cost Basis -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getCostBasisDisplay(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(getCostBasisDisplay(position))"></span>
                                            </td>
                                            
                                            <!-- NetLiq (mark price, negative for short positions) -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm text-slate-300" x-text="formatNumber(getNetLiq(position))"></span>
                                            </td>
                                            
                                            <!-- Unrealized P&L -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getLiveUnrealizedPnL(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(getLiveUnrealizedPnL(position))"></span>
                                            </td>
                                            
                                            <!-- P&L % -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getLivePnLPercent(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getLivePnLPercent(position).toFixed(1) + '%'"></span>
                                            </td>
                                        </tr>
                                    </template>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <script>
        function positionsApp() {
            return {
                // Data
                allPositions: [],
                filteredPositions: [],
                accounts: [],
                accountBalances: {},
                underlyings: [],
                underlyingQuotes: {},
                positionComments: {}, // Store comments by underlying symbol + account
                
                // WebSocket for live quotes
                ws: null,
                wsReconnectTimer: null,
                wsReconnectDelay: 5000,
                
                // Filters (with localStorage persistence)
                selectedAccount: '',
                selectedInstrumentType: '',
                selectedUnderlying: '',
                
                // State
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                cacheInfo: null, // Cache freshness information
                
                // Computed properties
                get totalUnrealizedPnL() {
                    return this.filteredPositions.reduce((sum, pos) => sum + this.getLiveUnrealizedPnL(pos), 0);
                },
                
                get currentAccountBalance() {
                    if (!this.selectedAccount || this.selectedAccount === '') {
                        // Sum all account balances
                        const values = Object.values(this.accountBalances);
                        if (values.length === 0) return null;
                        
                        const totals = values.reduce((acc, balance) => {
                            return {
                                cash_balance: (acc.cash_balance || 0) + (balance.cash_balance || 0),
                                derivative_buying_power: (acc.derivative_buying_power || 0) + (balance.derivative_buying_power || 0),
                                net_liquidating_value: (acc.net_liquidating_value || 0) + (balance.net_liquidating_value || 0)
                            };
                        }, {
                            cash_balance: 0,
                            derivative_buying_power: 0,
                            net_liquidating_value: 0
                        });
                        
                        return totals;
                    }
                    return this.accountBalances[this.selectedAccount] || null;
                },
                
                get groupedPositions() {
                    // Don't process if we're loading or have no data
                    if (this.isLoading || !this.allPositions || this.allPositions.length === 0) {
                        return [];
                    }
                    
                    // Group filtered positions by underlying symbol
                    const groups = new Map();
                    
                    this.filteredPositions.forEach(position => {
                        const underlying = position.underlying || position.symbol;
                        if (!underlying) {
                            console.warn('Position without underlying or symbol:', position);
                            return;
                        }
                        if (!groups.has(underlying)) {
                            groups.set(underlying, []);
                        }
                        groups.get(underlying).push(position);
                    });
                    
                    // Sort groups by underlying name and sort positions within each group
                    const sortedGroups = Array.from(groups.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                    
                    // Sort positions within each group: stocks first, then options by expiration and strike
                    const self = this; // Capture reference to the Alpine component
                    sortedGroups.forEach(([underlying, positions]) => {
                        positions.sort((a, b) => {
                            // Stocks before options
                            if (a.instrument_type === 'EQUITY' && b.instrument_type !== 'EQUITY') return -1;
                            if (a.instrument_type !== 'EQUITY' && b.instrument_type === 'EQUITY') return 1;
                            
                            // For options, sort by expiration then strike price (ascending)
                            if (a.instrument_type !== 'EQUITY' && b.instrument_type !== 'EQUITY') {
                                // First sort by expiration date
                                if (a.expires_at && b.expires_at && a.expires_at !== b.expires_at) {
                                    return new Date(a.expires_at) - new Date(b.expires_at);
                                }
                                
                                // Then sort by strike price (ascending)
                                const strikeA = self.getNumericStrikePrice(a);
                                const strikeB = self.getNumericStrikePrice(b);
                                
                                if (strikeA !== null && strikeB !== null && strikeA !== strikeB) {
                                    return strikeA - strikeB; // Ascending order
                                }
                                
                                // Fallback to symbol comparison if strikes are equal or unavailable
                                return a.symbol.localeCompare(b.symbol);
                            }
                            
                            // Default to symbol comparison
                            return a.symbol.localeCompare(b.symbol);
                        });
                    });
                    
                    return sortedGroups;
                },
                
                // Methods
                async init() {
                    await this.loadAccounts();
                    
                    // Load saved filter preferences after accounts are loaded
                    this.loadFilterPreferences();
                    
                    // Load saved position comments
                    this.loadPositionComments();
                    
                    // Load cached positions immediately for fast initial display
                    await this.loadCachedPositions();
                    
                    // Then fetch fresh positions in the background (smart sync)
                    this.fetchPositions(false);
                    
                    // Clean up WebSocket on page unload
                    window.addEventListener('beforeunload', () => {
                        if (this.ws) {
                            this.ws.close();
                        }
                    });
                },
                
                loadFilterPreferences() {
                    try {
                        // Use shared account selection key to sync between pages
                        const savedState = localStorage.getItem('tradeJournalState');
                        const sharedAccount = savedState ? JSON.parse(savedState).selectedAccount : null;
                        const savedAccount = sharedAccount || localStorage.getItem('positions_selectedAccount');
                        const savedInstrumentType = localStorage.getItem('positions_selectedInstrumentType');
                        const savedUnderlying = localStorage.getItem('positions_selectedUnderlying');
                        
                        // Validate saved account exists in current accounts list
                        if (savedAccount && this.accounts.some(acc => acc.account_number === savedAccount)) {
                            this.selectedAccount = savedAccount;
                        } else if (savedAccount) {
                            console.warn(`Saved account ${savedAccount} not found in current accounts list`);
                            // Clear invalid saved account
                            localStorage.removeItem('positions_selectedAccount');
                        }
                        
                        if (savedInstrumentType) this.selectedInstrumentType = savedInstrumentType;
                        if (savedUnderlying) this.selectedUnderlying = savedUnderlying;
                        
                        console.log('Loaded filter preferences:', {
                            account: this.selectedAccount,
                            instrumentType: this.selectedInstrumentType,
                            underlying: this.selectedUnderlying,
                            availableAccounts: this.accounts.map(a => a.account_number)
                        });
                    } catch (error) {
                        console.warn('Error loading filter preferences:', error);
                    }
                },
                
                saveFilterPreferences() {
                    try {
                        // Save to positions-specific keys
                        localStorage.setItem('positions_selectedAccount', this.selectedAccount);
                        localStorage.setItem('positions_selectedInstrumentType', this.selectedInstrumentType);
                        localStorage.setItem('positions_selectedUnderlying', this.selectedUnderlying);
                        
                        // Also save account to shared key for cross-page sync
                        try {
                            const existingState = localStorage.getItem('tradeJournalState');
                            const state = existingState ? JSON.parse(existingState) : {};
                            state.selectedAccount = this.selectedAccount;
                            localStorage.setItem('tradeJournalState', JSON.stringify(state));
                        } catch (sharedError) {
                            console.warn('Error updating shared state:', sharedError);
                        }
                        
                        console.log('Saved filter preferences:', {
                            account: this.selectedAccount,
                            instrumentType: this.selectedInstrumentType,
                            underlying: this.selectedUnderlying
                        });
                    } catch (error) {
                        console.warn('Error saving filter preferences:', error);
                    }
                },
                
                // Load cached positions immediately for fast initial display
                async loadCachedPositions() {
                    try {
                        console.log('Loading cached positions...');
                        const response = await fetch('/api/positions/cached');
                        if (!response.ok) {
                            console.warn('Failed to load cached positions:', response.statusText);
                            return;
                        }
                        
                        const data = await response.json();
                        console.log('Cached positions loaded:', data);
                        
                        // Set positions from cache
                        this.allPositions = [];
                        for (const [accountNumber, positions] of Object.entries(data.positions)) {
                            for (const position of positions) {
                                this.allPositions.push({
                                    ...position,
                                    account_number: accountNumber
                                });
                            }
                        }
                        
                        // Extract unique values for filters
                        this.underlyings = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))].sort();
                        
                        // Set cached quotes if available
                        if (data.quotes) {
                            this.underlyingQuotes = data.quotes;
                            console.log(`Loaded ${Object.keys(data.quotes).length} cached quotes`);
                        }
                        
                        // Apply filters to show cached data
                        this.filterPositions();
                        
                        // Clean up comments for positions that no longer exist
                        this.cleanupOrphanedComments();
                        
                        // Set cache info for UI indicators
                        this.cacheInfo = data.cache_info;
                        
                        // Load last sync timestamp in background (don't await)
                        this.loadLastSyncTimestamp();
                        
                        console.log('Cached positions ready for display');
                    } catch (error) {
                        console.warn('Error loading cached positions:', error);
                    }
                },
                
                // Comment management functions
                loadPositionComments() {
                    try {
                        const savedComments = localStorage.getItem('positions_comments');
                        if (savedComments) {
                            const comments = JSON.parse(savedComments);
                            
                            // Clean up old comments (older than 90 days)
                            const now = Date.now();
                            const ninetyDaysAgo = now - (90 * 24 * 60 * 60 * 1000);
                            
                            this.positionComments = {};
                            for (const [key, value] of Object.entries(comments)) {
                                // Handle both old format (string) and new format (object with text and timestamp)
                                if (typeof value === 'string') {
                                    // Old format - keep it but convert to new format
                                    this.positionComments[key] = {
                                        text: value,
                                        timestamp: now
                                    };
                                } else if (value && value.timestamp && value.timestamp > ninetyDaysAgo) {
                                    // New format - only keep if not too old
                                    this.positionComments[key] = value;
                                }
                            }
                            
                            // Save cleaned up comments
                            this.savePositionComments();
                        }
                    } catch (error) {
                        console.warn('Error loading position comments:', error);
                        this.positionComments = {};
                    }
                },
                
                savePositionComments() {
                    try {
                        localStorage.setItem('positions_comments', JSON.stringify(this.positionComments));
                    } catch (error) {
                        console.warn('Error saving position comments:', error);
                    }
                },
                
                getCommentKey(underlying) {
                    // Create a unique key combining underlying symbol and account
                    return `${underlying}_${this.selectedAccount || 'all'}`;
                },
                
                getPositionComment(underlying) {
                    const key = this.getCommentKey(underlying);
                    const commentData = this.positionComments[key];
                    
                    if (!commentData) {
                        return '';
                    }
                    
                    // Handle both old format (string) and new format (object)
                    if (typeof commentData === 'string') {
                        return commentData;
                    }
                    
                    return commentData.text || '';
                },
                
                updatePositionComment(underlying, comment) {
                    const key = this.getCommentKey(underlying);
                    if (comment.trim()) {
                        this.positionComments[key] = {
                            text: comment,
                            timestamp: Date.now()
                        };
                    } else {
                        delete this.positionComments[key];
                    }
                    this.savePositionComments();
                },
                
                cleanupOrphanedComments() {
                    // Get all current position keys
                    const currentPositionKeys = new Set();
                    const underlyings = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))];
                    
                    // Add keys for all accounts and "all" option
                    for (const underlying of underlyings) {
                        // Add key for "all accounts"
                        currentPositionKeys.add(`${underlying}_all`);
                        
                        // Add keys for each specific account
                        for (const account of this.accounts) {
                            currentPositionKeys.add(`${underlying}_${account.account_number}`);
                        }
                    }
                    
                    // Remove comments for positions that no longer exist
                    let hasChanges = false;
                    for (const key of Object.keys(this.positionComments)) {
                        if (!currentPositionKeys.has(key)) {
                            const commentData = this.positionComments[key];
                            const timestamp = typeof commentData === 'object' ? commentData.timestamp : null;
                            
                            // Only delete if comment is older than 7 days to handle rolled positions
                            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                            if (!timestamp || timestamp < sevenDaysAgo) {
                                delete this.positionComments[key];
                                hasChanges = true;
                            }
                        }
                    }
                    
                    if (hasChanges) {
                        this.savePositionComments();
                    }
                },
                
                async loadAccounts() {
                    try {
                        console.log('Loading accounts...');
                        const response = await fetch('/api/accounts');
                        const data = await response.json();
                        this.accounts = data.accounts || [];
                        
                        // Sort accounts in desired order: Roth, Individual, Traditional
                        this.accounts.sort((a, b) => {
                            const getAccountTypeOrder = (name) => {
                                const nameUpper = (name || '').toUpperCase();
                                if (nameUpper.includes('ROTH')) return 1;
                                if (nameUpper.includes('INDIVIDUAL')) return 2;
                                if (nameUpper.includes('TRADITIONAL')) return 3;
                                return 4; // Other account types go last
                            };
                            
                            const orderA = getAccountTypeOrder(a.account_name);
                            const orderB = getAccountTypeOrder(b.account_name);
                            
                            return orderA - orderB;
                        });
                        
                        // Also load account balances
                        await this.loadAccountBalances();
                        
                        console.log(`Loaded ${this.accounts.length} accounts`);
                    } catch (error) {
                        console.error('Error loading accounts:', error);
                    }
                },
                
                // Smart sync logic - check if sync is needed
                shouldSyncData() {
                    if (!this.cacheInfo) {
                        return true; // No cache info, sync needed
                    }
                    
                    // If data is fresh (less than 1 hour old), no sync needed
                    if (this.cacheInfo.is_fresh) {
                        return false;
                    }
                    
                    // If data is less than 2 hours old, still consider it fresh enough
                    if (this.cacheInfo.data_age_minutes < 120) {
                        return false;
                    }
                    
                    // If data is older than 2 hours, sync needed
                    return this.cacheInfo.data_age_minutes > 120;
                },
                
                async fetchPositions(forceSync = false) {
                    // Don't show loading initially since we have cached data
                    // Only show loading if we don't have cached data
                    if (!this.allPositions || this.allPositions.length === 0) {
                        this.isLoading = true;
                    }
                    this.error = null;
                    
                    // Add flag to prevent rendering issues during sync
                    if (forceSync) {
                        this.isLoading = true;
                    }
                    
                    try {
                        // Check if sync is needed based on cache freshness
                        const shouldSync = forceSync || this.shouldSyncData();
                        
                        if (shouldSync) {
                            // Clear all data to prevent mixing cached and fresh data
                            this.cacheInfo = null;
                            this.allPositions = [];
                            this.filteredPositions = [];
                            this.underlyings = [];
                            this.underlyingQuotes = {};
                            
                            // First, sync data from Tastytrade (includes both positions and order chains)
                            console.log('Starting unified sync...');
                            const syncResponse = await fetch('/api/sync', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({})
                            });
                            
                            if (!syncResponse.ok) {
                                throw new Error(`Sync failed: ${syncResponse.statusText}`);
                            }
                            
                            const syncResult = await syncResponse.json();
                            console.log('Sync completed:', syncResult);
                            
                            // Add a small delay to ensure database is fully updated
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                            // Now fetch updated positions after sync using the cached endpoint for consistency
                            const response = await fetch('/api/positions/cached');
                            if (!response.ok) {
                                throw new Error(`Failed to fetch positions: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            
                            // Flatten positions from all accounts (using cached endpoint format)
                            this.allPositions = [];
                            for (const [accountNumber, positions] of Object.entries(data.positions)) {
                                for (const position of positions) {
                                    this.allPositions.push({
                                        ...position,
                                        account_number: accountNumber
                                    });
                                }
                            }
                            
                            // Set cached quotes if available
                            if (data.quotes) {
                                this.underlyingQuotes = data.quotes;
                            }
                            
                            // Extract unique values for filters (accounts are loaded separately)
                            this.underlyings = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))].sort();
                            
                            // Add debugging to track data structure
                            console.log('Sample position after sync:', this.allPositions[0]);
                            console.log('Underlyings extracted:', this.underlyings.slice(0, 5));
                            
                            // Filter positions with fresh data
                            this.filterPositions();
                            
                            // Clean up comments for positions that no longer exist
                            this.cleanupOrphanedComments();
                            
                            // Fetch underlying quotes after positions are loaded
                            await this.fetchUnderlyingQuotes();
                            
                            // Update last sync timestamp after successful sync
                            await this.loadLastSyncTimestamp();
                            
                            // Reload account balances after sync
                            await this.loadAccountBalances();
                            
                            // Update cache info to show fresh data
                            this.cacheInfo = {
                                cached: false,
                                is_fresh: true,
                                data_age_minutes: 0,
                                last_sync: new Date().toISOString()
                            };
                            
                            console.log('Fresh positions loaded and cache updated');
                        } else {
                            console.log('Skipping sync - data is fresh enough');
                            // Still connect to WebSocket for live quotes if not already connected
                            if (!this.liveQuotesActive) {
                                await this.fetchUnderlyingQuotes();
                            }
                        }
                        
                    } catch (err) {
                        console.error('Error fetching positions:', err);
                        this.error = err.message;
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                async fetchUnderlyingQuotes() {
                    try {
                        // Get unique underlying symbols from positions
                        const underlyingSymbols = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))];
                        
                        // Also get individual option contract symbols for live NetLiq updates
                        const optionSymbols = [...new Set(this.allPositions
                            .filter(p => p.instrument_type && p.instrument_type.includes('OPTION'))
                            .map(p => p.symbol)
                        )];
                        
                        // Combine both underlying and option symbols
                        const allSymbols = [...underlyingSymbols, ...optionSymbols];
                        
                        if (allSymbols.length === 0) {
                            return;
                        }
                        
                        console.log(`Starting live quote streaming for ${allSymbols.length} symbols:`);
                        console.log(`  Underlyings (${underlyingSymbols.length}): ${underlyingSymbols.join(', ')}`);
                        console.log(`  Options (${optionSymbols.length}): ${optionSymbols.slice(0, 3).join(', ')}${optionSymbols.length > 3 ? '...' : ''}`);
                        
                        // Connect to WebSocket for live streaming quotes
                        this.connectWebSocket(allSymbols);
                        
                    } catch (err) {
                        console.warn('Error setting up quote streaming:', err);
                    }
                },
                
                connectWebSocket(symbols) {
                    // Close existing connection if any
                    if (this.ws) {
                        this.ws.close();
                    }
                    
                    // Clear any existing reconnect timer
                    if (this.wsReconnectTimer) {
                        clearTimeout(this.wsReconnectTimer);
                    }
                    
                    const wsUrl = `ws://${window.location.host}/ws/quotes`;
                    console.log(`Connecting to WebSocket at ${wsUrl}`);
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('✅ WebSocket connected for live quotes');
                        this.liveQuotesActive = true;
                        
                        // Subscribe to symbols
                        this.ws.send(JSON.stringify({
                            subscribe: symbols
                        }));
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            
                            if (message.type === 'quotes' && message.data) {
                                // Update quotes
                                this.underlyingQuotes = message.data;
                                this.lastQuoteUpdate = new Date();
                                const quotesReceived = Object.keys(this.underlyingQuotes).length;
                                
                                if (quotesReceived > 0) {
                                    console.log(`📊 Live update: ${quotesReceived} quotes at ${this.lastQuoteUpdate.toLocaleTimeString()}`);
                                }
                            } else if (message.error) {
                                console.error('WebSocket error:', message.error);
                            }
                        } catch (err) {
                            console.error('Error processing WebSocket message:', err);
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.liveQuotesActive = false;
                        
                        // Attempt to reconnect after delay
                        this.wsReconnectTimer = setTimeout(() => {
                            console.log('Attempting to reconnect WebSocket...');
                            this.connectWebSocket(symbols);
                        }, this.wsReconnectDelay);
                    };
                    
                    // Send periodic pings to keep connection alive
                    setInterval(() => {
                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(JSON.stringify({ ping: true }));
                        }
                    }, 30000); // Ping every 30 seconds
                },
                
                filterPositions() {
                    this.filteredPositions = this.allPositions.filter(position => {
                        if (this.selectedAccount && position.account_number !== this.selectedAccount) {
                            return false;
                        }
                        
                        if (this.selectedInstrumentType) {
                            if (this.selectedInstrumentType === 'EQUITY') {
                                // For EQUITY filter, only show stocks (not options)
                                if (!position.instrument_type || !position.instrument_type.includes('EQUITY') || position.instrument_type.includes('OPTION')) {
                                    return false;
                                }
                            } else if (this.selectedInstrumentType === 'EQUITY_OPTION') {
                                // For EQUITY_OPTION filter, only show options
                                if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                                    return false;
                                }
                            }
                        }
                        
                        if (this.selectedUnderlying) {
                            const underlying = position.underlying || position.symbol;
                            if (underlying !== this.selectedUnderlying) {
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    // Save filter preferences to localStorage
                    this.saveFilterPreferences();
                    
                    // Note: Sorting is now handled in the groupedPositions computed property
                },
                
                getGroupPnL(positions) {
                    return positions.reduce((sum, pos) => sum + this.getLiveUnrealizedPnL(pos), 0);
                },
                
                getGroupCostBasis(positions) {
                    return positions.reduce((sum, pos) => sum + this.getCostBasisDisplay(pos), 0);
                },
                
                getGroupNetLiq(positions) {
                    return positions.reduce((sum, pos) => sum + this.getNetLiq(pos), 0);
                },
                
                getMinDTE(positions) {
                    // Get the minimum DTE from all option positions in the group
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    
                    if (optionPositions.length === 0) {
                        return null; // No options in this group
                    }
                    
                    const dtes = optionPositions.map(pos => {
                        const dte = this.getDTE(pos);
                        // Convert DTE to number, handling special cases
                        if (dte === 'Expired') return -1;
                        if (dte === 'Today') return 0;
                        return parseInt(dte) || 0;
                    }).filter(dte => !isNaN(dte));
                    
                    if (dtes.length === 0) {
                        return null;
                    }
                    
                    const minDte = Math.min(...dtes);
                    
                    // Format back to string for display
                    if (minDte < 0) return 'Expired';
                    if (minDte === 0) return 'Today';
                    return minDte.toString();
                },
                
                shouldShowPriceIndicator(positions) {
                    // Only show price position indicator for spreads, butterflies, and condors
                    const strategy = this.getStrategyLabel(positions);
                    const spreadStrategies = [
                        'Bull Put Spread', 'Bear Call Spread', 'Bull Call Spread', 'Bear Put Spread',
                        'Iron Condor', 'Iron Butterfly', 'Butterfly', 'Straddle', 'Strangle'
                    ];
                    return spreadStrategies.includes(strategy);
                },
                
                getPricePositionIndicator(positions, underlying) {
                    const underlyingQuote = this.getUnderlyingQuote(underlying);
                    const currentPrice = underlyingQuote ? underlyingQuote.price : null;
                    
                    if (!currentPrice) {
                        return '<span class="text-slate-500">Price N/A</span>';
                    }
                    
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    const strikes = optionPositions.map(p => this.getNumericStrikePrice(p)).filter(s => s).sort((a, b) => a - b);
                    
                    if (strikes.length < 2) {
                        return '<span class="text-slate-500">No strikes</span>';
                    }
                    
                    // Format strikes for display
                    const formatStrike = (strike) => strike % 1 === 0 ? strike.toString() : strike.toFixed(1);
                    const formatPrice = (price) => price.toFixed(1);
                    
                    if (strikes.length === 2) {
                        // Two-leg spread
                        const [low, high] = strikes;
                        const currentPriceFormatted = formatPrice(currentPrice);
                        
                        if (currentPrice < low) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(low)}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(high)}</span>`;
                        } else if (currentPrice > high) {
                            return `<span class="strike-marker">${formatStrike(low)}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(high)}</span><span class="price-line"></span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(low)}</span><span class="price-line"></span><span class="price-marker price-between">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(high)}</span>`;
                        }
                    } else if (strikes.length === 4) {
                        // Iron Condor
                        const [s1, s2, s3, s4] = strikes;
                        const currentPriceFormatted = formatPrice(currentPrice);
                        
                        if (currentPrice < s1) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else if (currentPrice > s4) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span><span class="price-line"></span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else if (currentPrice >= s2 && currentPrice <= s3) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span><span class="price-marker price-between">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else if (currentPrice < s2) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s4)}</span>`;
                        }
                    } else if (strikes.length === 3) {
                        // Butterfly
                        const [s1, s2, s3] = strikes;
                        const currentPriceFormatted = formatPrice(currentPrice);
                        
                        if (currentPrice < s1) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        } else if (currentPrice > s3) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span><span class="price-line"></span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else if (Math.abs(currentPrice - s2) < Math.min(Math.abs(currentPrice - s1), Math.abs(currentPrice - s3))) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="price-marker price-between">◆${currentPriceFormatted}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(s1)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        }
                    }
                    
                    return '<span class="text-slate-500">Complex</span>';
                },
                
                getUnderlyingQuote(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    
                    if (!quote) {
                        return null;
                    }
                    
                    if (!quote.mark && quote.mark !== 0) {
                        return null;
                    }
                    
                    return {
                        price: quote.mark,
                        change: quote.change || 0,
                        changePercent: quote.change_percent || 0
                    };
                },
                
                getUnderlyingIV(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    
                    if (!quote) {
                        return null;
                    }
                    
                    // Check for IVR first (preferred), then fall back to IV
                    if (quote.ivr !== undefined && quote.ivr !== null) {
                        // Convert IVR from decimal to percentage with 1 decimal place
                        return (quote.ivr * 100).toFixed(1);
                    }
                    
                    if (quote.iv !== undefined && quote.iv !== null) {
                        // Format IV as percentage with 0 decimal places
                        return Math.round(quote.iv);
                    }
                    
                    return null;
                },
                
                // Option parsing and display methods
                getSignedQuantity(position) {
                    // The API provides signed quantities where negative = short
                    // But let's also check quantity_direction field as backup
                    let quantity = position.quantity || 0;
                    
                    // If quantity is positive but quantity_direction indicates short, make it negative
                    if (quantity > 0 && position.quantity_direction === 'Short') {
                        quantity = -quantity;
                    }
                    
                    return quantity;
                },
                
                getNetLiq(position) {
                    // For option positions, use live quote data if available
                    if (position.instrument_type && position.instrument_type.includes('OPTION')) {
                        const quote = this.underlyingQuotes[position.symbol];
                        if (quote && quote.mark) {
                            // Calculate live NetLiq: quantity * mark_price * 100 (for options)
                            const quantity = this.getSignedQuantity(position);
                            const liveNetLiq = quantity * quote.mark * 100;
                            return liveNetLiq;
                        }
                    }
                    
                    // Fallback to static market_value for stocks or when no live data
                    return position.market_value || 0;
                },
                
                getLiveUnrealizedPnL(position) {
                    // For option positions, calculate live P&L using current quotes
                    if (position.instrument_type && position.instrument_type.includes('OPTION')) {
                        const quote = this.underlyingQuotes[position.symbol];
                        if (quote && quote.mark) {
                            const liveNetLiq = this.getNetLiq(position);
                            const costBasis = position.cost_basis || 0;
                            const quantity = this.getSignedQuantity(position);
                            
                            if (quantity < 0) {
                                // Short position: P&L = cost_basis + market_value
                                // (cost_basis is what you received, market_value is negative for shorts)
                                return costBasis + liveNetLiq;
                            } else {
                                // Long position: P&L = market_value - cost_basis
                                return liveNetLiq - costBasis;
                            }
                        }
                    }
                    
                    // Fallback to static unrealized_pnl for stocks or when no live data
                    return position.unrealized_pnl || 0;
                },
                
                getLivePnLPercent(position) {
                    // Calculate live P&L percentage
                    if (position.instrument_type && position.instrument_type.includes('OPTION')) {
                        const quote = this.underlyingQuotes[position.symbol];
                        if (quote && quote.mark) {
                            const liveUnrealizedPnL = this.getLiveUnrealizedPnL(position);
                            const costBasis = Math.abs(position.cost_basis || 0);
                            
                            if (costBasis > 0) {
                                return (liveUnrealizedPnL / costBasis) * 100;
                            }
                            return 0;
                        }
                    }
                    
                    // Fallback to static pnl_percent for stocks or when no live data
                    return position.pnl_percent || 0;
                },
                
                formatNumber(num) {
                    // Format numbers with commas and 2 decimal places
                    if (num === null || num === undefined || isNaN(num)) return '0.00';
                    return num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                },
                
                getCostBasisDisplay(position) {
                    // Display cost basis with proper sign based on position direction
                    const costBasis = position.cost_basis || 0;
                    const quantity = this.getSignedQuantity(position);
                    
                    if (quantity < 0) {
                        // Short position: cost basis is money received (positive/credit)
                        return costBasis;
                    } else {
                        // Long position: cost basis is money paid (negative/debit)
                        return -costBasis;
                    }
                },
                
                parseOptionSymbol(symbol) {
                    // Parse option symbol like "IBIT  250404C00050000"
                    if (!symbol || typeof symbol !== 'string') return null;

                    const parts = symbol.trim().split(/\s+/);
                    if (parts.length < 2) return null;

                    const optionCode = parts[1];
                    if (optionCode.length < 15) return null;
                    
                    try {
                        // Extract components: YYMMDD + C/P + 8-digit strike
                        const expiration = optionCode.substring(0, 6);  // YYMMDD
                        const optionType = optionCode.substring(6, 7);  // C or P
                        const strikeStr = optionCode.substring(7);      // 8-digit strike
                        
                        // Parse expiration date
                        const year = 2000 + parseInt(expiration.substring(0, 2));
                        const month = parseInt(expiration.substring(2, 4));
                        const day = parseInt(expiration.substring(4, 6));
                        const expirationDate = new Date(year, month - 1, day);
                        
                        // Parse strike price (divide by 1000 to get actual price)
                        const strike = parseInt(strikeStr) / 1000;

                        return {
                            expiration: expirationDate,
                            optionType: optionType,
                            strike: strike
                        };
                    } catch (e) {
                        console.warn('Failed to parse option symbol:', symbol, e);
                        return null;
                    }
                },
                
                getStrikePrice(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    let strike = null;
                    
                    // First try the API field
                    if (position.strike_price !== null && position.strike_price !== undefined) {
                        strike = parseFloat(position.strike_price);
                    } else {
                        // Fallback to symbol parsing
                        const parsed = this.parseOptionSymbol(position.symbol);
                        if (parsed && parsed.strike) {
                            strike = parsed.strike;
                        }
                    }
                    
                    if (strike !== null) {
                        // Format to remove unnecessary decimal places
                        // $400.00 -> 400, $317.50 -> 317.5
                        const formatted = strike % 1 === 0 ? strike.toString() : strike.toFixed(2).replace(/\.?0+$/, '');
                        return formatted;
                    }
                    
                    return '';
                },
                
                getNumericStrikePrice(position) {
                    // Get numeric strike price for sorting purposes
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return null;
                    }

                    let strike = null;

                    // First try the API field
                    if (position.strike_price !== null && position.strike_price !== undefined) {
                        strike = parseFloat(position.strike_price);
                    } else {
                        // Fallback to symbol parsing
                        const parsed = this.parseOptionSymbol(position.symbol);
                        if (parsed && parsed.strike) {
                            strike = parsed.strike;
                        }
                    }

                    return strike; // Return raw numeric value for sorting
                },
                
                getOptionType(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    // First try the API field
                    if (position.option_type) {
                        return position.option_type;
                    }
                    
                    // Fallback to symbol parsing
                    const parsed = this.parseOptionSymbol(position.symbol);
                    if (parsed && parsed.optionType) {
                        return parsed.optionType;
                    }
                    
                    return '';
                },
                
                getExpirationDate(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    // First try the expires_at field from the API
                    if (position.expires_at) {
                        const date = new Date(position.expires_at);
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric'
                        });
                    }
                    
                    // Fallback to parsing from symbol
                    const parsed = this.parseOptionSymbol(position.symbol);
                    if (parsed && parsed.expiration) {
                        return parsed.expiration.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric'
                        });
                    }
                    
                    return '';
                },
                
                getDTE(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    let expirationDate = null;
                    
                    // First try the expires_at field from the API
                    if (position.expires_at) {
                        expirationDate = new Date(position.expires_at);
                    } else {
                        // Fallback to parsing from symbol
                        const parsed = this.parseOptionSymbol(position.symbol);
                        if (parsed && parsed.expiration) {
                            expirationDate = parsed.expiration;
                        }
                    }
                    
                    if (expirationDate) {
                        // Normalize both dates to midnight for accurate day counting
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        
                        const expiry = new Date(expirationDate);
                        expiry.setHours(0, 0, 0, 0);
                        
                        const timeDiff = expiry.getTime() - today.getTime();
                        const daysDiff = Math.round(timeDiff / (1000 * 3600 * 24));
                        
                        if (daysDiff < 0) {
                            return 'Expired';
                        } else if (daysDiff === 0) {
                            return 'Today';
                        } else {
                            return daysDiff.toString();
                        }
                    }
                    
                    return '';
                },
                
                // Debug method to log position data 
                debugPositionData() {
                    console.log('=== POSITION DEBUG INFO ===');
                    console.log('Total positions found:', this.allPositions.length);
                    
                    if (this.allPositions.length > 0) {
                        console.log('All instrument types:', [...new Set(this.allPositions.map(p => p.instrument_type))]);
                        
                        // Show first few positions regardless of type
                        console.log('First 3 positions:', this.allPositions.slice(0, 3));
                        
                        // Look for options with different possible instrument type values
                        const optionPosition = this.allPositions.find(p => 
                            p.instrument_type && 
                            (p.instrument_type.includes('OPTION') || 
                             p.instrument_type.includes('option') ||
                             p.symbol.includes(' ') || // Options often have spaces in symbol
                             p.expires_at)  // Options have expiration dates
                        );
                        
                        if (optionPosition) {
                            console.log('Found option-like position:', optionPosition);
                            console.log('Option position fields:', Object.keys(optionPosition));
                        } else {
                            console.log('No option-like positions found');
                        }
                    } else {
                        console.log('No positions at all - check API connection');
                    }
                    console.log('=== END DEBUG INFO ===');
                },
                
                
                getStrategyLabel(positions) {
                    // Recognize strategy from position group
                    if (!positions || positions.length === 0) {
                        return 'No Positions';
                    }

                    const underlying = positions[0]?.underlying || positions[0]?.symbol || 'UNKNOWN';
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    const stockPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('EQUITY') && !p.instrument_type.includes('OPTION'));
                    
                    // Pure stock positions
                    if (optionPositions.length === 0 && stockPositions.length > 0) {
                        return stockPositions.some(p => this.getSignedQuantity(p) < 0) ? 'Short Stock' : 'Long Stock';
                    }
                    
                    // Mixed stock and options
                    if (stockPositions.length > 0 && optionPositions.length === 1) {
                        const option = optionPositions[0];
                        const optionType = this.getOptionType(option);
                        const quantity = this.getSignedQuantity(option);
                        
                        if (optionType === 'C' && quantity < 0) {
                            return 'Covered Call';
                        }
                        // Could add more covered positions logic here
                    }
                    
                    // Pure option strategies
                    if (optionPositions.length === 1) {
                        const option = optionPositions[0];
                        const optionType = this.getOptionType(option);
                        const quantity = this.getSignedQuantity(option);
                        
                        if (quantity < 0) {
                            return optionType === 'P' ? 'Cash Secured Put' : 'Naked Call';
                        } else {
                            return optionType === 'P' ? 'Long Put' : 'Long Call';
                        }
                    }
                    
                    if (optionPositions.length === 2) {
                        const strikes = optionPositions.map(p => this.getNumericStrikePrice(p)).filter(s => s !== null && s !== undefined).sort((a, b) => a - b);
                        const quantities = optionPositions.map(p => this.getSignedQuantity(p));
                        const optionTypes = optionPositions.map(p => this.getOptionType(p));
                        const expirations = optionPositions.map(p => this.getExpirationDate(p));
                        
                        // Check if all options have same expiration and type
                        const sameExpiration = expirations.every(exp => exp === expirations[0]);
                        const sameType = optionTypes.every(type => type === optionTypes[0]);
                        const sameStrike = strikes.length === 2 && strikes[0] === strikes[1];
                        
                        if (sameStrike && sameExpiration && !sameType) {
                            // Same strike, different types = Straddle
                            return 'Straddle';
                        }
                        
                        if (!sameStrike && sameExpiration && !sameType) {
                            // Different strikes, different types = Strangle
                            return 'Strangle';
                        }
                        
                        if (!sameStrike && sameExpiration && sameType) {
                            // Different strikes, same type = Vertical Spread
                            const hasLong = quantities.some(q => q > 0);
                            const hasShort = quantities.some(q => q < 0);
                            
                            if (hasLong && hasShort) {
                                if (optionTypes[0] === 'P') {
                                    // Put spreads: Bull = sell higher strike, buy lower strike
                                    const shortPutIndex = quantities.findIndex(q => q < 0);
                                    const longPutIndex = quantities.findIndex(q => q > 0);
                                    const shortStrike = this.getNumericStrikePrice(optionPositions[shortPutIndex]);
                                    const longStrike = this.getNumericStrikePrice(optionPositions[longPutIndex]);
                                    return shortStrike > longStrike ? 'Bull Put Spread' : 'Bear Put Spread';
                                } else {
                                    // Call spreads: Bull = buy lower strike, sell higher strike  
                                    const shortCallIndex = quantities.findIndex(q => q < 0);
                                    const longCallIndex = quantities.findIndex(q => q > 0);
                                    const shortStrike = this.getNumericStrikePrice(optionPositions[shortCallIndex]);
                                    const longStrike = this.getNumericStrikePrice(optionPositions[longCallIndex]);
                                    return longStrike < shortStrike ? 'Bull Call Spread' : 'Bear Call Spread';
                                }
                            }
                        }
                        
                        return 'Two-Leg Strategy';
                    }
                    
                    if (optionPositions.length === 3) {
                        return 'Butterfly';
                    }
                    
                    if (optionPositions.length === 4) {
                        const putOptions = optionPositions.filter(p => this.getOptionType(p) === 'P');
                        const callOptions = optionPositions.filter(p => this.getOptionType(p) === 'C');
                        
                        if (putOptions.length === 2 && callOptions.length === 2) {
                            return 'Iron Condor';
                        } else if (putOptions.length === 4 || callOptions.length === 4) {
                            return 'Iron Butterfly';
                        }
                        
                        return 'Four-Leg Strategy';
                    }
                    
                    if (optionPositions.length > 4) {
                        return 'Complex Strategy';
                    }
                    
                    return 'Mixed Positions';
                },
                
                getStrategyBadgeClass(strategyLabel) {
                    // Return CSS class based on strategy type
                    const complexStrategies = ['Iron Condor', 'Iron Butterfly', 'Butterfly', 'Complex Strategy'];
                    const spreadStrategies = ['Bull Put Spread', 'Bear Call Spread', 'Bull Call Spread', 'Bear Put Spread', 'Two-Leg Strategy', 'Four-Leg Strategy', 'Straddle', 'Strangle'];
                    const coveredStrategies = ['Covered Call', 'Cash Secured Put'];
                    const singleStrategies = ['Long Call', 'Long Put', 'Naked Call', 'Naked Put'];
                    const stockStrategies = ['Long Stock', 'Short Stock'];
                    
                    if (complexStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-complex';
                    } else if (spreadStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-spread';
                    } else if (coveredStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-covered';
                    } else if (singleStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-single';
                    } else if (stockStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-stock';
                    } else {
                        return 'strategy-badge-stock'; // Default
                    }
                },
                
                shouldShowMaxPercent(positions) {
                    // Show % Max for defined-risk strategies with calculable max profit/loss
                    const strategy = this.getStrategyLabel(positions);
                    const definedRiskStrategies = [
                        'Bull Put Spread', 'Bear Call Spread',
                        'Bull Call Spread', 'Bear Put Spread',
                        'Butterfly', 'Iron Butterfly', 'Iron Condor'
                    ];
                    return definedRiskStrategies.includes(strategy);
                },
                
                getGroupDaysOpen(positions) {
                    if (!positions || positions.length === 0) {
                        return null;
                    }

                    // Get earliest opening date from positions
                    const openingDates = positions
                        .map(p => p.opened_at || p.open_date || p.entry_date)
                        .filter(d => d)
                        .map(d => new Date(d));

                    if (openingDates.length === 0) {
                        // Fallback: estimate based on expiration for options
                        const expirationDates = positions
                            .filter(p => p.expires_at)
                            .map(p => new Date(p.expires_at));

                        if (expirationDates.length > 0) {
                            const minExpiration = new Date(Math.min(...expirationDates));
                            const now = new Date();
                            const daysToExpiry = Math.floor((minExpiration - now) / (1000 * 60 * 60 * 24));

                            // Estimate opening as when position had 45 days to expiry (or 14 days ago minimum)
                            const estimatedDaysFromOpen = Math.max(45 - daysToExpiry, 14);
                            return estimatedDaysFromOpen;
                        }

                        return null;
                    }

                    const openingDate = new Date(Math.min(...openingDates));
                    const now = new Date();
                    const daysOpen = Math.floor((now - openingDate) / (1000 * 60 * 60 * 24));

                    return daysOpen;
                },
                
                getGroupPnLPercent(positions) {
                    if (!positions || positions.length === 0) {
                        return null;
                    }
                    
                    // % Ret = (P&L / Cost Basis) × 100
                    const totalPnL = this.getGroupPnL(positions);
                    const totalCostBasis = Math.abs(this.getGroupCostBasis(positions));
                    
                    if (totalCostBasis === 0) {
                        return null;
                    }
                    
                    const percent = (totalPnL / totalCostBasis) * 100;
                    return Math.round(percent * 10) / 10;
                },
                
                getGroupMaxPercent(positions) {
                    if (!this.shouldShowMaxPercent(positions)) {
                        return null;
                    }

                    const strategy = this.getStrategyLabel(positions);
                    const currentPnL = this.getGroupPnL(positions);
                    const costBasis = Math.abs(this.getGroupCostBasis(positions));

                    if (costBasis <= 0) {
                        return "—";
                    }

                    let maxProfit = 0;
                    let maxLoss = 0;

                    // Get option positions for strike calculations
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));

                    if (optionPositions.length >= 2) {
                        // Get strikes and calculate spread width
                        const strikes = optionPositions.map(p => this.getNumericStrikePrice(p)).filter(s => s !== null && s !== undefined).sort((a, b) => a - b);
                        const quantities = optionPositions.map(p => this.getSignedQuantity(p));

                        if (strikes.length >= 2) {
                            const strikeWidth = strikes[strikes.length - 1] - strikes[0]; // Max - Min strike
                            const numContracts = Math.abs(quantities[0]); // Number of contracts

                            if (strategy.includes('Bull Call') || strategy.includes('Bear Put')) {
                                // Debit spreads
                                maxProfit = (strikeWidth * numContracts * 100) - costBasis;
                                maxLoss = costBasis;
                            } else if (strategy.includes('Bear Call') || strategy.includes('Bull Put')) {
                                // Credit spreads
                                maxProfit = costBasis;
                                maxLoss = (strikeWidth * numContracts * 100) - costBasis;
                            } else if (strategy.includes('Iron Condor')) {
                                // Iron Condor: credit received is max profit, max loss is spread width - credit
                                maxProfit = costBasis; // Credit received (should be positive for credit strategies)

                                // For Iron Condor with 4 legs, calculate the spread width
                                // Method: find the gap between consecutive strikes to identify spread width
                                let spreadWidth = 0;
                                if (strikes.length >= 4) {
                                    // Calculate gaps between consecutive strikes
                                    const gaps = [];
                                    for (let i = 1; i < strikes.length; i++) {
                                        gaps.push(strikes[i] - strikes[i-1]);
                                    }
                                    // The spread width is typically the largest gap (between short strikes)
                                    // or we can use the fact that both spreads should be the same width
                                    spreadWidth = Math.max(...gaps);

                                    // Sanity check: if gap seems too large, use average gap
                                    const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
                                    if (spreadWidth > avgGap * 2) {
                                        spreadWidth = avgGap;
                                    }
                                } else {
                                    // Fallback: estimate from total width
                                    spreadWidth = strikeWidth / 3; // Conservative estimate for 4-leg spread
                                }

                                // Iron Condor max loss = (spread width * contracts * 100) - credit received
                                maxLoss = (spreadWidth * numContracts * 100) - costBasis;
                            }
                        }
                    }

                    if (maxProfit <= 0 && maxLoss <= 0) {
                        return "—";
                    }

                    let percent;
                    if (currentPnL >= 0) {
                        // Profit: calculate % of max profit
                        percent = maxProfit > 0 ? (currentPnL / maxProfit) * 100 : 0;
                    } else {
                        // Loss: calculate % of max loss (show as negative)
                        percent = maxLoss > 0 ? (currentPnL / maxLoss) * 100 : 0;
                    }

                    // Format: no sign for positive, minus sign for negative
                    if (percent >= 0) {
                        return percent.toFixed(1) + '%';
                    } else {
                        return percent.toFixed(1) + '%';
                    }
                },
                
                getMaxPercentColor(maxPercent) {
                    if (!maxPercent || maxPercent === "—") {
                        return 'text-slate-400';
                    }

                    const value = parseFloat(maxPercent.replace('%', ''));
                    if (value >= 50) {
                        return 'text-green-400';
                    } else if (value >= 25) {
                        return 'text-yellow-400';
                    } else if (value >= 0) {
                        return 'text-blue-400';
                    } else {
                        return 'text-red-400';
                    }
                },
                
                getMaxPercentTooltip(positions) {
                    if (!this.shouldShowMaxPercent(positions)) {
                        return '';
                    }

                    const strategy = this.getStrategyLabel(positions);
                    return `Percentage of maximum ${strategy.includes('Bull Call') || strategy.includes('Bear Put') ? 'profit' : 'profit'} achieved`;
                },
                
                async loadAccountBalances() {
                    try {
                        console.log('Fetching account balances...');
                        const response = await fetch('/api/account-balances');
                        
                        if (!response.ok) {
                            console.error('Failed to fetch account balances:', response.status, response.statusText);
                            return;
                        }
                        
                        const data = await response.json();
                        console.log('Account balances response:', data);
                        
                        // Store balances indexed by account number
                        this.accountBalances = {};
                        if (data.balances) {
                            data.balances.forEach(balance => {
                                this.accountBalances[balance.account_number] = balance;
                            });
                        }
                        
                        console.log('Loaded account balances:', this.accountBalances);
                        console.log('Current account balance computed:', this.currentAccountBalance);
                    } catch (error) {
                        console.error('Error loading account balances:', error);
                    }
                },
                
                // Load last sync timestamp
                async loadLastSyncTimestamp() {
                    try {
                        const response = await fetch('/api/sync/status');
                        const data = await response.json();
                        if (data.last_sync) {
                            // Format timestamp for display
                            const date = new Date(data.last_sync);
                            this.lastSyncTimestamp = date.toLocaleDateString('en-US', {
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        } else {
                            this.lastSyncTimestamp = '';
                        }
                    } catch (error) {
                        console.error('Error loading last sync timestamp:', error);
                        this.lastSyncTimestamp = '';
                    }
                }
            };
        }
    </script>
</body>
</html>