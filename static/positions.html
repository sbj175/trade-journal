<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Positions - Trade Journal</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Shared CSS -->
    <link rel="stylesheet" href="/static/css/shared.css">
    
    <!-- Alpine.js for interactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Inline positions app -->
    <script>
        function positionsApp() {
            return {
                // Basic state
                allPositions: [],
                filteredPositions: [],
                accounts: [],
                accountBalances: {},
                underlyingQuotes: {},
                positionComments: {},
                selectedAccount: '',
                selectedInstrumentType: '',
                selectedUnderlying: '',
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                cacheInfo: null,
                ws: null,
                username: null,
                
                
                // Computed properties
                get currentAccountBalance() {
                    if (!this.selectedAccount || this.selectedAccount === '') {
                        const values = Object.values(this.accountBalances);
                        if (values.length === 0) return null;
                        
                        return values.reduce((acc, balance) => ({
                            cash_balance: (acc.cash_balance || 0) + (balance.cash_balance || 0),
                            derivative_buying_power: (acc.derivative_buying_power || 0) + (balance.derivative_buying_power || 0),
                            net_liquidating_value: (acc.net_liquidating_value || 0) + (balance.net_liquidating_value || 0)
                        }), { cash_balance: 0, derivative_buying_power: 0, net_liquidating_value: 0 });
                    }
                    return this.accountBalances[this.selectedAccount] || null;
                },
                
                get groupedPositions() {
                    if (this.isLoading || !this.allPositions || this.allPositions.length === 0) {
                        return [];
                    }

                    const groups = new Map();
                    this.filteredPositions.forEach(position => {
                        const underlying = this.getUnderlyingSymbol(position);
                        if (!underlying || underlying === 'Unknown') return;

                        // Group by (underlying, chain_id, strategy_type) for intelligent multi-chain display
                        // If position has chain_id (enriched), use it; otherwise group separately as "unenriched"
                        const chainId = position.chain_id || 'unenriched';
                        const strategyType = position.strategy_type || 'Unknown';

                        // Create a unique key combining underlying, chain_id, and strategy
                        const groupKey = `${underlying}|${chainId}|${strategyType}`;

                        // Create a display key that includes strategy for ambiguous underlyings
                        const displayKey = chainId !== 'unenriched' ? `${underlying} (${strategyType})` : underlying;

                        if (!groups.has(groupKey)) {
                            groups.set(groupKey, {
                                displayKey,
                                underlying,
                                chainId,
                                strategyType,
                                positions: []
                            });
                        }
                        groups.get(groupKey).positions.push(position);
                    });

                    // Convert to array and sort by underlying, then by chain_id
                    const result = Array.from(groups.values())
                        .sort((a, b) => {
                            if (a.underlying !== b.underlying) {
                                return a.underlying.localeCompare(b.underlying);
                            }
                            // Secondary sort by chain_id (unenriched last)
                            if (a.chainId === 'unenriched') return 1;
                            if (b.chainId === 'unenriched') return -1;
                            return (a.chainId || '').localeCompare(b.chainId || '');
                        });

                    return result;
                },
                
                // Initialize
                async init() {
                    console.log('Initializing positions page...');
                    // Check authentication first
                    try {
                        const authResponse = await fetch('/api/auth/verify');
                        if (!authResponse.ok) {
                            window.location.href = '/login';
                            return;
                        }
                        const authData = await authResponse.json();
                        this.username = authData.username;
                    } catch (error) {
                        console.error('Auth check failed:', error);
                        window.location.href = '/login';
                        return;
                    }

                    this.loadComments();
                    await this.fetchAccounts();
                    await this.loadAccountBalances();
                    await this.fetchPositions();
                    this.initializeWebSocket();
                },
                

                // Basic methods (just essential ones for now)
                async fetchAccounts() {
                    try {
                        const response = await fetch('/api/accounts');
                        const data = await response.json();
                        this.accounts = data.accounts || [];
                        console.log('Loaded accounts:', this.accounts);
                    } catch (error) {
                        console.error('Failed to load accounts:', error);
                    }
                },
                
                async fetchPositions(includeSync = false, fastMode = true) {
                    this.isLoading = true;
                    this.error = null;
                    
                    try {
                        if (includeSync) {
                            // Use fast sync for positions page by default
                            const endpoint = fastMode ? '/api/sync-positions-only' : '/api/sync';
                            await fetch(endpoint, { method: 'POST' });
                        }
                        
                        const response = await fetch('/api/positions');
                        const data = await response.json();
                        
                        // Flatten positions from accounts
                        this.allPositions = [];
                        if (typeof data === 'object' && !Array.isArray(data)) {
                            Object.entries(data).forEach(([accountNumber, accountPositions]) => {
                                if (Array.isArray(accountPositions)) {
                                    // Add account_number to each position
                                    accountPositions.forEach(position => {
                                        position.account_number = accountNumber;
                                        this.allPositions.push(position);
                                    });
                                }
                            });
                        } else {
                            this.allPositions = Array.isArray(data) ? data : [];
                        }
                        
                        console.log('Sample position:', this.allPositions[0]);
                        console.log('Total positions loaded:', this.allPositions.length);
                        console.log('Accounts in positions:', [...new Set(this.allPositions.map(p => p.account_number))]);
                        this.applyFilters();
                        
                    } catch (error) {
                        console.error('Failed to load positions:', error);
                        this.error = 'Failed to load positions';
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                async loadAccountBalances() {
                    try {
                        const response = await fetch('/api/account-balances');
                        const data = await response.json();
                        const balances = data.balances || data;
                        
                        this.accountBalances = {};
                        if (Array.isArray(balances)) {
                            balances.forEach(balance => {
                                this.accountBalances[balance.account_number] = balance;
                            });
                        }
                    } catch (error) {
                        console.error('Failed to load account balances:', error);
                    }
                },
                
                initializeWebSocket() {
                    try {
                        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                        const wsUrl = `${protocol}//${location.host}/ws/quotes`;
                        
                        this.ws = new WebSocket(wsUrl);
                        
                        this.ws.onopen = () => {
                            console.log('WebSocket connected successfully');
                            this.liveQuotesActive = true;
                        };
                        
                        this.ws.onmessage = (event) => {
                            try {
                                const message = JSON.parse(event.data);
                                console.log('WebSocket message received:', message);
                                
                                if (message.type === 'connected') {
                                    console.log('WebSocket connection confirmed, requesting quotes...');
                                    this.requestLiveQuotes();
                                } else if (message.type === 'quotes' && message.data) {
                                    for (const [symbol, quoteData] of Object.entries(message.data)) {
                                        if (quoteData && typeof quoteData === 'object') {
                                            this.underlyingQuotes[symbol] = quoteData;
                                        }
                                    }
                                    this.lastQuoteUpdate = new Date().toLocaleTimeString();
                                    console.log('Updated quotes for:', Object.keys(message.data));
                                } else if (message.error) {
                                    console.error('WebSocket error from server:', message.error);
                                }
                            } catch (error) {
                                console.error('Failed to parse WebSocket message:', error);
                            }
                        };
                        
                        this.ws.onclose = (event) => {
                            console.log('WebSocket closed. Code:', event.code, 'Reason:', event.reason);
                            this.liveQuotesActive = false;
                            setTimeout(() => this.initializeWebSocket(), 5000);
                        };
                        
                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                        };
                        
                    } catch (error) {
                        console.error('WebSocket error:', error);
                    }
                },
                
                requestLiveQuotes() {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                    
                    const underlyings = [...new Set(this.filteredPositions.map(p => this.getUnderlyingSymbol(p)).filter(s => s && s !== 'Unknown'))];
                    
                    if (underlyings.length > 0) {
                        console.log('Requesting quotes for:', underlyings);
                        this.ws.send(JSON.stringify({
                            subscribe: underlyings
                        }));
                    }
                },
                
                // Filtering
                applyFilters() {
                    console.log('Applying filters with selectedAccount:', this.selectedAccount);
                    console.log('All positions count:', this.allPositions.length);
                    
                    this.filteredPositions = this.allPositions.filter(position => {
                        if (this.selectedAccount && position.account_number !== this.selectedAccount) {
                            console.log(`Filtering out position ${position.symbol} - account ${position.account_number} != ${this.selectedAccount}`);
                            return false;
                        }
                        if (this.selectedInstrumentType && position.instrument_type !== this.selectedInstrumentType) {
                            return false;
                        }
                        if (this.selectedUnderlying) {
                            const underlying = this.getUnderlyingSymbol(position);
                            if (underlying !== this.selectedUnderlying) {
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    console.log('Filtered positions count:', this.filteredPositions.length);
                },
                
                filterPositions() {
                    this.applyFilters();
                },
                
                saveFilterPreferences() {
                    // Save filters to localStorage
                },
                
                // Utility methods
                getUnderlyingSymbol(position) {
                    if (position.underlying) {
                        return position.underlying;
                    }
                    
                    if (position.symbol) {
                        if (position.instrument_type === 'EQUITY') {
                            return position.symbol;
                        } else {
                            return position.symbol.split(' ')[0] || position.symbol.split('_')[0];
                        }
                    }
                    
                    return 'Unknown';
                },
                
                formatNumber(value, decimals = 2) {
                    if (value === null || value === undefined || isNaN(value)) return '0';
                    return new Intl.NumberFormat('en-US', {
                        minimumFractionDigits: decimals,
                        maximumFractionDigits: decimals
                    }).format(value);
                },
                
                // Position calculation functions
                getGroupCostBasis(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                },
                getGroupNetLiq(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.market_value || 0), 0);
                },
                getGroupPnL(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.unrealized_pnl || 0), 0);
                },
                getGroupPnLPercent(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    const totalCostBasis = positions.reduce((sum, pos) => sum + Math.abs(pos.cost_basis || 0), 0);
                    const totalPnL = this.getGroupPnL(positions);
                    if (totalCostBasis === 0) return null;
                    return ((totalPnL / totalCostBasis) * 100).toFixed(2);
                },
                getGroupDaysOpen(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    const firstPos = positions[0];
                    if (!firstPos.opened_at) return null;
                    const openedDate = new Date(firstPos.opened_at);
                    const now = new Date();
                    const days = Math.floor((now - openedDate) / (1000 * 60 * 60 * 24));
                    return days > 0 ? days : 0;
                },
                getGroupMaxPercent(positions) {
                    // For Iron Condor style positions, calculate max profit percentage
                    const totalCostBasis = positions.reduce((sum, pos) => sum + Math.abs(pos.cost_basis || 0), 0);
                    if (totalCostBasis === 0) return '—';
                    const totalPnL = this.getGroupPnL(positions);
                    const maxProfit = positions.reduce((sum, pos) => sum + (pos.market_value || 0), 0);
                    if (maxProfit >= totalPnL) return '—';
                    const maxPercent = ((Math.abs(maxProfit) / totalCostBasis) * 100).toFixed(1);
                    return maxPercent + '%';
                },
                getMinDTE(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    let minDTE = null;
                    for (const pos of positions) {
                        if (pos.expires_at) {
                            const expDate = new Date(pos.expires_at);
                            const now = new Date();
                            const dte = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
                            if (minDTE === null || dte < minDTE) {
                                minDTE = dte;
                            }
                        }
                    }
                    return minDTE;
                },
                getStrategyLabel(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return 'Unknown';
                    // Check if positions include both calls and puts (Iron Condor style)
                    const hasCall = positions.some(p => p.option_type === 'Call' || p.symbol.includes('C'));
                    const hasPut = positions.some(p => p.option_type === 'Put' || p.symbol.includes('P'));
                    if (hasCall && hasPut) return 'Spread';
                    if (hasCall) return 'Call';
                    if (hasPut) return 'Put';
                    return 'Stock';
                },
                shouldShowMaxPercent(positions) {
                    if (!Array.isArray(positions)) return false;
                    // Show max percent for spreads and similar limited-risk strategies
                    const hasCall = positions.some(p => p.option_type === 'Call' || p.symbol.includes('C'));
                    const hasPut = positions.some(p => p.option_type === 'Put' || p.symbol.includes('P'));
                    return hasCall && hasPut;
                },
                shouldShowPriceIndicator(positions) {
                    if (!Array.isArray(positions)) return false;
                    // Show price indicator for spreads (has both calls and puts)
                    const hasCall = positions.some(p => p.option_type === 'Call' || p.symbol.includes('C'));
                    const hasPut = positions.some(p => p.option_type === 'Put' || p.symbol.includes('P'));
                    return hasCall && hasPut;
                },
                getPricePositionIndicator(positions, underlying) {
                    if (!Array.isArray(positions)) return '';
                    const quote = this.getUnderlyingQuote(underlying);
                    if (!quote) return '';

                    const calls = positions.filter(p => p.option_type === 'Call' || p.symbol.includes('C'));
                    const puts = positions.filter(p => p.option_type === 'Put' || p.symbol.includes('P'));

                    if (calls.length === 0 || puts.length === 0) return '';

                    const callStrike = Math.max(...calls.map(p => p.strike_price || 0).filter(x => x > 0));
                    const putStrike = Math.min(...puts.map(p => p.strike_price || 0).filter(x => x > 0));
                    const price = quote.price || 0;

                    if (price < putStrike) return '<span class="price-below">Below</span>';
                    if (price > callStrike) return '<span class="price-above">Above</span>';
                    return '<span class="price-between">Between</span>';
                },
                getUnderlyingQuote(underlying) {
                    return this.underlyingQuotes[underlying] || null;
                },
                getUnderlyingIV(underlying) {
                    const quote = this.getUnderlyingQuote(underlying);
                    if (!quote || !quote.iv) return null;
                    return (quote.iv * 100).toFixed(1);
                },
                getOptionType(position) {
                    if (position.option_type) return position.option_type.charAt(0).toUpperCase();
                    if (position.symbol.includes('C')) return 'C';
                    if (position.symbol.includes('P')) return 'P';
                    return '—';
                },
                getSignedQuantity(position) {
                    const qty = position.quantity || 0;
                    if (position.quantity_direction === 'Short') return -qty;
                    return qty;
                },
                getExpirationDate(position) {
                    if (!position.expires_at) return '';
                    const date = new Date(position.expires_at);
                    return date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                },
                getStrikePrice(position) {
                    return position.strike_price ? position.strike_price.toFixed(2) : '';
                },
                getDTE(position) {
                    if (!position.expires_at) return null;
                    const expDate = new Date(position.expires_at);
                    const now = new Date();
                    const dte = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
                    return dte > 0 ? dte : 0;
                },
                getLivePnLPercent(position) {
                    if (!position.cost_basis || position.cost_basis === 0) return 0;
                    return ((position.unrealized_pnl || 0) / Math.abs(position.cost_basis) * 100).toFixed(1);
                },
                
                // Comments
                loadComments() {
                    try {
                        this.positionComments = JSON.parse(localStorage.getItem('positionComments') || '{}');
                    } catch (error) {
                        this.positionComments = {};
                    }
                },
                
                getPositionComment(underlying) {
                    const key = `${underlying}_${this.selectedAccount || 'default'}`;
                    return this.positionComments[key] || '';
                },
                
                updatePositionComment(underlying, value) {
                    const key = `${underlying}_${this.selectedAccount || 'default'}`;
                    this.positionComments[key] = value;
                    localStorage.setItem('positionComments', JSON.stringify(this.positionComments));
                },

                async logout() {
                    try {
                        const response = await fetch('/api/auth/logout', { method: 'POST' });
                        if (response.ok) {
                            // Logout successful, redirect to login page
                            window.location.href = '/login';
                        } else {
                            console.error('Logout failed');
                        }
                    } catch (error) {
                        console.error('Logout error:', error);
                        // Force redirect to login page even if request fails
                        window.location.href = '/login';
                    }
                }
            };
        }
    </script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Page-specific styles -->
    <style>
        /* Price position specific styles */
        .price-between {
            color: #10b981;
        }
        
        .price-outside {
            color: #ef4444;
        }
        
        /* Strategy badge styles */
        .strategy-badge-complex {
            background: #7C3AED;
            border-color: #8B5CF6;
            color: #DDD6FE;
        }
        
        .strategy-badge-spread {
            background: #0891B2;
            border-color: #0EA5E9;
            color: #BFDBFE;
        }
        
        .strategy-badge-covered {
            background: #059669;
            border-color: #10B981;
            color: #A7F3D0;
        }
        
        .strategy-badge-single {
            background: #DC2626;
            border-color: #EF4444;
            color: #FECACA;
        }
        
        .strategy-badge-stock {
            background: #374151;
            border-color: #6B7280;
            color: #D1D5DB;
        }
        
        /* Aligned header grid */
        .header-stats-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.3rem;
            align-items: center;
            width: 100%;
        }
        
        .header-stat-column {
            flex-shrink: 0;
        }
        
        /* Strict column alignment - optimized for Comments space */
        .header-stats-grid > div:nth-child(1) { width: 100px; flex-shrink: 0; }  /* Symbol + chevron */
        .header-stats-grid > div:nth-child(2) { width: 160px; flex-shrink: 0; }  /* Price boxes */
        .header-stats-grid > div:nth-child(3) { width: 40px; flex-shrink: 0; }   /* Chain link */
        .header-stats-grid > div:nth-child(4) { width: 80px; flex-shrink: 0; }   /* Cost Basis */
        .header-stats-grid > div:nth-child(5) { width: 80px; flex-shrink: 0; }   /* Net Liq */
        .header-stats-grid > div:nth-child(6) { width: 70px; flex-shrink: 0; }   /* P&L */
        .header-stats-grid > div:nth-child(7) { width: 60px; flex-shrink: 0; }   /* % Ret */
        .header-stats-grid > div:nth-child(8) { width: 55px; flex-shrink: 0; }   /* % Max */
        .header-stats-grid > div:nth-child(9) { width: 50px; flex-shrink: 0; }   /* Days */
        .header-stats-grid > div:nth-child(10) { width: 50px; flex-shrink: 0; }  /* DTE */
        .header-stats-grid > div:nth-child(11) { width: 150px; flex-shrink: 0; } /* Strategy */
        .header-stats-grid > div:nth-child(12) { flex: 1; min-width: 200px; }    /* Comments */
        
        .header-stat-column {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
    </style>
</head>

<body class="min-h-screen bg-slate-900 text-slate-100">
    <div x-data="positionsApp()" x-init="init()">
        <!-- Navigation Header -->
        <nav class="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center space-x-8">
                        <div class="flex-shrink-0">
                            <h1 class="text-xl font-bold text-blue-400">
                                <i class="fas fa-chart-line mr-2"></i>
                                Trade Journal
                            </h1>
                        </div>
                        
                        <div class="hidden sm:flex space-x-4">
                            <a href="/chains"
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-link mr-1"></i>
                                Order Chains
                            </a>
                            <a href="/screener"
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-search mr-1"></i>
                                Options Screener
                            </a>
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-4">
                        <button @click="fetchPositions(true)" 
                                :disabled="isLoading"
                                class="bg-green-600 hover:bg-green-700 disabled:bg-green-800 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center">
                            <i class="fas fa-sync-alt mr-2" :class="{'loading-spinner': isLoading}"></i>
                            <span x-text="isLoading ? 'Syncing...' : 'Sync Positions'"></span>
                        </button>
                        
                        <!-- Last Synced Timestamp -->
                        <div class="text-xs text-slate-400" x-show="lastSyncTimestamp">
                            <i class="fas fa-clock mr-1"></i>
                            Last synced: <span x-text="lastSyncTimestamp"></span>
                        </div>
                        
                        <!-- Cache Freshness Indicator -->
                        <div class="text-xs" x-show="cacheInfo && cacheInfo.cached">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-database" 
                                   :class="cacheInfo && cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo && cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')"></i>
                                <span :class="cacheInfo && cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo && cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')">
                                    <span x-show="cacheInfo && cacheInfo.is_fresh">Fresh data</span>
                                    <span x-show="cacheInfo && !cacheInfo.is_fresh && cacheInfo.data_age_minutes < 360">
                                        <span x-text="cacheInfo ? Math.round(cacheInfo.data_age_minutes) : ''"></span>m old
                                    </span>
                                    <span x-show="cacheInfo && !cacheInfo.is_fresh && cacheInfo.data_age_minutes >= 360">
                                        <span x-text="cacheInfo ? Math.round(cacheInfo.data_age_minutes / 60) : ''"></span>h old
                                    </span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- Account Selector -->
                        <div class="flex items-center space-x-2">
                            <label for="account-select" class="text-sm font-medium text-slate-300">Account:</label>
                            <select
                                id="account-select"
                                x-model="selectedAccount"
                                @change="filterPositions(); saveFilterPreferences()"
                                class="bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2"
                            >
                                <option value="">All Accounts</option>
                                <template x-for="account in accounts" :key="account.account_number">
                                    <option
                                        :value="account.account_number"
                                        x-text="account.account_name || account.account_number"
                                    ></option>
                                </template>
                            </select>
                        </div>

                        <!-- User Menu with Logout -->
                        <div class="flex items-center space-x-4 ml-4 pl-4 border-l border-slate-600">
                            <div class="text-sm text-slate-300">
                                <i class="fas fa-user mr-1"></i>
                                <span x-text="username || 'User'"></span>
                            </div>
                            <button @click="logout()"
                                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                                <i class="fas fa-sign-out-alt mr-1"></i>
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Header Section -->
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-slate-100 mb-2">Open Positions</h2>
                <p class="text-slate-400">Current positions from your Tastytrade accounts</p>
            </div>

            <!-- Filters and Summary -->
            <div class="bg-slate-800 rounded-lg p-6 mb-6">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <!-- Account Balances (Left Side) -->
                    <div class="flex flex-wrap items-center gap-6 text-sm">
                        <template x-if="currentAccountBalance">
                            <div class="flex items-center gap-6">
                                <div>
                                    <div class="text-slate-400 text-xs">Cash</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.cash_balance)"></div>
                                </div>
                                <div>
                                    <div class="text-slate-400 text-xs">Option BP</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.derivative_buying_power)"></div>
                                </div>
                                <div>
                                    <div class="text-slate-400 text-xs">NetLiq</div>
                                    <div class="font-semibold text-base" x-text="formatNumber(currentAccountBalance.net_liquidating_value)"></div>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- Filters (Right Side) -->
                    <div class="flex flex-wrap items-center gap-4">
                        <!-- Instrument Type Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Type:</label>
                            <select x-model="selectedInstrumentType" @change="filterPositions()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Types</option>
                                <option value="EQUITY">Stocks</option>
                                <option value="EQUITY_OPTION">Options</option>
                            </select>
                        </div>

                        <!-- Underlying Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Underlying:</label>
                            <select x-model="selectedUnderlying" @change="filterPositions()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Underlyings</option>
                                <template x-for="underlying in underlyings" :key="underlying">
                                    <option :value="underlying" x-text="underlying"></option>
                                </template>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div x-show="isLoading" class="text-center py-12">
                <i class="fas fa-spinner fa-spin text-4xl text-blue-400 mb-4"></i>
                <p class="text-slate-400">Loading positions...</p>
            </div>

            <!-- Error State -->
            <div x-show="error && !isLoading" class="bg-red-900/20 border border-red-700 rounded-lg p-4 mb-6">
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-red-400 mr-3"></i>
                    <span class="text-red-200" x-text="error"></span>
                </div>
            </div>

            <!-- Empty State -->
            <div x-show="!isLoading && !error && filteredPositions.length === 0" class="text-center py-12">
                <i class="fas fa-layer-group text-4xl text-slate-600 mb-4"></i>
                <p class="text-slate-400 mb-4">No open positions found</p>
                <button @click="fetchPositions()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    <i class="fas fa-sync-alt mr-2"></i>
                    Refresh Positions
                </button>
            </div>

            <!-- Grouped Positions -->
            <div x-show="!isLoading && !error && filteredPositions.length > 0 && allPositions.length > 0" class="space-y-3">
                <template x-for="group in groupedPositions" :key="`${group.underlying}|${group.chainId}|${group.strategyType}`">
                    <div class="bg-slate-800 rounded-lg overflow-hidden" x-data="{ expanded: false }">
                        <!-- Group Header (Clickable) -->
                        <div class="bg-slate-700 px-6 py-2 border-b border-slate-600 cursor-pointer hover:bg-slate-600 transition-colors" 
                             @click="expanded = !expanded">
                            <div class="header-stats-grid">
                                <!-- Symbol Column -->
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-chevron-right text-slate-400 transition-transform duration-200"
                                       :class="{ 'rotate-90': expanded }"></i>
                                    <div class="flex flex-col">
                                        <h3 class="text-lg font-semibold text-slate-100" x-text="group.displayKey"></h3>
                                        <span x-show="getUnderlyingIV(group.underlying)"
                                              class="text-sm -mt-1"
                                              :class="getUnderlyingIV(group.underlying) >= 30 ? 'font-bold text-yellow-400' : (getUnderlyingIV(group.underlying) >= 20 ? 'font-normal text-white' : 'font-normal text-slate-400')"
                                              x-text="getUnderlyingIV(group.underlying)"></span>
                                    </div>
                                </div>
                                
                                <!-- Price Column -->
                                <div class="flex items-center space-x-2">
                                    <template x-if="getUnderlyingQuote(group.underlying)">
                                        <div class="flex items-center space-x-2">
                                            <!-- Price with colored background -->
                                            <div class="px-3 py-1 rounded-lg font-medium"
                                                 :class="getUnderlyingQuote(group.underlying).change >= 0 ? 'bg-green-800 hover:bg-green-900' : 'bg-red-700 hover:bg-red-800'">
                                                <span class="text-lg font-semibold text-white"
                                                      x-text="formatNumber(getUnderlyingQuote(group.underlying).price)"></span>
                                            </div>
                                            <!-- Change data with black background - 2 lines -->
                                            <div class="px-3 py-1 rounded-lg bg-black">
                                                <div class="text-xs font-medium leading-tight"
                                                     :class="getUnderlyingQuote(group.underlying).change >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(group.underlying).change >= 0 ? '+' : '') + formatNumber(getUnderlyingQuote(group.underlying).change)">
                                                </div>
                                                <div class="text-xs font-medium leading-tight"
                                                     :class="getUnderlyingQuote(group.underlying).changePercent >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(group.underlying).changePercent >= 0 ? '+' : '') + getUnderlyingQuote(group.underlying).changePercent.toFixed(2) + '%'">
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <template x-if="!getUnderlyingQuote(group.underlying)">
                                        <span class="text-sm text-orange-400" title="Live price data not available">
                                            <i class="fas fa-exclamation-triangle mr-1"></i>
                                            Price N/A
                                        </span>
                                    </template>
                                </div>
                                
                                <!-- Order Chains Link Column -->
                                <div class="flex items-center">
                                    <a :href="'/chains?underlying=' + encodeURIComponent(group.underlying) + (selectedAccount ? '&account=' + encodeURIComponent(selectedAccount) : '')"
                                       @click.stop
                                       class="inline-flex items-center px-2 py-1 text-xs font-medium text-blue-300 hover:text-blue-200 bg-blue-900/30 hover:bg-blue-900/50 rounded border border-blue-700/50 hover:border-blue-600 transition-colors"
                                       title="View order chains for this symbol">
                                        <i class="fas fa-link"></i>
                                    </a>
                                </div>

                                <!-- Aligned stat columns -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">Cost Basis</div>
                                    <div class="font-semibold text-sm text-right"
                                         :class="getGroupCostBasis(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupCostBasis(group.positions))"></div>
                                </div>

                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">NetLiq</div>
                                    <div class="font-semibold text-sm text-slate-100 text-right"
                                         x-text="formatNumber(getGroupNetLiq(group.positions))"></div>
                                </div>

                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">P&L</div>
                                    <div class="font-semibold text-sm text-right"
                                         :class="getGroupPnL(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupPnL(group.positions))"></div>
                                </div>

                                <!-- P&L Percent Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">% Ret</div>
                                    <div class="font-semibold text-sm text-center"
                                         :class="getGroupPnLPercent(group.positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="getGroupPnLPercent(group.positions) !== null ? getGroupPnLPercent(group.positions) + '%' : ''"></div>
                                </div>

                                <!-- % Max Column -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowMaxPercent(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs text-center">% Max</div>
                                            <div class="font-semibold text-sm text-center"
                                                 :class="getMaxPercentColor(getGroupMaxPercent(group.positions))"
                                                 :title="getMaxPercentTooltip(group.positions)"
                                                 x-text="getGroupMaxPercent(group.positions)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowMaxPercent(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs text-center">—</div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Days Open Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">Days</div>
                                    <div class="text-sm text-center font-semibold text-slate-300"
                                         x-text="getGroupDaysOpen(group.positions) || ''"></div>
                                </div>

                                <!-- DTE Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">DTE</div>
                                    <div class="text-sm text-center"
                                         :class="getMinDTE(group.positions) <= 21 ? 'font-bold text-yellow-400' : 'font-semibold text-slate-300'"
                                         x-text="getMinDTE(group.positions) || ''"></div>
                                </div>

                                <!-- Strategy and Price Position Indicator (always present for consistent alignment) -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowPriceIndicator(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs" x-text="getStrategyLabel(group.positions)"></div>
                                            <div class="price-position-indicator" x-html="getPricePositionIndicator(group.positions, group.underlying)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowPriceIndicator(group.positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs" x-text="getStrategyLabel(group.positions)"></div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>

                                <!-- Comments Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-left">Comments</div>
                                    <input type="text"
                                           :value="getPositionComment(group.underlying)"
                                           @input="updatePositionComment(group.underlying, $event.target.value)"
                                           @click.stop
                                           class="bg-transparent text-slate-100 text-sm border-none outline-none focus:bg-slate-700/30 rounded px-2 py-1 w-full"
                                           placeholder="">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Positions Table (Collapsible) -->
                        <div x-show="expanded"
                             class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead class="bg-slate-700/50">
                                    <tr>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Type</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Qty</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Exp</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">DTE</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Strike</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Cost Basis</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">NetLiq</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Unrealized P&L</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">P&L %</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-slate-800 divide-y divide-slate-700/50">
                                    <template x-for="position in group.positions" :key="position.symbol + position.account_number">
                                        <tr class="table-row-hover">
                                            <!-- Option Type (C/P) - moved to first -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-bold" 
                                                      :class="getOptionType(position) === 'C' ? 'text-green-400' : getOptionType(position) === 'P' ? 'text-red-400' : 'text-slate-400'"
                                                      x-text="getOptionType(position)"></span>
                                            </td>
                                            
                                            <!-- Quantity (negative for short positions) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-medium" 
                                                      :class="getSignedQuantity(position) > 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getSignedQuantity(position).toFixed(0)"></span>
                                            </td>
                                            
                                            <!-- Expiration Date -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getExpirationDate(position)"></span>
                                            </td>
                                            
                                            <!-- DTE (Days to Expiration) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs font-medium" 
                                                      :class="getDTE(position) <= 7 ? 'text-red-400' : getDTE(position) <= 30 ? 'text-yellow-400' : 'text-slate-300'"
                                                      x-text="getDTE(position)"></span>
                                            </td>
                                            
                                            <!-- Strike Price (options only) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getStrikePrice(position)"></span>
                                            </td>
                                            
                                            <!-- Cost Basis -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getCostBasisDisplay(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(getCostBasisDisplay(position))"></span>
                                            </td>
                                            
                                            <!-- NetLiq (mark price, negative for short positions) -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm text-slate-300" x-text="formatNumber(getNetLiq(position))"></span>
                                            </td>
                                            
                                            <!-- Unrealized P&L -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getLiveUnrealizedPnL(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(getLiveUnrealizedPnL(position))"></span>
                                            </td>
                                            
                                            <!-- P&L % -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getLivePnLPercent(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getLivePnLPercent(position).toFixed(1) + '%'"></span>
                                            </td>
                                        </tr>
                                    </template>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

</body>
</html>
