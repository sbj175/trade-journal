<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Positions - Trade Journal</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Alpine.js for interactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Custom styles -->
    <style>
        /* Custom dark theme colors */
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
            --accent-purple: #8b5cf6;
        }
        
        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }
        
        /* Loading animation */
        .loading-spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Custom table styles */
        .table-row-hover:hover {
            background-color: rgba(71, 85, 105, 0.3);
        }
        
        /* Price position indicator styles */
        .price-position-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #1e293b;
            border-radius: 6px;
            font-size: 11px;
            font-family: monospace;
        }
        
        .strike-marker {
            color: #94a3b8;
            font-weight: 600;
        }
        
        .price-marker {
            color: #fbbf24;
            font-weight: 800;
            font-size: 14px;
        }
        
        .price-line {
            width: 20px;
            height: 2px;
            background: #475569;
            display: inline-block;
            vertical-align: middle;
        }
        
        .price-between {
            color: #10b981;
        }
        
        .price-outside {
            color: #ef4444;
        }
        
        /* Strategy badge styles */
        .strategy-badge-complex {
            background: #7C3AED;
            border-color: #8B5CF6;
            color: #DDD6FE;
        }
        
        .strategy-badge-spread {
            background: #0891B2;
            border-color: #0EA5E9;
            color: #BFDBFE;
        }
        
        .strategy-badge-covered {
            background: #059669;
            border-color: #10B981;
            color: #A7F3D0;
        }
        
        .strategy-badge-single {
            background: #DC2626;
            border-color: #EF4444;
            color: #FECACA;
        }
        
        .strategy-badge-stock {
            background: #374151;
            border-color: #6B7280;
            color: #D1D5DB;
        }
        
        /* Aligned header grid */
        .header-stats-grid {
            display: grid;
            grid-template-columns: 60px 160px 120px 80px 80px 60px 80px 180px 250px;
            gap: 0.5rem;
            align-items: center;
        }
        
        .header-stat-column {
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
    </style>
</head>

<body class="min-h-screen bg-slate-900 text-slate-100">
    <div x-data="positionsApp()" x-init="init()">
        <!-- Navigation Header -->
        <nav class="bg-slate-800 border-b border-slate-700 sticky top-0 z-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between h-16">
                    <div class="flex items-center space-x-8">
                        <div class="flex-shrink-0">
                            <h1 class="text-xl font-bold text-blue-400">
                                <i class="fas fa-chart-line mr-2"></i>
                                Trade Journal
                            </h1>
                        </div>
                        
                        <div class="hidden sm:flex space-x-4">
                            <a href="/static/index-fixed.html" 
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-link mr-1"></i>
                                Order Chains
                            </a>
                            <a href="/static/strategy-config.html" 
                               class="text-slate-300 hover:text-white px-3 py-2 rounded-md text-sm font-medium transition-colors">
                                <i class="fas fa-cog mr-1"></i>
                                Strategy Config
                            </a>
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-4">
                        <button @click="fetchPositions(true)" 
                                :disabled="isLoading"
                                class="bg-green-600 hover:bg-green-700 disabled:bg-green-800 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center">
                            <i class="fas fa-sync-alt mr-2" :class="{'loading-spinner': isLoading}"></i>
                            <span x-text="isLoading ? 'Syncing...' : 'Sync Positions'"></span>
                        </button>
                        
                        <!-- Last Synced Timestamp -->
                        <div class="text-xs text-slate-400" x-show="lastSyncTimestamp">
                            <i class="fas fa-clock mr-1"></i>
                            Last synced: <span x-text="lastSyncTimestamp"></span>
                        </div>
                        
                        <!-- Cache Freshness Indicator -->
                        <div class="text-xs" x-show="cacheInfo && cacheInfo.cached">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-database" 
                                   :class="cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')"></i>
                                <span :class="cacheInfo.is_fresh ? 'text-green-400' : (cacheInfo.data_age_minutes < 360 ? 'text-yellow-400' : 'text-red-400')">
                                    <span x-show="cacheInfo.is_fresh">Fresh data</span>
                                    <span x-show="!cacheInfo.is_fresh && cacheInfo.data_age_minutes < 360">
                                        <span x-text="Math.round(cacheInfo.data_age_minutes)"></span>m old
                                    </span>
                                    <span x-show="!cacheInfo.is_fresh && cacheInfo.data_age_minutes >= 360">
                                        <span x-text="Math.round(cacheInfo.data_age_minutes / 60)"></span>h old
                                    </span>
                                </span>
                            </div>
                        </div>
                        
                        <!-- Account Selector -->
                        <div class="flex items-center space-x-2">
                            <label for="account-select" class="text-sm font-medium text-slate-300">Account:</label>
                            <select 
                                id="account-select"
                                x-model="selectedAccount" 
                                @change="filterPositions(); saveFilterPreferences()"
                                class="bg-slate-700 border border-slate-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2"
                            >
                                <option value="">All Accounts</option>
                                <template x-for="account in accounts" :key="account.account_number">
                                    <option 
                                        :value="account.account_number" 
                                        x-text="account.account_name || account.account_number"
                                    ></option>
                                </template>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Header Section -->
            <div class="mb-8">
                <h2 class="text-3xl font-bold text-slate-100 mb-2">Open Positions</h2>
                <p class="text-slate-400">Current positions from your Tastytrade accounts</p>
            </div>

            <!-- Filters and Summary -->
            <div class="bg-slate-800 rounded-lg p-6 mb-6">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <div class="flex flex-wrap items-center gap-4">
                        <!-- Instrument Type Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Type:</label>
                            <select x-model="selectedInstrumentType" @change="filterPositions()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Types</option>
                                <option value="EQUITY">Stocks</option>
                                <option value="EQUITY_OPTION">Options</option>
                            </select>
                        </div>

                        <!-- Underlying Filter -->
                        <div class="flex items-center space-x-2">
                            <label class="text-sm font-medium text-slate-300">Underlying:</label>
                            <select x-model="selectedUnderlying" @change="filterPositions()"
                                    class="bg-slate-700 border border-slate-600 text-slate-100 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2">
                                <option value="">All Underlyings</option>
                                <template x-for="underlying in underlyings" :key="underlying">
                                    <option :value="underlying" x-text="underlying"></option>
                                </template>
                            </select>
                        </div>
                    </div>

                    <!-- Summary Stats -->
                    <div class="flex items-center space-x-6 text-sm">
                        <div class="text-center">
                            <div class="text-slate-400">Positions</div>
                            <div class="font-semibold" x-text="filteredPositions.length"></div>
                        </div>
                        <div class="text-center">
                            <div class="text-slate-400">Total P&L</div>
                            <div class="font-semibold" 
                                 :class="totalUnrealizedPnL >= 0 ? 'text-green-400' : 'text-red-400'"
                                 x-text="formatNumber(totalUnrealizedPnL)"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div x-show="isLoading" class="text-center py-12">
                <i class="fas fa-spinner fa-spin text-4xl text-blue-400 mb-4"></i>
                <p class="text-slate-400">Loading positions...</p>
            </div>

            <!-- Error State -->
            <div x-show="error && !isLoading" class="bg-red-900/20 border border-red-700 rounded-lg p-4 mb-6">
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-red-400 mr-3"></i>
                    <span class="text-red-200" x-text="error"></span>
                </div>
            </div>

            <!-- Empty State -->
            <div x-show="!isLoading && !error && filteredPositions.length === 0" class="text-center py-12">
                <i class="fas fa-layer-group text-4xl text-slate-600 mb-4"></i>
                <p class="text-slate-400 mb-4">No open positions found</p>
                <button @click="fetchPositions()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                    <i class="fas fa-sync-alt mr-2"></i>
                    Refresh Positions
                </button>
            </div>

            <!-- Grouped Positions -->
            <div x-show="!isLoading && !error && filteredPositions.length > 0" class="space-y-3">
                <template x-for="[underlying, positions] in groupedPositions" :key="underlying">
                    <div class="bg-slate-800 rounded-lg overflow-hidden" x-data="{ expanded: false }">
                        <!-- Group Header (Clickable) -->
                        <div class="bg-slate-700 px-6 py-2 border-b border-slate-600 cursor-pointer hover:bg-slate-600 transition-colors" 
                             @click="expanded = !expanded">
                            <div class="header-stats-grid">
                                <!-- Symbol Column -->
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-chevron-right text-slate-400 transition-transform duration-200" 
                                       :class="{ 'rotate-90': expanded }"></i>
                                    <h3 class="text-lg font-semibold text-slate-100">
                                        <span x-text="underlying"></span>
                                        <span x-show="getUnderlyingIV(underlying)" 
                                              class="text-sm"
                                              :class="getUnderlyingIV(underlying) >= 30 ? 'font-bold text-yellow-400' : (getUnderlyingIV(underlying) >= 20 ? 'font-normal text-white' : 'font-normal text-slate-400')"
                                              x-text="getUnderlyingIV(underlying)"></span>
                                    </h3>
                                </div>
                                
                                <!-- Price Column -->
                                <div class="flex items-center space-x-2">
                                    <template x-if="getUnderlyingQuote(underlying)">
                                        <div class="flex items-center space-x-2">
                                            <!-- Price with colored background -->
                                            <div class="px-3 py-1 rounded-lg font-medium"
                                                 :class="getUnderlyingQuote(underlying).change >= 0 ? 'bg-green-800 hover:bg-green-900' : 'bg-red-700 hover:bg-red-800'">
                                                <span class="text-lg font-semibold text-white" 
                                                      x-text="formatNumber(getUnderlyingQuote(underlying).price)"></span>
                                            </div>
                                            <!-- Change data with black background - 2 lines -->
                                            <div class="px-3 py-1 rounded-lg bg-black">
                                                <div class="text-xs font-medium leading-tight" 
                                                     :class="getUnderlyingQuote(underlying).change >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(underlying).change >= 0 ? '+' : '') + formatNumber(getUnderlyingQuote(underlying).change)">
                                                </div>
                                                <div class="text-xs font-medium leading-tight" 
                                                     :class="getUnderlyingQuote(underlying).changePercent >= 0 ? 'text-green-400' : 'text-red-400'"
                                                     x-text="(getUnderlyingQuote(underlying).changePercent >= 0 ? '+' : '') + getUnderlyingQuote(underlying).changePercent.toFixed(2) + '%'">
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                    <template x-if="!getUnderlyingQuote(underlying)">
                                        <span class="text-sm text-orange-400" title="Live price data not available">
                                            <i class="fas fa-exclamation-triangle mr-1"></i>
                                            Price N/A
                                        </span>
                                    </template>
                                </div>
                                
                                <!-- Order Chains Link Column -->
                                <div class="flex items-center">
                                    <a :href="'/static/index-fixed.html?underlying=' + encodeURIComponent(underlying) + (selectedAccount ? '&account=' + encodeURIComponent(selectedAccount) : '')" 
                                       @click.stop
                                       class="inline-flex items-center px-2 py-1 text-xs font-medium text-blue-300 hover:text-blue-200 bg-blue-900/30 hover:bg-blue-900/50 rounded border border-blue-700/50 hover:border-blue-600 transition-colors" 
                                       title="View order chains for this symbol">
                                        <i class="fas fa-link mr-1"></i>
                                        Order Chains
                                    </a>
                                </div>
                                
                                <!-- Aligned stat columns -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">Cost Basis</div>
                                    <div class="font-semibold text-sm text-right" 
                                         :class="getGroupCostBasis(positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupCostBasis(positions))"></div>
                                </div>
                                
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">NetLiq</div>
                                    <div class="font-semibold text-sm text-slate-100 text-right" 
                                         x-text="formatNumber(getGroupNetLiq(positions))"></div>
                                </div>
                                
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-right">P&L</div>
                                    <div class="font-semibold text-sm text-right" 
                                         :class="getGroupPnL(positions) >= 0 ? 'text-green-400' : 'text-red-400'"
                                         x-text="formatNumber(getGroupPnL(positions))"></div>
                                </div>
                                
                                <!-- DTE Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-center">DTE</div>
                                    <div class="text-sm text-center" 
                                         :class="getMinDTE(positions) <= 21 ? 'font-bold text-yellow-400' : 'font-semibold text-slate-300'"
                                         x-text="getMinDTE(positions) || ''"></div>
                                </div>
                                
                                <!-- Strategy and Price Position Indicator (always present for consistent alignment) -->
                                <div class="header-stat-column">
                                    <template x-if="shouldShowPriceIndicator(positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs" x-text="getStrategyLabel(positions)"></div>
                                            <div class="price-position-indicator" x-html="getPricePositionIndicator(positions, underlying)"></div>
                                        </div>
                                    </template>
                                    <template x-if="!shouldShowPriceIndicator(positions)">
                                        <div>
                                            <div class="text-slate-400 text-xs" x-text="getStrategyLabel(positions)"></div>
                                            <div class="text-xs text-slate-500">—</div>
                                        </div>
                                    </template>
                                </div>
                                
                                <!-- Comments Column -->
                                <div class="header-stat-column">
                                    <div class="text-slate-400 text-xs text-left">Comments</div>
                                    <input type="text" 
                                           :value="getPositionComment(underlying)"
                                           @input="updatePositionComment(underlying, $event.target.value)"
                                           @click.stop
                                           class="w-full bg-transparent text-slate-100 text-sm border-none outline-none focus:bg-slate-700/30 rounded px-2 py-1"
                                           placeholder="">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Positions Table (Collapsible) -->
                        <div x-show="expanded"
                             class="overflow-x-auto">
                            <table class="min-w-full">
                                <thead class="bg-slate-700/50">
                                    <tr>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Type</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Qty</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Exp</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">DTE</th>
                                        <th class="px-2 py-2 text-center text-xs font-medium text-slate-300 uppercase tracking-wider">Strike</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Cost Basis</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">NetLiq</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">Unrealized P&L</th>
                                        <th class="px-3 py-2 text-right text-xs font-medium text-slate-300 uppercase tracking-wider">P&L %</th>
                                    </tr>
                                </thead>
                                <tbody class="bg-slate-800 divide-y divide-slate-700/50">
                                    <template x-for="position in positions" :key="position.symbol + position.account_number">
                                        <tr class="table-row-hover">
                                            <!-- Option Type (C/P) - moved to first -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-bold" 
                                                      :class="getOptionType(position) === 'C' ? 'text-green-400' : getOptionType(position) === 'P' ? 'text-red-400' : 'text-slate-400'"
                                                      x-text="getOptionType(position)"></span>
                                            </td>
                                            
                                            <!-- Quantity (negative for short positions) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-sm font-medium" 
                                                      :class="getSignedQuantity(position) > 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getSignedQuantity(position).toFixed(0)"></span>
                                            </td>
                                            
                                            <!-- Expiration Date -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getExpirationDate(position)"></span>
                                            </td>
                                            
                                            <!-- DTE (Days to Expiration) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs font-medium" 
                                                      :class="getDTE(position) <= 7 ? 'text-red-400' : getDTE(position) <= 30 ? 'text-yellow-400' : 'text-slate-300'"
                                                      x-text="getDTE(position)"></span>
                                            </td>
                                            
                                            <!-- Strike Price (options only) -->
                                            <td class="px-2 py-2 whitespace-nowrap text-center">
                                                <span class="text-xs text-slate-300" 
                                                      x-text="getStrikePrice(position)"></span>
                                            </td>
                                            
                                            <!-- Cost Basis -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getCostBasisDisplay(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(getCostBasisDisplay(position))"></span>
                                            </td>
                                            
                                            <!-- NetLiq (mark price, negative for short positions) -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm text-slate-300" x-text="formatNumber(getNetLiq(position))"></span>
                                            </td>
                                            
                                            <!-- Unrealized P&L -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getLiveUnrealizedPnL(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="formatNumber(getLiveUnrealizedPnL(position))"></span>
                                            </td>
                                            
                                            <!-- P&L % -->
                                            <td class="px-3 py-2 whitespace-nowrap text-right">
                                                <span class="text-sm font-medium" 
                                                      :class="getLivePnLPercent(position) >= 0 ? 'text-green-400' : 'text-red-400'"
                                                      x-text="getLivePnLPercent(position).toFixed(1) + '%'"></span>
                                            </td>
                                        </tr>
                                    </template>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <script>
        function positionsApp() {
            return {
                // Data
                allPositions: [],
                filteredPositions: [],
                accounts: [],
                underlyings: [],
                underlyingQuotes: {},
                positionComments: {}, // Store comments by underlying symbol + account
                
                // WebSocket for live quotes
                ws: null,
                wsReconnectTimer: null,
                wsReconnectDelay: 5000,
                
                // Filters (with localStorage persistence)
                selectedAccount: '',
                selectedInstrumentType: '',
                selectedUnderlying: '',
                
                // State
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                cacheInfo: null, // Cache freshness information
                
                // Computed properties
                get totalUnrealizedPnL() {
                    return this.filteredPositions.reduce((sum, pos) => sum + this.getLiveUnrealizedPnL(pos), 0);
                },
                
                get groupedPositions() {
                    // Group filtered positions by underlying symbol
                    const groups = new Map();
                    
                    this.filteredPositions.forEach(position => {
                        const underlying = position.underlying || position.symbol;
                        if (!groups.has(underlying)) {
                            groups.set(underlying, []);
                        }
                        groups.get(underlying).push(position);
                    });
                    
                    // Sort groups by underlying name and sort positions within each group
                    const sortedGroups = Array.from(groups.entries()).sort((a, b) => a[0].localeCompare(b[0]));
                    
                    // Sort positions within each group: stocks first, then options by expiration and strike
                    const self = this; // Capture reference to the Alpine component
                    sortedGroups.forEach(([underlying, positions]) => {
                        positions.sort((a, b) => {
                            // Stocks before options
                            if (a.instrument_type === 'EQUITY' && b.instrument_type !== 'EQUITY') return -1;
                            if (a.instrument_type !== 'EQUITY' && b.instrument_type === 'EQUITY') return 1;
                            
                            // For options, sort by expiration then strike price (ascending)
                            if (a.instrument_type !== 'EQUITY' && b.instrument_type !== 'EQUITY') {
                                // First sort by expiration date
                                if (a.expires_at && b.expires_at && a.expires_at !== b.expires_at) {
                                    return new Date(a.expires_at) - new Date(b.expires_at);
                                }
                                
                                // Then sort by strike price (ascending)
                                const strikeA = self.getNumericStrikePrice(a);
                                const strikeB = self.getNumericStrikePrice(b);
                                
                                if (strikeA !== null && strikeB !== null && strikeA !== strikeB) {
                                    return strikeA - strikeB; // Ascending order
                                }
                                
                                // Fallback to symbol comparison if strikes are equal or unavailable
                                return a.symbol.localeCompare(b.symbol);
                            }
                            
                            // Default to symbol comparison
                            return a.symbol.localeCompare(b.symbol);
                        });
                    });
                    
                    return sortedGroups;
                },
                
                // Methods
                async init() {
                    await this.loadAccounts();
                    
                    // Load saved filter preferences after accounts are loaded
                    this.loadFilterPreferences();
                    
                    // Load saved position comments
                    this.loadPositionComments();
                    
                    // Load cached positions immediately for fast initial display
                    await this.loadCachedPositions();
                    
                    // Then fetch fresh positions in the background (smart sync)
                    this.fetchPositions(false);
                    
                    // Clean up WebSocket on page unload
                    window.addEventListener('beforeunload', () => {
                        if (this.ws) {
                            this.ws.close();
                        }
                    });
                },
                
                loadFilterPreferences() {
                    try {
                        // Use shared account selection key to sync between pages
                        const savedState = localStorage.getItem('tradeJournalState');
                        const sharedAccount = savedState ? JSON.parse(savedState).selectedAccount : null;
                        const savedAccount = sharedAccount || localStorage.getItem('positions_selectedAccount');
                        const savedInstrumentType = localStorage.getItem('positions_selectedInstrumentType');
                        const savedUnderlying = localStorage.getItem('positions_selectedUnderlying');
                        
                        // Validate saved account exists in current accounts list
                        if (savedAccount && this.accounts.some(acc => acc.account_number === savedAccount)) {
                            this.selectedAccount = savedAccount;
                        } else if (savedAccount) {
                            console.warn(`Saved account ${savedAccount} not found in current accounts list`);
                            // Clear invalid saved account
                            localStorage.removeItem('positions_selectedAccount');
                        }
                        
                        if (savedInstrumentType) this.selectedInstrumentType = savedInstrumentType;
                        if (savedUnderlying) this.selectedUnderlying = savedUnderlying;
                        
                        console.log('Loaded filter preferences:', {
                            account: this.selectedAccount,
                            instrumentType: this.selectedInstrumentType,
                            underlying: this.selectedUnderlying,
                            availableAccounts: this.accounts.map(a => a.account_number)
                        });
                    } catch (error) {
                        console.warn('Error loading filter preferences:', error);
                    }
                },
                
                saveFilterPreferences() {
                    try {
                        // Save to positions-specific keys
                        localStorage.setItem('positions_selectedAccount', this.selectedAccount);
                        localStorage.setItem('positions_selectedInstrumentType', this.selectedInstrumentType);
                        localStorage.setItem('positions_selectedUnderlying', this.selectedUnderlying);
                        
                        // Also save account to shared key for cross-page sync
                        try {
                            const existingState = localStorage.getItem('tradeJournalState');
                            const state = existingState ? JSON.parse(existingState) : {};
                            state.selectedAccount = this.selectedAccount;
                            localStorage.setItem('tradeJournalState', JSON.stringify(state));
                        } catch (sharedError) {
                            console.warn('Error updating shared state:', sharedError);
                        }
                        
                        console.log('Saved filter preferences:', {
                            account: this.selectedAccount,
                            instrumentType: this.selectedInstrumentType,
                            underlying: this.selectedUnderlying
                        });
                    } catch (error) {
                        console.warn('Error saving filter preferences:', error);
                    }
                },
                
                // Load cached positions immediately for fast initial display
                async loadCachedPositions() {
                    try {
                        console.log('Loading cached positions...');
                        const response = await fetch('/api/positions/cached');
                        if (!response.ok) {
                            console.warn('Failed to load cached positions:', response.statusText);
                            return;
                        }
                        
                        const data = await response.json();
                        console.log('Cached positions loaded:', data);
                        
                        // Set positions from cache
                        this.allPositions = [];
                        for (const [accountNumber, positions] of Object.entries(data.positions)) {
                            for (const position of positions) {
                                this.allPositions.push({
                                    ...position,
                                    account_number: accountNumber
                                });
                            }
                        }
                        
                        // Extract unique values for filters
                        this.underlyings = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))].sort();
                        
                        // Set cached quotes if available
                        if (data.quotes) {
                            this.underlyingQuotes = data.quotes;
                            console.log(`Loaded ${Object.keys(data.quotes).length} cached quotes`);
                        }
                        
                        // Apply filters to show cached data
                        this.filterPositions();
                        
                        // Clean up comments for positions that no longer exist
                        this.cleanupOrphanedComments();
                        
                        // Set cache info for UI indicators
                        this.cacheInfo = data.cache_info;
                        
                        // Load last sync timestamp in background (don't await)
                        this.loadLastSyncTimestamp();
                        
                        console.log('Cached positions ready for display');
                    } catch (error) {
                        console.warn('Error loading cached positions:', error);
                    }
                },
                
                // Comment management functions
                loadPositionComments() {
                    try {
                        const savedComments = localStorage.getItem('positions_comments');
                        if (savedComments) {
                            const comments = JSON.parse(savedComments);
                            
                            // Clean up old comments (older than 90 days)
                            const now = Date.now();
                            const ninetyDaysAgo = now - (90 * 24 * 60 * 60 * 1000);
                            
                            this.positionComments = {};
                            for (const [key, value] of Object.entries(comments)) {
                                // Handle both old format (string) and new format (object with text and timestamp)
                                if (typeof value === 'string') {
                                    // Old format - keep it but convert to new format
                                    this.positionComments[key] = {
                                        text: value,
                                        timestamp: now
                                    };
                                } else if (value && value.timestamp && value.timestamp > ninetyDaysAgo) {
                                    // New format - only keep if not too old
                                    this.positionComments[key] = value;
                                }
                            }
                            
                            // Save cleaned up comments
                            this.savePositionComments();
                        }
                    } catch (error) {
                        console.warn('Error loading position comments:', error);
                        this.positionComments = {};
                    }
                },
                
                savePositionComments() {
                    try {
                        localStorage.setItem('positions_comments', JSON.stringify(this.positionComments));
                    } catch (error) {
                        console.warn('Error saving position comments:', error);
                    }
                },
                
                getCommentKey(underlying) {
                    // Create a unique key combining underlying symbol and account
                    return `${underlying}_${this.selectedAccount || 'all'}`;
                },
                
                getPositionComment(underlying) {
                    const key = this.getCommentKey(underlying);
                    const commentData = this.positionComments[key];
                    
                    if (!commentData) {
                        return '';
                    }
                    
                    // Handle both old format (string) and new format (object)
                    if (typeof commentData === 'string') {
                        return commentData;
                    }
                    
                    return commentData.text || '';
                },
                
                updatePositionComment(underlying, comment) {
                    const key = this.getCommentKey(underlying);
                    if (comment.trim()) {
                        this.positionComments[key] = {
                            text: comment,
                            timestamp: Date.now()
                        };
                    } else {
                        delete this.positionComments[key];
                    }
                    this.savePositionComments();
                },
                
                cleanupOrphanedComments() {
                    // Get all current position keys
                    const currentPositionKeys = new Set();
                    const underlyings = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))];
                    
                    // Add keys for all accounts and "all" option
                    for (const underlying of underlyings) {
                        // Add key for "all accounts"
                        currentPositionKeys.add(`${underlying}_all`);
                        
                        // Add keys for each specific account
                        for (const account of this.accounts) {
                            currentPositionKeys.add(`${underlying}_${account.account_number}`);
                        }
                    }
                    
                    // Remove comments for positions that no longer exist
                    let hasChanges = false;
                    for (const key of Object.keys(this.positionComments)) {
                        if (!currentPositionKeys.has(key)) {
                            const commentData = this.positionComments[key];
                            const timestamp = typeof commentData === 'object' ? commentData.timestamp : null;
                            
                            // Only delete if comment is older than 7 days to handle rolled positions
                            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                            if (!timestamp || timestamp < sevenDaysAgo) {
                                delete this.positionComments[key];
                                hasChanges = true;
                            }
                        }
                    }
                    
                    if (hasChanges) {
                        this.savePositionComments();
                    }
                },
                
                async loadAccounts() {
                    try {
                        console.log('Loading accounts...');
                        const response = await fetch('/api/accounts');
                        const data = await response.json();
                        this.accounts = data.accounts || [];
                        
                        // Sort accounts in desired order: Roth, Individual, Traditional
                        this.accounts.sort((a, b) => {
                            const getAccountTypeOrder = (name) => {
                                const nameUpper = (name || '').toUpperCase();
                                if (nameUpper.includes('ROTH')) return 1;
                                if (nameUpper.includes('INDIVIDUAL')) return 2;
                                if (nameUpper.includes('TRADITIONAL')) return 3;
                                return 4; // Other account types go last
                            };
                            
                            const orderA = getAccountTypeOrder(a.account_name);
                            const orderB = getAccountTypeOrder(b.account_name);
                            
                            return orderA - orderB;
                        });
                        
                        console.log(`Loaded ${this.accounts.length} accounts`);
                    } catch (error) {
                        console.error('Error loading accounts:', error);
                    }
                },
                
                // Smart sync logic - check if sync is needed
                shouldSyncData() {
                    if (!this.cacheInfo) {
                        return true; // No cache info, sync needed
                    }
                    
                    // If data is fresh (less than 1 hour old), no sync needed
                    if (this.cacheInfo.is_fresh) {
                        return false;
                    }
                    
                    // If data is less than 2 hours old, still consider it fresh enough
                    if (this.cacheInfo.data_age_minutes < 120) {
                        return false;
                    }
                    
                    // If data is older than 2 hours, sync needed
                    return this.cacheInfo.data_age_minutes > 120;
                },
                
                async fetchPositions(forceSync = false) {
                    // Don't show loading initially since we have cached data
                    // Only show loading if we don't have cached data
                    if (!this.allPositions || this.allPositions.length === 0) {
                        this.isLoading = true;
                    }
                    this.error = null;
                    
                    try {
                        // Check if sync is needed based on cache freshness
                        const shouldSync = forceSync || this.shouldSyncData();
                        
                        if (shouldSync) {
                            // First, sync data from Tastytrade (includes both positions and order chains)
                            console.log('Starting unified sync...');
                            const syncResponse = await fetch('/api/sync', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({})
                            });
                            
                            if (!syncResponse.ok) {
                                throw new Error(`Sync failed: ${syncResponse.statusText}`);
                            }
                            
                            const syncResult = await syncResponse.json();
                            console.log('Sync completed:', syncResult);
                            
                            // Now fetch updated positions after sync
                            const response = await fetch('/api/positions');
                            if (!response.ok) {
                                throw new Error(`Failed to fetch positions: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            
                            // Flatten positions from all accounts
                            this.allPositions = [];
                            for (const [accountNumber, positions] of Object.entries(data)) {
                                for (const position of positions) {
                                    this.allPositions.push({
                                        ...position,
                                        account_number: accountNumber
                                    });
                                }
                            }
                            
                            // Extract unique values for filters (accounts are loaded separately)
                            this.underlyings = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))].sort();
                            
                            this.filterPositions();
                            
                            // Clean up comments for positions that no longer exist
                            this.cleanupOrphanedComments();
                            
                            // Fetch underlying quotes after positions are loaded
                            await this.fetchUnderlyingQuotes();
                            
                            // Update last sync timestamp after successful sync
                            await this.loadLastSyncTimestamp();
                            
                            // Update cache info to show fresh data
                            this.cacheInfo = {
                                cached: false,
                                is_fresh: true,
                                data_age_minutes: 0,
                                last_sync: new Date().toISOString()
                            };
                            
                            console.log('Fresh positions loaded and cache updated');
                        } else {
                            console.log('Skipping sync - data is fresh enough');
                            // Still connect to WebSocket for live quotes if not already connected
                            if (!this.liveQuotesActive) {
                                await this.fetchUnderlyingQuotes();
                            }
                        }
                        
                    } catch (err) {
                        console.error('Error fetching positions:', err);
                        this.error = err.message;
                    } finally {
                        this.isLoading = false;
                    }
                },
                
                async fetchUnderlyingQuotes() {
                    try {
                        // Get unique underlying symbols from positions
                        const underlyingSymbols = [...new Set(this.allPositions.map(p => p.underlying || p.symbol))];
                        
                        // Also get individual option contract symbols for live NetLiq updates
                        const optionSymbols = [...new Set(this.allPositions
                            .filter(p => p.instrument_type && p.instrument_type.includes('OPTION'))
                            .map(p => p.symbol)
                        )];
                        
                        // Combine both underlying and option symbols
                        const allSymbols = [...underlyingSymbols, ...optionSymbols];
                        
                        if (allSymbols.length === 0) {
                            return;
                        }
                        
                        console.log(`Starting live quote streaming for ${allSymbols.length} symbols:`);
                        console.log(`  Underlyings (${underlyingSymbols.length}): ${underlyingSymbols.join(', ')}`);
                        console.log(`  Options (${optionSymbols.length}): ${optionSymbols.slice(0, 3).join(', ')}${optionSymbols.length > 3 ? '...' : ''}`);
                        
                        // Connect to WebSocket for live streaming quotes
                        this.connectWebSocket(allSymbols);
                        
                    } catch (err) {
                        console.warn('Error setting up quote streaming:', err);
                    }
                },
                
                connectWebSocket(symbols) {
                    // Close existing connection if any
                    if (this.ws) {
                        this.ws.close();
                    }
                    
                    // Clear any existing reconnect timer
                    if (this.wsReconnectTimer) {
                        clearTimeout(this.wsReconnectTimer);
                    }
                    
                    const wsUrl = `ws://${window.location.host}/ws/quotes`;
                    console.log(`Connecting to WebSocket at ${wsUrl}`);
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('✅ WebSocket connected for live quotes');
                        this.liveQuotesActive = true;
                        
                        // Subscribe to symbols
                        this.ws.send(JSON.stringify({
                            subscribe: symbols
                        }));
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            
                            if (message.type === 'quotes' && message.data) {
                                // Update quotes
                                this.underlyingQuotes = message.data;
                                this.lastQuoteUpdate = new Date();
                                const quotesReceived = Object.keys(this.underlyingQuotes).length;
                                
                                if (quotesReceived > 0) {
                                    console.log(`📊 Live update: ${quotesReceived} quotes at ${this.lastQuoteUpdate.toLocaleTimeString()}`);
                                }
                            } else if (message.error) {
                                console.error('WebSocket error:', message.error);
                            }
                        } catch (err) {
                            console.error('Error processing WebSocket message:', err);
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.liveQuotesActive = false;
                        
                        // Attempt to reconnect after delay
                        this.wsReconnectTimer = setTimeout(() => {
                            console.log('Attempting to reconnect WebSocket...');
                            this.connectWebSocket(symbols);
                        }, this.wsReconnectDelay);
                    };
                    
                    // Send periodic pings to keep connection alive
                    setInterval(() => {
                        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                            this.ws.send(JSON.stringify({ ping: true }));
                        }
                    }, 30000); // Ping every 30 seconds
                },
                
                filterPositions() {
                    this.filteredPositions = this.allPositions.filter(position => {
                        if (this.selectedAccount && position.account_number !== this.selectedAccount) {
                            return false;
                        }
                        
                        if (this.selectedInstrumentType) {
                            if (this.selectedInstrumentType === 'EQUITY') {
                                // For EQUITY filter, only show stocks (not options)
                                if (!position.instrument_type || !position.instrument_type.includes('EQUITY') || position.instrument_type.includes('OPTION')) {
                                    return false;
                                }
                            } else if (this.selectedInstrumentType === 'EQUITY_OPTION') {
                                // For EQUITY_OPTION filter, only show options
                                if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                                    return false;
                                }
                            }
                        }
                        
                        if (this.selectedUnderlying) {
                            const underlying = position.underlying || position.symbol;
                            if (underlying !== this.selectedUnderlying) {
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    // Save filter preferences to localStorage
                    this.saveFilterPreferences();
                    
                    // Note: Sorting is now handled in the groupedPositions computed property
                },
                
                getGroupPnL(positions) {
                    return positions.reduce((sum, pos) => sum + this.getLiveUnrealizedPnL(pos), 0);
                },
                
                getGroupCostBasis(positions) {
                    return positions.reduce((sum, pos) => sum + this.getCostBasisDisplay(pos), 0);
                },
                
                getGroupNetLiq(positions) {
                    return positions.reduce((sum, pos) => sum + this.getNetLiq(pos), 0);
                },
                
                getMinDTE(positions) {
                    // Get the minimum DTE from all option positions in the group
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    
                    if (optionPositions.length === 0) {
                        return null; // No options in this group
                    }
                    
                    const dtes = optionPositions.map(pos => {
                        const dte = this.getDTE(pos);
                        // Convert DTE to number, handling special cases
                        if (dte === 'Expired') return -1;
                        if (dte === 'Today') return 0;
                        return parseInt(dte) || 0;
                    }).filter(dte => !isNaN(dte));
                    
                    if (dtes.length === 0) {
                        return null;
                    }
                    
                    const minDte = Math.min(...dtes);
                    
                    // Format back to string for display
                    if (minDte < 0) return 'Expired';
                    if (minDte === 0) return 'Today';
                    return minDte.toString();
                },
                
                shouldShowPriceIndicator(positions) {
                    // Only show price position indicator for spreads, butterflies, and condors
                    const strategy = this.getStrategyLabel(positions);
                    const spreadStrategies = [
                        'Bull Put Spread', 'Bear Call Spread', 'Bull Call Spread', 'Bear Put Spread',
                        'Iron Condor', 'Iron Butterfly', 'Butterfly', 'Straddle', 'Strangle'
                    ];
                    return spreadStrategies.includes(strategy);
                },
                
                getPricePositionIndicator(positions, underlying) {
                    const underlyingQuote = this.getUnderlyingQuote(underlying);
                    const currentPrice = underlyingQuote ? underlyingQuote.price : null;
                    
                    if (!currentPrice) {
                        return '<span class="text-slate-500">Price N/A</span>';
                    }
                    
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    const strikes = optionPositions.map(p => this.getNumericStrikePrice(p)).filter(s => s).sort((a, b) => a - b);
                    
                    if (strikes.length < 2) {
                        return '<span class="text-slate-500">No strikes</span>';
                    }
                    
                    // Format strikes for display
                    const formatStrike = (strike) => strike % 1 === 0 ? strike.toString() : strike.toFixed(1);
                    const formatPrice = (price) => price.toFixed(1);
                    
                    if (strikes.length === 2) {
                        // Two-leg spread
                        const [low, high] = strikes;
                        const currentPriceFormatted = formatPrice(currentPrice);
                        
                        if (currentPrice < low) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(low)}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(high)}</span>`;
                        } else if (currentPrice > high) {
                            return `<span class="strike-marker">${formatStrike(low)}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(high)}</span><span class="price-line"></span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(low)}</span><span class="price-line"></span><span class="price-marker price-between">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(high)}</span>`;
                        }
                    } else if (strikes.length === 4) {
                        // Iron Condor
                        const [s1, s2, s3, s4] = strikes;
                        const currentPriceFormatted = formatPrice(currentPrice);
                        
                        if (currentPrice < s1) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else if (currentPrice > s4) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span><span class="price-line"></span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else if (currentPrice >= s2 && currentPrice <= s3) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span><span class="price-marker price-between">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else if (currentPrice < s2) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>—<span class="strike-marker">${formatStrike(s4)}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s4)}</span>`;
                        }
                    } else if (strikes.length === 3) {
                        // Butterfly
                        const [s1, s2, s3] = strikes;
                        const currentPriceFormatted = formatPrice(currentPrice);
                        
                        if (currentPrice < s1) {
                            return `<span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="price-line"></span><span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        } else if (currentPrice > s3) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span><span class="price-line"></span><span class="price-marker price-outside">◆${currentPriceFormatted}</span>`;
                        } else if (Math.abs(currentPrice - s2) < Math.min(Math.abs(currentPrice - s1), Math.abs(currentPrice - s3))) {
                            return `<span class="strike-marker">${formatStrike(s1)}</span>—<span class="price-marker price-between">◆${currentPriceFormatted}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        } else {
                            return `<span class="strike-marker">${formatStrike(s1)}</span><span class="price-marker price-outside">◆${currentPriceFormatted}</span><span class="strike-marker">${formatStrike(s2)}</span>—<span class="strike-marker">${formatStrike(s3)}</span>`;
                        }
                    }
                    
                    return '<span class="text-slate-500">Complex</span>';
                },
                
                getUnderlyingQuote(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    
                    if (!quote) {
                        return null;
                    }
                    
                    if (!quote.mark && quote.mark !== 0) {
                        return null;
                    }
                    
                    return {
                        price: quote.mark,
                        change: quote.change || 0,
                        changePercent: quote.change_percent || 0
                    };
                },
                
                getUnderlyingIV(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    
                    if (!quote) {
                        return null;
                    }
                    
                    // Check for IVR first (preferred), then fall back to IV
                    if (quote.ivr !== undefined && quote.ivr !== null) {
                        // Convert IVR from decimal to percentage with 1 decimal place
                        return (quote.ivr * 100).toFixed(1);
                    }
                    
                    if (quote.iv !== undefined && quote.iv !== null) {
                        // Format IV as percentage with 0 decimal places
                        return Math.round(quote.iv);
                    }
                    
                    return null;
                },
                
                // Option parsing and display methods
                getSignedQuantity(position) {
                    // The API provides signed quantities where negative = short
                    // But let's also check quantity_direction field as backup
                    let quantity = position.quantity || 0;
                    
                    // If quantity is positive but quantity_direction indicates short, make it negative
                    if (quantity > 0 && position.quantity_direction === 'Short') {
                        quantity = -quantity;
                    }
                    
                    return quantity;
                },
                
                getNetLiq(position) {
                    // For option positions, use live quote data if available
                    if (position.instrument_type && position.instrument_type.includes('OPTION')) {
                        const quote = this.underlyingQuotes[position.symbol];
                        if (quote && quote.mark) {
                            // Calculate live NetLiq: quantity * mark_price * 100 (for options)
                            const quantity = this.getSignedQuantity(position);
                            const liveNetLiq = quantity * quote.mark * 100;
                            return liveNetLiq;
                        }
                    }
                    
                    // Fallback to static market_value for stocks or when no live data
                    return position.market_value || 0;
                },
                
                getLiveUnrealizedPnL(position) {
                    // For option positions, calculate live P&L using current quotes
                    if (position.instrument_type && position.instrument_type.includes('OPTION')) {
                        const quote = this.underlyingQuotes[position.symbol];
                        if (quote && quote.mark) {
                            const liveNetLiq = this.getNetLiq(position);
                            const costBasis = position.cost_basis || 0;
                            const quantity = this.getSignedQuantity(position);
                            
                            if (quantity < 0) {
                                // Short position: P&L = cost_basis + market_value
                                // (cost_basis is what you received, market_value is negative for shorts)
                                return costBasis + liveNetLiq;
                            } else {
                                // Long position: P&L = market_value - cost_basis
                                return liveNetLiq - costBasis;
                            }
                        }
                    }
                    
                    // Fallback to static unrealized_pnl for stocks or when no live data
                    return position.unrealized_pnl || 0;
                },
                
                getLivePnLPercent(position) {
                    // Calculate live P&L percentage
                    if (position.instrument_type && position.instrument_type.includes('OPTION')) {
                        const quote = this.underlyingQuotes[position.symbol];
                        if (quote && quote.mark) {
                            const liveUnrealizedPnL = this.getLiveUnrealizedPnL(position);
                            const costBasis = Math.abs(position.cost_basis || 0);
                            
                            if (costBasis > 0) {
                                return (liveUnrealizedPnL / costBasis) * 100;
                            }
                            return 0;
                        }
                    }
                    
                    // Fallback to static pnl_percent for stocks or when no live data
                    return position.pnl_percent || 0;
                },
                
                formatNumber(num) {
                    // Format numbers with commas and 2 decimal places
                    if (num === null || num === undefined || isNaN(num)) return '0.00';
                    return num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                },
                
                getCostBasisDisplay(position) {
                    // Display cost basis with proper sign based on position direction
                    const costBasis = position.cost_basis || 0;
                    const quantity = this.getSignedQuantity(position);
                    
                    if (quantity < 0) {
                        // Short position: cost basis is money received (positive/credit)
                        return costBasis;
                    } else {
                        // Long position: cost basis is money paid (negative/debit)
                        return -costBasis;
                    }
                },
                
                parseOptionSymbol(symbol) {
                    // Parse option symbol like "IBIT  250404C00050000"
                    if (!symbol || typeof symbol !== 'string') return null;
                    
                    const parts = symbol.trim().split(/\s+/);
                    if (parts.length < 2) return null;
                    
                    const optionCode = parts[1];
                    if (optionCode.length < 15) return null;
                    
                    try {
                        // Extract components: YYMMDD + C/P + 8-digit strike
                        const expiration = optionCode.substring(0, 6);  // YYMMDD
                        const optionType = optionCode.substring(6, 7);  // C or P
                        const strikeStr = optionCode.substring(7);      // 8-digit strike
                        
                        // Parse expiration date
                        const year = 2000 + parseInt(expiration.substring(0, 2));
                        const month = parseInt(expiration.substring(2, 4));
                        const day = parseInt(expiration.substring(4, 6));
                        const expirationDate = new Date(year, month - 1, day);
                        
                        // Parse strike price (divide by 1000 to get actual price)
                        const strike = parseInt(strikeStr) / 1000;
                        
                        return {
                            expiration: expirationDate,
                            optionType: optionType,
                            strike: strike
                        };
                    } catch (e) {
                        console.warn('Failed to parse option symbol:', symbol, e);
                        return null;
                    }
                },
                
                getStrikePrice(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    let strike = null;
                    
                    // First try the API field
                    if (position.strike_price !== null && position.strike_price !== undefined) {
                        strike = parseFloat(position.strike_price);
                    } else {
                        // Fallback to symbol parsing
                        const parsed = this.parseOptionSymbol(position.symbol);
                        if (parsed && parsed.strike) {
                            strike = parsed.strike;
                        }
                    }
                    
                    if (strike !== null) {
                        // Format to remove unnecessary decimal places
                        // $400.00 -> 400, $317.50 -> 317.5
                        const formatted = strike % 1 === 0 ? strike.toString() : strike.toFixed(2).replace(/\.?0+$/, '');
                        return formatted;
                    }
                    
                    return '';
                },
                
                getNumericStrikePrice(position) {
                    // Get numeric strike price for sorting purposes
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return null;
                    }
                    
                    let strike = null;
                    
                    // First try the API field
                    if (position.strike_price !== null && position.strike_price !== undefined) {
                        strike = parseFloat(position.strike_price);
                    } else {
                        // Fallback to symbol parsing
                        const parsed = this.parseOptionSymbol(position.symbol);
                        if (parsed && parsed.strike) {
                            strike = parsed.strike;
                        }
                    }
                    
                    return strike; // Return raw numeric value for sorting
                },
                
                getOptionType(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    // First try the API field
                    if (position.option_type) {
                        return position.option_type;
                    }
                    
                    // Fallback to symbol parsing
                    const parsed = this.parseOptionSymbol(position.symbol);
                    if (parsed && parsed.optionType) {
                        return parsed.optionType;
                    }
                    
                    return '';
                },
                
                getExpirationDate(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    // First try the expires_at field from the API
                    if (position.expires_at) {
                        const date = new Date(position.expires_at);
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric'
                        });
                    }
                    
                    // Fallback to parsing from symbol
                    const parsed = this.parseOptionSymbol(position.symbol);
                    if (parsed && parsed.expiration) {
                        return parsed.expiration.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric'
                        });
                    }
                    
                    return '';
                },
                
                getDTE(position) {
                    if (!position.instrument_type || !position.instrument_type.includes('EQUITY_OPTION')) {
                        return '';
                    }
                    
                    let expirationDate = null;
                    
                    // First try the expires_at field from the API
                    if (position.expires_at) {
                        expirationDate = new Date(position.expires_at);
                    } else {
                        // Fallback to parsing from symbol
                        const parsed = this.parseOptionSymbol(position.symbol);
                        if (parsed && parsed.expiration) {
                            expirationDate = parsed.expiration;
                        }
                    }
                    
                    if (expirationDate) {
                        // Normalize both dates to midnight for accurate day counting
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        
                        const expiry = new Date(expirationDate);
                        expiry.setHours(0, 0, 0, 0);
                        
                        const timeDiff = expiry.getTime() - today.getTime();
                        const daysDiff = Math.round(timeDiff / (1000 * 3600 * 24));
                        
                        if (daysDiff < 0) {
                            return 'Expired';
                        } else if (daysDiff === 0) {
                            return 'Today';
                        } else {
                            return daysDiff.toString();
                        }
                    }
                    
                    return '';
                },
                
                // Debug method to log position data 
                debugPositionData() {
                    console.log('=== POSITION DEBUG INFO ===');
                    console.log('Total positions found:', this.allPositions.length);
                    
                    if (this.allPositions.length > 0) {
                        console.log('All instrument types:', [...new Set(this.allPositions.map(p => p.instrument_type))]);
                        
                        // Show first few positions regardless of type
                        console.log('First 3 positions:', this.allPositions.slice(0, 3));
                        
                        // Look for options with different possible instrument type values
                        const optionPosition = this.allPositions.find(p => 
                            p.instrument_type && 
                            (p.instrument_type.includes('OPTION') || 
                             p.instrument_type.includes('option') ||
                             p.symbol.includes(' ') || // Options often have spaces in symbol
                             p.expires_at)  // Options have expiration dates
                        );
                        
                        if (optionPosition) {
                            console.log('Found option-like position:', optionPosition);
                            console.log('Option position fields:', Object.keys(optionPosition));
                        } else {
                            console.log('No option-like positions found');
                        }
                    } else {
                        console.log('No positions at all - check API connection');
                    }
                    console.log('=== END DEBUG INFO ===');
                },
                
                
                getStrategyLabel(positions) {
                    // Recognize strategy from position group
                    if (!positions || positions.length === 0) {
                        return 'No Positions';
                    }
                    
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    const stockPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('EQUITY') && !p.instrument_type.includes('OPTION'));
                    
                    // Pure stock positions
                    if (optionPositions.length === 0 && stockPositions.length > 0) {
                        return stockPositions.some(p => this.getSignedQuantity(p) < 0) ? 'Short Stock' : 'Long Stock';
                    }
                    
                    // Mixed stock and options
                    if (stockPositions.length > 0 && optionPositions.length === 1) {
                        const option = optionPositions[0];
                        const optionType = this.getOptionType(option);
                        const quantity = this.getSignedQuantity(option);
                        
                        if (optionType === 'C' && quantity < 0) {
                            return 'Covered Call';
                        }
                        // Could add more covered positions logic here
                    }
                    
                    // Pure option strategies
                    if (optionPositions.length === 1) {
                        const option = optionPositions[0];
                        const optionType = this.getOptionType(option);
                        const quantity = this.getSignedQuantity(option);
                        
                        if (quantity < 0) {
                            return optionType === 'P' ? 'Cash Secured Put' : 'Naked Call';
                        } else {
                            return optionType === 'P' ? 'Long Put' : 'Long Call';
                        }
                    }
                    
                    if (optionPositions.length === 2) {
                        const strikes = optionPositions.map(p => this.getNumericStrikePrice(p)).filter(s => s).sort((a, b) => a - b);
                        const quantities = optionPositions.map(p => this.getSignedQuantity(p));
                        const optionTypes = optionPositions.map(p => this.getOptionType(p));
                        const expirations = optionPositions.map(p => this.getExpirationDate(p));
                        
                        // Check if all options have same expiration and type
                        const sameExpiration = expirations.every(exp => exp === expirations[0]);
                        const sameType = optionTypes.every(type => type === optionTypes[0]);
                        const sameStrike = strikes.length === 2 && strikes[0] === strikes[1];
                        
                        if (sameStrike && sameExpiration && !sameType) {
                            // Same strike, different types = Straddle
                            return 'Straddle';
                        }
                        
                        if (!sameStrike && sameExpiration && !sameType) {
                            // Different strikes, different types = Strangle
                            return 'Strangle';
                        }
                        
                        if (!sameStrike && sameExpiration && sameType) {
                            // Different strikes, same type = Vertical Spread
                            const hasLong = quantities.some(q => q > 0);
                            const hasShort = quantities.some(q => q < 0);
                            
                            if (hasLong && hasShort) {
                                if (optionTypes[0] === 'P') {
                                    // Put spreads: Bull = sell higher strike, buy lower strike
                                    const shortPutIndex = quantities.findIndex(q => q < 0);
                                    const longPutIndex = quantities.findIndex(q => q > 0);
                                    const shortStrike = this.getNumericStrikePrice(optionPositions[shortPutIndex]);
                                    const longStrike = this.getNumericStrikePrice(optionPositions[longPutIndex]);
                                    return shortStrike > longStrike ? 'Bull Put Spread' : 'Bear Put Spread';
                                } else {
                                    // Call spreads: Bull = buy lower strike, sell higher strike  
                                    const shortCallIndex = quantities.findIndex(q => q < 0);
                                    const longCallIndex = quantities.findIndex(q => q > 0);
                                    const shortStrike = this.getNumericStrikePrice(optionPositions[shortCallIndex]);
                                    const longStrike = this.getNumericStrikePrice(optionPositions[longCallIndex]);
                                    return longStrike < shortStrike ? 'Bull Call Spread' : 'Bear Call Spread';
                                }
                            }
                        }
                        
                        return 'Two-Leg Strategy';
                    }
                    
                    if (optionPositions.length === 3) {
                        return 'Butterfly';
                    }
                    
                    if (optionPositions.length === 4) {
                        const putOptions = optionPositions.filter(p => this.getOptionType(p) === 'P');
                        const callOptions = optionPositions.filter(p => this.getOptionType(p) === 'C');
                        
                        if (putOptions.length === 2 && callOptions.length === 2) {
                            return 'Iron Condor';
                        } else if (putOptions.length === 4 || callOptions.length === 4) {
                            return 'Iron Butterfly';
                        }
                        
                        return 'Four-Leg Strategy';
                    }
                    
                    if (optionPositions.length > 4) {
                        return 'Complex Strategy';
                    }
                    
                    return 'Mixed Positions';
                },
                
                getStrategyBadgeClass(strategyLabel) {
                    // Return CSS class based on strategy type
                    const complexStrategies = ['Iron Condor', 'Iron Butterfly', 'Butterfly', 'Complex Strategy'];
                    const spreadStrategies = ['Bull Put Spread', 'Bear Call Spread', 'Bull Call Spread', 'Bear Put Spread', 'Two-Leg Strategy', 'Four-Leg Strategy', 'Straddle', 'Strangle'];
                    const coveredStrategies = ['Covered Call', 'Cash Secured Put'];
                    const singleStrategies = ['Long Call', 'Long Put', 'Naked Call', 'Naked Put'];
                    const stockStrategies = ['Long Stock', 'Short Stock'];
                    
                    if (complexStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-complex';
                    } else if (spreadStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-spread';
                    } else if (coveredStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-covered';
                    } else if (singleStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-single';
                    } else if (stockStrategies.includes(strategyLabel)) {
                        return 'strategy-badge-stock';
                    } else {
                        return 'strategy-badge-stock'; // Default
                    }
                },
                
                // Load last sync timestamp
                async loadLastSyncTimestamp() {
                    try {
                        const response = await fetch('/api/sync/status');
                        const data = await response.json();
                        if (data.last_sync) {
                            // Format timestamp for display
                            const date = new Date(data.last_sync);
                            this.lastSyncTimestamp = date.toLocaleDateString('en-US', {
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                        } else {
                            this.lastSyncTimestamp = '';
                        }
                    } catch (error) {
                        console.error('Error loading last sync timestamp:', error);
                        this.lastSyncTimestamp = '';
                    }
                }
            };
        }
    </script>
</body>
</html>