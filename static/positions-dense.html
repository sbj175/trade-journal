<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OptionEdge - Positions</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%232962ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='22 12 18 12 15 21 9 3 6 12 2 12'></polyline></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        tv: {
                            bg: '#131722',
                            panel: '#1e222d',
                            border: '#2a2e39',
                            text: '#d1d4dc',
                            muted: '#787b86',
                            green: '#26a69a',
                            red: '#ef5350',
                            blue: '#2962ff',
                        }
                    }
                }
            }
        }
    </script>

    <!-- Alpine.js for interactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif; }
        body { background: #131722; color: #d1d4dc; font-size: 16px; }
        .tv-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .tv-scrollbar::-webkit-scrollbar-track { background: #1e222d; }
        .tv-scrollbar::-webkit-scrollbar-thumb { background: #2a2e39; border-radius: 3px; }
        .tv-scrollbar::-webkit-scrollbar-thumb:hover { background: #363a45; }
        [x-cloak] { display: none !important; }
    </style>

    <!-- Inline positions app -->
    <script>
        function positionsApp() {
            return {
                // Basic state
                allPositions: [],
                filteredPositions: [],
                accounts: [],
                accountBalances: {},
                underlyingQuotes: {},
                quoteUpdateCounter: 0,
                positionComments: {},
                chainNoteMap: {},
                _noteSaveTimers: {},
                selectedAccount: '',
                selectedInstrumentType: '',
                selectedUnderlying: '',
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                ws: null,
                // Roll analysis state
                strategyTargets: {},
                rollAlertSettings: { enabled: true, profitTarget: true, lossLimit: true, lateStage: true, deltaSaturation: true, lowRewardToRisk: true },

                // Sorting state
                sortColumn: 'underlying',
                sortDirection: 'asc',

                // Computed properties
                get currentAccountBalance() {
                    if (!this.selectedAccount || this.selectedAccount === '') {
                        const values = Object.values(this.accountBalances);
                        if (values.length === 0) return null;
                        return values.reduce((acc, balance) => ({
                            cash_balance: (acc.cash_balance || 0) + (balance.cash_balance || 0),
                            derivative_buying_power: (acc.derivative_buying_power || 0) + (balance.derivative_buying_power || 0),
                            equity_buying_power: (acc.equity_buying_power || 0) + (balance.equity_buying_power || 0),
                            net_liquidating_value: (acc.net_liquidating_value || 0) + (balance.net_liquidating_value || 0)
                        }), { cash_balance: 0, derivative_buying_power: 0, equity_buying_power: 0, net_liquidating_value: 0 });
                    }
                    return this.accountBalances[this.selectedAccount] || null;
                },

                get groupedPositions() {
                    try {
                        if (this.isLoading || !this.allPositions || this.allPositions.length === 0) return [];
                        const groups = new Map();

                        this.filteredPositions.forEach(position => {
                            const underlying = this.getUnderlyingSymbol(position);
                            if (!underlying || underlying === 'Unknown') return;

                            const chainId = position.chain_id;
                            const strategyType = position.strategy_type || 'Unknown';
                            const accountNumber = position.account_number;

                            let groupKey, displayKey;
                            if (chainId) {
                                groupKey = `${accountNumber}|${underlying}|${chainId}|${strategyType}`;
                                displayKey = underlying;
                            } else {
                                const expiration = position.expires_at || position.expiration || 'Unknown';
                                groupKey = `${accountNumber}|${underlying}|unenriched|${expiration}`;
                                displayKey = underlying;
                            }

                            if (!groups.has(groupKey)) {
                                groups.set(groupKey, {
                                    groupKey,
                                    displayKey, underlying,
                                    accountNumber,
                                    chainId: chainId || 'unenriched',
                                    strategyType,
                                    positions: []
                                });
                            }
                            groups.get(groupKey).positions.push(position);
                        });

                        // Apply sorting based on sortColumn and sortDirection
                        this.quoteUpdateCounter; // ensure recompute on quote changes
                        const self = this;
                        const sorted = Array.from(groups.values()).sort((a, b) => {
                            let aVal, bVal;

                            switch (self.sortColumn) {
                                case 'underlying':
                                    aVal = a.underlying.toLowerCase();
                                    bVal = b.underlying.toLowerCase();
                                    break;
                                case 'ivr':
                                    aVal = self.getUnderlyingIVR(a.underlying) ?? -1;
                                    bVal = self.getUnderlyingIVR(b.underlying) ?? -1;
                                    break;
                                case 'price':
                                    const aQuote = self.underlyingQuotes[a.underlying];
                                    const bQuote = self.underlyingQuotes[b.underlying];
                                    aVal = aQuote?.price || 0;
                                    bVal = bQuote?.price || 0;
                                    break;
                                case 'cost_basis':
                                    aVal = self.getGroupCostBasis(a.positions);
                                    bVal = self.getGroupCostBasis(b.positions);
                                    break;
                                case 'net_liq':
                                    aVal = self.getGroupNetLiqWithLiveQuotes(a.positions);
                                    bVal = self.getGroupNetLiqWithLiveQuotes(b.positions);
                                    break;
                                case 'pnl':
                                    aVal = self.getGroupPnLWithLiveQuotes(a.positions);
                                    bVal = self.getGroupPnLWithLiveQuotes(b.positions);
                                    break;
                                case 'pnl_percent':
                                    aVal = parseFloat(self.getGroupPnLPercent(a.positions)) || 0;
                                    bVal = parseFloat(self.getGroupPnLPercent(b.positions)) || 0;
                                    break;
                                case 'max_percent':
                                    const aMax = self.getGroupMaxPercent(a.positions);
                                    const bMax = self.getGroupMaxPercent(b.positions);
                                    aVal = aMax === '—' ? -1 : parseFloat(aMax) || 0;
                                    bVal = bMax === '—' ? -1 : parseFloat(bMax) || 0;
                                    break;
                                case 'days':
                                    aVal = self.getGroupDaysOpen(a.positions) || 0;
                                    bVal = self.getGroupDaysOpen(b.positions) || 0;
                                    break;
                                case 'dte':
                                    aVal = self.getMinDTE(a.positions) ?? 9999;
                                    bVal = self.getMinDTE(b.positions) ?? 9999;
                                    break;
                                case 'strategy':
                                    aVal = self.getGroupStrategyLabel(a).toLowerCase();
                                    bVal = self.getGroupStrategyLabel(b).toLowerCase();
                                    break;
                                default:
                                    aVal = a.underlying.toLowerCase();
                                    bVal = b.underlying.toLowerCase();
                            }

                            // Compare
                            if (aVal < bVal) return self.sortDirection === 'asc' ? -1 : 1;
                            if (aVal > bVal) return self.sortDirection === 'asc' ? 1 : -1;
                            return 0;
                        });

                        // Attach roll analysis to each group for reactive badge display
                        sorted.forEach(group => {
                            group.rollAnalysis = this.getRollAnalysis(group);
                        });
                        return sorted;
                    } catch (error) {
                        console.error('Error in groupedPositions:', error);
                        return [];
                    }
                },

                get underlyings() {
                    return [...new Set(this.filteredPositions.map(p => this.getUnderlyingSymbol(p)).filter(s => s && s !== 'Unknown'))];
                },

                // Initialize
                async init() {
                    await this.loadComments();
                    this.loadRollAlertSettings();
                    await this.fetchAccounts();
                    await this.loadStrategyTargets();
                    this.loadFilterPreferences();
                    await this.loadAccountBalances();
                    await this.fetchPositions();
                    await this.loadCachedQuotes();
                    this.initializeWebSocket();
                },

                async fetchAccounts() {
                    try {
                        const response = await fetch('/api/accounts');
                        const data = await response.json();
                        this.accounts = data.accounts || [];
                        this.accounts.sort((a, b) => {
                            const getOrder = (name) => {
                                const n = (name || '').toUpperCase();
                                if (n.includes('ROTH')) return 1;
                                if (n.includes('INDIVIDUAL')) return 2;
                                if (n.includes('TRADITIONAL')) return 3;
                                return 4;
                            };
                            return getOrder(a.account_name) - getOrder(b.account_name);
                        });
                    } catch (error) { console.error('Failed to load accounts:', error); }
                },

                async fetchPositions(includeSync = false, fastMode = true) {
                    this.isLoading = true;
                    this.error = null;
                    try {
                        if (includeSync) {
                            const endpoint = fastMode ? '/api/sync-positions-only' : '/api/sync';
                            await fetch(endpoint, { method: 'POST' });
                        }
                        const response = await fetch('/api/positions');
                        const data = await response.json();

                        this.allPositions = [];
                        if (typeof data === 'object' && !Array.isArray(data)) {
                            Object.entries(data).forEach(([accountNumber, accountPositions]) => {
                                if (Array.isArray(accountPositions)) {
                                    accountPositions.forEach(position => {
                                        position.account_number = accountNumber;
                                        this.allPositions.push(position);
                                    });
                                }
                            });
                        } else {
                            this.allPositions = Array.isArray(data) ? data : [];
                        }
                        this.applyFilters();
                    } catch (error) {
                        console.error('Failed to load positions:', error);
                        this.error = 'Failed to load positions';
                    } finally {
                        this.isLoading = false;
                    }
                },

                async loadAccountBalances() {
                    try {
                        const response = await fetch('/api/account-balances');
                        const data = await response.json();
                        const balances = data.balances || data;
                        this.accountBalances = {};
                        if (Array.isArray(balances)) {
                            balances.forEach(balance => { this.accountBalances[balance.account_number] = balance; });
                        }
                    } catch (error) { console.error('Failed to load account balances:', error); }
                },

                async loadCachedQuotes() {
                    try {
                        const underlyings = [...new Set(this.filteredPositions.map(p => this.getUnderlyingSymbol(p)).filter(s => s && s !== 'Unknown'))];
                        if (underlyings.length === 0) return;

                        const response = await fetch(`/api/quotes?symbols=${encodeURIComponent(underlyings.join(','))}`);
                        if (response.ok) {
                            const quotes = await response.json();
                            for (const [symbol, quoteData] of Object.entries(quotes)) {
                                if (quoteData && typeof quoteData === 'object') {
                                    this.underlyingQuotes[symbol] = quoteData;
                                }
                            }
                            this.lastQuoteUpdate = new Date().toLocaleTimeString();
                            this.quoteUpdateCounter++;
                        }
                    } catch (error) { console.error('Error loading cached quotes:', error); }
                },

                initializeWebSocket() {
                    try {
                        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                        const wsUrl = protocol + '//' + location.host + '/ws/quotes';
                        this.ws = new WebSocket(wsUrl);

                        this.ws.onopen = () => {
                            this.liveQuotesActive = true;
                            this.requestLiveQuotes();
                        };

                        this.ws.onmessage = (event) => {
                            const message = JSON.parse(event.data);
                            if (message.type === 'quotes' && message.data) {
                                let quotesUpdated = false;
                                for (const [symbol, quoteData] of Object.entries(message.data)) {
                                    if (quoteData && typeof quoteData === 'object') {
                                        this.underlyingQuotes[symbol] = quoteData;
                                        quotesUpdated = true;
                                    }
                                }
                                if (quotesUpdated) {
                                    this.underlyingQuotes = { ...this.underlyingQuotes };
                                }
                                this.quoteUpdateCounter++;
                                this.lastQuoteUpdate = new Date().toLocaleTimeString();
                            }
                        };

                        this.ws.onclose = () => {
                            this.liveQuotesActive = false;
                            setTimeout(() => this.initializeWebSocket(), 5000);
                        };
                    } catch (error) { console.error('WebSocket error:', error); }
                },

                getPositionSymbol(position) {
                    const isOption = position.instrument_type && position.instrument_type.includes('OPTION');
                    return isOption ? position.symbol : this.getUnderlyingSymbol(position);
                },

                requestLiveQuotes() {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

                    const symbolSet = new Set();
                    this.filteredPositions.forEach(p => {
                        const posSymbol = this.getPositionSymbol(p);
                        if (posSymbol && posSymbol !== 'Unknown') symbolSet.add(posSymbol);
                        const isOption = p.instrument_type && p.instrument_type.includes('OPTION');
                        if (isOption) {
                            const underlying = this.getUnderlyingSymbol(p);
                            if (underlying && underlying !== 'Unknown') symbolSet.add(underlying);
                        }
                    });

                    const symbols = Array.from(symbolSet);
                    if (symbols.length > 0) {
                        this.ws.send(JSON.stringify({ subscribe: symbols }));
                    }
                },

                applyFilters() {
                    this.filteredPositions = this.allPositions.filter(position => {
                        if (this.selectedAccount && position.account_number !== this.selectedAccount) return false;
                        if (this.selectedInstrumentType && position.instrument_type !== this.selectedInstrumentType) return false;
                        if (this.selectedUnderlying) {
                            const underlying = this.getUnderlyingSymbol(position);
                            if (underlying !== this.selectedUnderlying) return false;
                        }
                        return true;
                    });

                    if (this.selectedAccount && this.filteredPositions.length === 0 && this.allPositions.length > 0) {
                        this.selectedAccount = '';
                        this.filteredPositions = this.allPositions.filter(position => {
                            if (this.selectedInstrumentType && position.instrument_type !== this.selectedInstrumentType) return false;
                            if (this.selectedUnderlying) {
                                const underlying = this.getUnderlyingSymbol(position);
                                if (underlying !== this.selectedUnderlying) return false;
                            }
                            return true;
                        });
                    }
                },

                filterPositions() { this.applyFilters(); },

                saveFilterPreferences() {
                    localStorage.setItem('trade_journal_selected_account', this.selectedAccount || '');
                },

                loadFilterPreferences() {
                    const savedAccount = localStorage.getItem('trade_journal_selected_account');
                    if (savedAccount !== null) this.selectedAccount = savedAccount;

                    // Load saved sort preference
                    const savedSort = localStorage.getItem('positions_sort');
                    if (savedSort) {
                        try {
                            const parsed = JSON.parse(savedSort);
                            this.sortColumn = parsed.column || 'underlying';
                            this.sortDirection = parsed.direction || 'asc';
                        } catch (e) {
                            // Default sort
                        }
                    }
                },

                onAccountChange() {
                    this.underlyingQuotes = {};
                    this.applyFilters();
                    this.saveFilterPreferences();
                    setTimeout(async () => {
                        await this.loadCachedQuotes();
                        this.requestLiveQuotes();
                    }, 50);
                },

                // Utility methods
                getUnderlyingSymbol(position) {
                    if (position.underlying) return position.underlying;
                    if (position.symbol) {
                        if (position.instrument_type === 'EQUITY') return position.symbol;
                        return position.symbol.split(' ')[0] || position.symbol.split('_')[0];
                    }
                    return 'Unknown';
                },

                formatNumber(value, decimals = 2) {
                    if (value === null || value === undefined || isNaN(value)) return '0';
                    return new Intl.NumberFormat('en-US', {
                        minimumFractionDigits: decimals,
                        maximumFractionDigits: decimals
                    }).format(value);
                },

                // Position calculations
                getGroupCostBasis(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                },
                getGroupNetLiq(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.market_value || 0), 0);
                },
                getGroupPnL(positions) {
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + (pos.unrealized_pnl || 0), 0);
                },
                getGroupPnLPercent(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    const totalCostBasis = positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                    const totalPnL = this.getGroupPnLWithLiveQuotes(positions);
                    if (totalCostBasis === 0) return null;
                    return ((totalPnL / Math.abs(totalCostBasis)) * 100).toFixed(1);
                },
                getGroupMaxPercent(positions) {
                    // For spread strategies, calculate current P&L as percentage of max profit
                    // % Max = (Current P&L / Max Profit) × 100
                    const totalCostBasis = positions.reduce((sum, pos) => sum + (pos.cost_basis || 0), 0);
                    if (totalCostBasis === 0) return '—';

                    // Get strikes and sort them
                    const getStrike = (p) => {
                        if (p.strike_price && p.strike_price > 0) return p.strike_price;
                        const match = (p.symbol || '').match(/([CP])(\d+)/);
                        if (match) {
                            const priceStr = match[2];
                            if (priceStr.length >= 3) return parseFloat(priceStr.slice(0, -3) + '.' + priceStr.slice(-3));
                        }
                        return null;
                    };

                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    const strikes = optionPositions.map(getStrike).filter(s => s !== null && s > 0).sort((a, b) => a - b);

                    // Need at least 2 strikes for a spread
                    if (strikes.length < 2) return '—';

                    // Calculate spread width (difference between strikes)
                    const spreadWidth = strikes[strikes.length - 1] - strikes[0];

                    // Get number of contracts (both long and short should have same quantity)
                    const numContracts = Math.abs(positions[0].quantity || 0);

                    // Detect credit vs debit: positive cost basis = credit received
                    const isCreditSpread = totalCostBasis > 0;

                    let maxProfit;
                    if (isCreditSpread) {
                        maxProfit = Math.abs(totalCostBasis); // credit received
                    } else {
                        maxProfit = (spreadWidth * 100 * numContracts) - Math.abs(totalCostBasis); // debit spread
                    }

                    if (maxProfit <= 0) return '—';

                    // Current P&L using live quotes
                    const currentPnL = this.getGroupPnLWithLiveQuotes(positions);

                    // For debit spreads: only show when profitable
                    // For credit spreads: show even when negative (indicates credit erosion)
                    if (!isCreditSpread && currentPnL <= 0) return '—';

                    // % Max = (Current P&L / Max Profit) × 100
                    const maxPercent = ((currentPnL / maxProfit) * 100).toFixed(1);

                    return maxPercent + '%';
                },
                shouldShowMaxPercent(positions) {
                    if (!Array.isArray(positions) || positions.length <= 1) return false;
                    // Show max percent for multi-leg strategies (spreads, covered calls, etc.)
                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    return optionPositions.length >= 2;
                },
                getMaxPercentColor(value) {
                    if (typeof value !== 'string' || value === '—') return 'text-tv-muted';
                    const numVal = parseFloat(value);
                    if (numVal >= 50) return 'text-yellow-400 font-bold';
                    if (numVal >= 30) return 'text-tv-text';
                    return 'text-tv-muted';
                },
                getGroupDaysOpen(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    const firstPos = positions[0];
                    if (!firstPos.opened_at) return null;
                    const openedDate = new Date(firstPos.opened_at);
                    const now = new Date();
                    const days = Math.floor((now - openedDate) / (1000 * 60 * 60 * 24));
                    return days > 0 ? days : 0;
                },
                getMinDTE(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return null;
                    let minDTE = null;
                    for (const pos of positions) {
                        if (pos.expires_at) {
                            const dateStr = pos.expires_at.substring(0, 10);
                            const expDate = new Date(dateStr + 'T00:00:00');
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const dte = Math.ceil((expDate - today) / (1000 * 60 * 60 * 24));
                            if (minDTE === null || dte < minDTE) minDTE = dte;
                        }
                    }
                    return minDTE;
                },

                // Sort positions by column
                sortPositions(column) {
                    // Toggle direction if same column
                    if (this.sortColumn === column) {
                        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortColumn = column;
                        // Default to descending for P&L/value columns, ascending for others
                        if (column === 'pnl' || column === 'pnl_percent' || column === 'net_liq' || column === 'price' || column === 'ivr' || column === 'max_percent') {
                            this.sortDirection = 'desc';
                        } else {
                            this.sortDirection = 'asc';
                        }
                    }

                    // Save sort preference
                    localStorage.setItem('positions_sort', JSON.stringify({
                        column: this.sortColumn,
                        direction: this.sortDirection
                    }));
                },

                getGroupStrategyLabel(group) {
                    // First try group-level strategy from chain enrichment
                    if (group.strategyType && group.strategyType !== 'Unknown') return group.strategyType;
                    // Try to find strategy_type from any position in the group
                    for (const pos of group.positions) {
                        if (pos.strategy_type && pos.strategy_type !== 'Unknown') {
                            return pos.strategy_type;
                        }
                    }
                    // Fallback to detection based on position structure
                    return this.detectStrategy(group.positions);
                },
                detectStrategy(positions) {
                    if (!Array.isArray(positions) || positions.length === 0) return 'Unknown';

                    // Check for option vs non-option positions
                    const optionPositions = positions.filter(p =>
                        (p.instrument_type && p.instrument_type.includes('OPTION')) ||
                        (p.symbol && p.symbol.match(/\d{6}[CP]\d/))  // OCC option symbol format
                    );
                    const stockPositions = positions.filter(p => !optionPositions.includes(p));

                    // Pure stock/ETF position (no options)
                    if (optionPositions.length === 0 && stockPositions.length > 0) return 'Shares';

                    // Helper to get strike from position
                    const getStrike = (p) => {
                        if (p.strike_price && p.strike_price > 0) return p.strike_price;
                        const match = (p.symbol || '').match(/([CP])(\d+)/);
                        if (match && match[2].length >= 3) {
                            return parseFloat(match[2].slice(0, -3) + '.' + match[2].slice(-3));
                        }
                        return null;
                    };

                    // Helper to determine if position is long or short
                    const isShort = (p) => p.quantity_direction === 'Short' || (p.quantity || 0) < 0;

                    // Helper to determine option type from symbol (OCC format: SYMBOL + YYMMDD + C/P + STRIKE)
                    const getOptionType = (p) => {
                        if (p.option_type === 'Call') return 'C';
                        if (p.option_type === 'Put') return 'P';
                        // Look for C or P after 6-digit date in OCC symbol format
                        const match = (p.symbol || '').match(/\d{6}([CP])/);
                        return match ? match[1] : null;
                    };

                    // Categorize options by type
                    const calls = optionPositions.filter(p => getOptionType(p) === 'C');
                    const puts = optionPositions.filter(p => getOptionType(p) === 'P');

                    // Iron Condor: 4 legs - 2 calls, 2 puts
                    if (calls.length === 2 && puts.length === 2) return 'Iron Condor';

                    // Call spread: 2 calls at different strikes
                    if (calls.length === 2 && puts.length === 0) {
                        const strikes = calls.map(getStrike).filter(s => s).sort((a, b) => a - b);
                        const shortCall = calls.find(c => isShort(c));
                        if (strikes.length === 2 && shortCall) {
                            const shortStrike = getStrike(shortCall);
                            // Bull Call: long lower strike, short higher strike
                            // Bear Call: short lower strike, long higher strike
                            return shortStrike === strikes[1] ? 'Bull Call Spread' : 'Bear Call Spread';
                        }
                        return 'Call Spread';
                    }

                    // Put spread: 2 puts at different strikes
                    if (puts.length === 2 && calls.length === 0) {
                        const strikes = puts.map(getStrike).filter(s => s).sort((a, b) => a - b);
                        const shortPut = puts.find(p => isShort(p));
                        if (strikes.length === 2 && shortPut) {
                            const shortStrike = getStrike(shortPut);
                            // Bull Put: short higher strike, long lower strike
                            // Bear Put: short lower strike, long higher strike
                            return shortStrike === strikes[1] ? 'Bull Put Spread' : 'Bear Put Spread';
                        }
                        return 'Put Spread';
                    }

                    // Covered call: stock + short call
                    if (stockPositions.length > 0 && calls.length === 1 && isShort(calls[0])) {
                        return 'Covered Call';
                    }

                    // Cash secured put: single short put
                    if (puts.length === 1 && isShort(puts[0]) && calls.length === 0) {
                        return 'Cash Secured Put';
                    }

                    // Single long call
                    if (calls.length === 1 && !isShort(calls[0]) && puts.length === 0) {
                        return 'Long Call';
                    }

                    // Single long put
                    if (puts.length === 1 && !isShort(puts[0]) && calls.length === 0) {
                        return 'Long Put';
                    }

                    // Straddle/Strangle: 1 call + 1 put
                    if (calls.length === 1 && puts.length === 1) {
                        const callStrike = getStrike(calls[0]);
                        const putStrike = getStrike(puts[0]);
                        if (callStrike && putStrike) {
                            return callStrike === putStrike ? 'Straddle' : 'Strangle';
                        }
                    }

                    // Complex multi-leg
                    if (optionPositions.length > 2) return 'Complex';

                    // Generic fallback
                    if (calls.length > 0 && puts.length > 0) return 'Combo';
                    if (calls.length > 0) return 'Call';
                    if (puts.length > 0) return 'Put';
                    return 'Unknown';
                },
                calculateLiveMarketValue(position) {
                    this.quoteUpdateCounter;
                    let marketValue = position.market_value || 0;

                    const isOption = position.instrument_type && position.instrument_type.includes('OPTION');
                    const isEquity = !isOption && (!position.instrument_type || position.instrument_type === 'EQUITY' || position.instrument_type.includes('EQUITY'));

                    if (isEquity) {
                        const underlying = this.getUnderlyingSymbol(position);
                        const quote = this.underlyingQuotes[underlying];
                        if (quote && quote.price) {
                            const absValue = quote.price * position.quantity;
                            marketValue = position.quantity_direction === 'Short' ? -absValue : absValue;
                        }
                    } else {
                        const optionSymbol = position.symbol.trim();
                        const optionQuote = this.underlyingQuotes[optionSymbol];
                        if (optionQuote && optionQuote.mark !== undefined) {
                            const absValue = optionQuote.mark * position.quantity * 100;
                            marketValue = position.quantity_direction === 'Short' ? -absValue : absValue;
                        }
                    }
                    return marketValue;
                },
                calculateLivePositionPnL(position) {
                    const liveMarketValue = this.calculateLiveMarketValue(position);
                    const costBasis = position.cost_basis || 0;
                    const absMarketValue = Math.abs(liveMarketValue);
                    const absCostBasis = Math.abs(costBasis);

                    if (position.quantity_direction === 'Short') {
                        return absCostBasis - absMarketValue;
                    } else {
                        return absMarketValue - absCostBasis;
                    }
                },
                getGroupNetLiqWithLiveQuotes(positions) {
                    this.quoteUpdateCounter;
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + this.calculateLiveMarketValue(pos), 0);
                },
                getGroupPnLWithLiveQuotes(positions) {
                    this.quoteUpdateCounter;
                    if (!Array.isArray(positions)) return 0;
                    return positions.reduce((sum, pos) => sum + this.calculateLivePositionPnL(pos), 0);
                },
                getUnderlyingQuote(underlying) {
                    return this.underlyingQuotes[underlying] || null;
                },
                getUnderlyingIVR(underlying) {
                    const quote = this.getUnderlyingQuote(underlying);
                    if (!quote || !quote.ivr) return null;
                    return Math.round(quote.ivr * 100);
                },
                getOptionType(position) {
                    if (position.option_type) return position.option_type.charAt(0).toUpperCase();
                    if (position.symbol.includes('C')) return 'C';
                    if (position.symbol.includes('P')) return 'P';
                    return '—';
                },
                getSignedQuantity(position) {
                    const qty = position.quantity || 0;
                    if (position.quantity_direction === 'Short') return -qty;
                    return qty;
                },
                getExpirationDate(position) {
                    if (!position.expires_at) return '';
                    const date = new Date(position.expires_at);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                },
                getStrikePrice(position) {
                    if (position.strike_price && position.strike_price > 0) return position.strike_price.toFixed(2);
                    const symbol = position.symbol || '';
                    const match = symbol.match(/([CP])(\d+)/);
                    if (match) {
                        const priceStr = match[2];
                        if (priceStr.length >= 3) {
                            const strike = parseFloat(priceStr.slice(0, -3) + '.' + priceStr.slice(-3));
                            return strike.toFixed(2);
                        }
                    }
                    return '';
                },
                getDTE(position) {
                    if (!position.expires_at) return null;
                    const dateStr = position.expires_at.substring(0, 10);
                    const expDate = new Date(dateStr + 'T00:00:00');
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const dte = Math.ceil((expDate - today) / (1000 * 60 * 60 * 24));
                    return dte > 0 ? dte : 0;
                },

                // Roll analysis
                getRollAnalysis(group) {
                    const strategy = this.getGroupStrategyLabel(group);
                    const supportedStrategies = ['Bull Call Spread', 'Bear Put Spread', 'Bull Put Spread', 'Bear Call Spread'];
                    if (!supportedStrategies.includes(strategy)) return null;
                    if (!this.rollAlertSettings.enabled) return null;

                    const positions = group.positions;
                    const underlying = group.underlying;
                    const quote = this.underlyingQuotes[underlying];
                    if (!quote || !quote.price) return null;
                    const underlyingPrice = quote.price;

                    // Helper functions
                    const getStrike = (p) => {
                        if (p.strike_price && p.strike_price > 0) return p.strike_price;
                        const match = (p.symbol || '').match(/([CP])(\d+)/);
                        if (match && match[2].length >= 3) return parseFloat(match[2].slice(0, -3) + '.' + match[2].slice(-3));
                        return null;
                    };
                    const isShort = (p) => p.quantity_direction === 'Short' || (p.quantity || 0) < 0;
                    const getOptionType = (p) => {
                        if (p.option_type === 'Call') return 'C';
                        if (p.option_type === 'Put') return 'P';
                        const match = (p.symbol || '').match(/\d{6}([CP])/);
                        return match ? match[1] : null;
                    };

                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    if (optionPositions.length < 2) return null;

                    // Identify long and short legs
                    let longLeg = null, shortLeg = null;
                    for (const p of optionPositions) {
                        if (isShort(p)) shortLeg = p;
                        else longLeg = p;
                    }
                    if (!longLeg || !shortLeg) return null;

                    const longStrike = getStrike(longLeg);
                    const shortStrike = getStrike(shortLeg);
                    if (!longStrike || !shortStrike) return null;

                    const spreadWidth = Math.abs(shortStrike - longStrike);
                    const numContracts = Math.abs(longLeg.quantity || 0);
                    const totalCostBasis = Math.abs(positions.reduce((sum, p) => sum + (p.cost_basis || 0), 0));

                    const isBullCall = strategy === 'Bull Call Spread';
                    const isBullPut = strategy === 'Bull Put Spread';
                    const isBearCall = strategy === 'Bear Call Spread';
                    const isCredit = isBullPut || isBearCall;
                    const isDebit = !isCredit;

                    let maxProfit, maxLoss;
                    if (isCredit) {
                        maxProfit = totalCostBasis;                                    // credit received
                        maxLoss = (spreadWidth * 100 * numContracts) - totalCostBasis; // spread width minus credit
                    } else {
                        maxProfit = (spreadWidth * 100 * numContracts) - totalCostBasis;
                        maxLoss = totalCostBasis;
                    }
                    if (maxProfit <= 0 || maxLoss <= 0) return null;

                    const currentPnL = this.getGroupPnLWithLiveQuotes(positions);
                    const dte = this.getMinDTE(positions);

                    // Derived metrics
                    const pctMaxProfit = (currentPnL / maxProfit) * 100;
                    const pctMaxLoss = currentPnL < 0 ? (Math.abs(currentPnL) / maxLoss) * 100 : 0;
                    const remainingReward = maxProfit - currentPnL;
                    const remainingRisk = maxLoss + currentPnL;
                    const rewardToRisk = remainingRisk > 0 ? remainingReward / remainingRisk : 99;
                    const proximityToShort = Math.abs(underlyingPrice - shortStrike) / shortStrike * 100;

                    // Delta saturation via BS theoretical spread value.
                    // Measures what % of the spread's max value has been realized,
                    // accounting for both moneyness and remaining time value.
                    // Raw delta approaches 1.0 too fast for deep ITM (gives 100%),
                    // and net spread delta gives 0% for deep ITM (both legs ≈1.0).
                    // Theoretical price ratio avoids both problems.
                    const r = 0.045;
                    const sigma = this._getEffectiveIV(underlying);
                    const T = dte !== null && dte > 0 ? dte / 365 : 0.01;
                    const optType = (isBullCall || isBearCall) ? 'C' : 'P';
                    const longPrice = this._bsPrice(underlyingPrice, longStrike, T, r, sigma, optType);
                    const shortPrice = this._bsPrice(underlyingPrice, shortStrike, T, r, sigma, optType);
                    let deltaSaturation;
                    if (isCredit) {
                        // For credit spreads: shortPrice - longPrice = cost to buy back = theoretical risk
                        const theoreticalRisk = shortPrice - longPrice;
                        deltaSaturation = Math.min(Math.max(theoreticalRisk / spreadWidth * 100, 0), 100);
                    } else {
                        const theoreticalValue = longPrice - shortPrice;
                        deltaSaturation = Math.min(Math.max(theoreticalValue / spreadWidth * 100, 0), 100);
                    }

                    // Convexity / Risk state
                    let convexity;
                    if (isCredit) {
                        // For credit spreads: high delta sat = bad (near max loss)
                        if (deltaSaturation < 40) convexity = 'Low Risk';
                        else if (deltaSaturation < 65) convexity = 'Elevated Risk';
                        else convexity = 'High Risk';
                    } else {
                        // For debit spreads: high delta sat = good (near max profit)
                        if (deltaSaturation < 40) convexity = 'High';
                        else if (deltaSaturation < 65) convexity = 'Diminishing';
                        else convexity = 'Low';
                    }

                    // Late-stage check (>= 2 of 5 conditions)
                    // Credit spreads use tighter thresholds (theta helps, close at 50%)
                    let lateStageCount = 0;
                    if (isCredit) {
                        if (dte !== null && dte < 21) lateStageCount++;
                        if (pctMaxProfit >= 50) lateStageCount++;
                        if (deltaSaturation >= 65) lateStageCount++;
                        if (proximityToShort < 3) lateStageCount++;
                        if (rewardToRisk < 0.3) lateStageCount++;
                    } else {
                        if (dte !== null && dte < 30) lateStageCount++;
                        if (pctMaxProfit >= 70) lateStageCount++;
                        if (deltaSaturation >= 65) lateStageCount++;
                        if (proximityToShort < 3) lateStageCount++;
                        if (rewardToRisk < 0.6) lateStageCount++;
                    }
                    const isLateStage = lateStageCount >= 2;

                    // User targets
                    const targetConfig = this.strategyTargets[strategy];
                    const profitTargetPct = targetConfig ? targetConfig.profit_target_pct : (isBullCall ? 100 : 100);
                    const lossTargetPct = targetConfig ? targetConfig.loss_target_pct : 75;

                    // Build badges
                    const badges = [];
                    const profitHit = pctMaxProfit >= profitTargetPct;
                    const lossHit = pctMaxProfit <= -lossTargetPct;
                    const lowRRThreshold = isCredit ? 0.3 : 0.6;

                    if (profitHit && this.rollAlertSettings.profitTarget) {
                        badges.push({ label: 'Profit Target', color: 'green' });
                    }
                    if (lossHit && this.rollAlertSettings.lossLimit) {
                        badges.push({ label: 'Loss Limit', color: 'red' });
                    }
                    if (!profitHit && !lossHit && isLateStage && this.rollAlertSettings.lateStage) {
                        badges.push({ label: 'Late-Stage', color: 'yellow' });
                    }
                    if (!profitHit && deltaSaturation >= 65 && this.rollAlertSettings.deltaSaturation) {
                        // For credit spreads, high delta sat = near max loss (red); for debit = near max profit (orange)
                        badges.push({ label: 'High Delta', color: isCredit ? 'red' : 'orange' });
                    }
                    if (!profitHit && !lossHit && rewardToRisk < lowRRThreshold && this.rollAlertSettings.lowRewardToRisk) {
                        badges.push({ label: 'Low R:R', color: 'orange' });
                    }
                    // DTE warning — always shown when <= 21, independent of other conditions
                    // Suggestion text covers the gamma (credit) / theta (debit) implications
                    if (dte !== null && dte <= 21) {
                        badges.push({ label: '≤21 DTE', color: dte <= 7 ? 'red' : 'yellow' });
                    }

                    // Primary suggestion
                    const defensiveDirectionCredit = isBullPut ? 'down' : 'up'; // further OTM for credit spreads
                    const profitDirection = isBullCall ? 'up' : 'down';
                    const profitDirectionOut = isBullCall ? 'up and out' : 'down and out';
                    const defensiveDirection = isBullCall ? 'down' : 'up';
                    let suggestion = null;
                    let urgency = 'low'; // low, medium, high

                    if (isCredit) {
                        // Credit spread suggestions
                        if (lossHit) {
                            urgency = 'high';
                            suggestion = `Close to limit loss. Down ${Math.abs(pctMaxProfit).toFixed(0)}% of credit received with ${dte ?? '?'} DTE remaining. Could roll out for a net credit at same or further OTM strikes ${defensiveDirectionCredit} \u2014 do not roll for a debit.`;
                        } else if (profitHit) {
                            urgency = 'medium';
                            suggestion = `Captured ${pctMaxProfit.toFixed(0)}% of max profit ($${maxProfit.toFixed(0)} credit). Close to lock in gains.`;
                        } else if (proximityToShort < 3) {
                            urgency = 'medium';
                            suggestion = `Short strike being tested (${proximityToShort.toFixed(1)}% away). Roll out in time or further OTM ${defensiveDirectionCredit} for a net credit.`;
                        } else if (dte !== null && dte <= 21 && deltaSaturation > 40) {
                            urgency = 'medium';
                            suggestion = `Gamma risk elevated at ${dte} DTE with spread near the money. Close or roll out in time for a credit.`;
                        } else if (dte !== null && dte <= 21 && deltaSaturation <= 40) {
                            urgency = 'low';
                            suggestion = `Spread is far OTM with theta in your favor at ${dte} DTE \u2014 monitor.`;
                        } else if (isLateStage && pctMaxProfit >= 50) {
                            urgency = 'low';
                            suggestion = `Premium is ${pctMaxProfit.toFixed(0)}% captured with diminishing return. Close.`;
                        }
                    } else {
                        // Debit spread suggestions (existing logic)
                        if (lossHit) {
                            urgency = 'high';
                            suggestion = `Consider closing to limit loss. Down ${Math.abs(pctMaxProfit).toFixed(0)}% of debit paid with ${dte ?? '?'} DTE remaining. A defensive roll ${defensiveDirection} would reposition strikes near the current price but adds to cost basis.`;
                        } else if (profitHit && (isLateStage || (dte !== null && dte < 21))) {
                            urgency = 'medium';
                            suggestion = `Profit target reached with ${dte ?? '?'} DTE remaining. May consider closing to lock in ${pctMaxProfit.toFixed(0)}% of max profit.`;
                        } else if (profitHit) {
                            urgency = 'low';
                            suggestion = `Could roll ${profitDirectionOut} to capture additional upside, or close at ${pctMaxProfit.toFixed(0)}% of max profit. Remaining reward-to-risk is ${rewardToRisk.toFixed(2)}.`;
                        } else if (isLateStage && pctMaxProfit >= 50) {
                            urgency = 'low';
                            suggestion = `Structure is maturing with ${convexity.toLowerCase()} convexity. ${pctMaxProfit.toFixed(0)}% of max profit reached with ${dte ?? '?'} DTE. Consider closing or rolling ${profitDirectionOut}.`;
                        } else if (dte !== null && dte <= 21) {
                            urgency = 'medium';
                            suggestion = `Approaching 21 DTE. Theta decay accelerates from here \u2014 consider rolling out to a later expiration to preserve time value, or closing to realize current P&L.`;
                        }
                    }

                    // Border color for the panel
                    let borderColor = 'blue';
                    if (lossHit) borderColor = 'red';
                    else if (profitHit) borderColor = 'green';
                    else if (isLateStage) borderColor = 'yellow';
                    else if (dte !== null && dte <= 21) borderColor = 'yellow';

                    // TODO: Per-leg IV from option quotes for more accurate delta
                    // TODO: Gamma/convexity health tracking across consecutive updates
                    // TODO: Laddering / partial roll suggestions
                    // TODO: Alert/notification system integration
                    // TODO: Multi-leg (Iron Condor) support with per-wing analysis

                    return {
                        strategy,
                        isCredit,
                        pctMaxProfit: pctMaxProfit.toFixed(1),
                        pctMaxLoss: pctMaxLoss.toFixed(1),
                        rewardToRisk: rewardToRisk.toFixed(2),
                        deltaSaturation: deltaSaturation.toFixed(0),
                        proximityToShort: proximityToShort.toFixed(1),
                        maxProfit: maxProfit.toFixed(0),
                        maxLoss: maxLoss.toFixed(0),
                        convexity,
                        isLateStage,
                        badges,
                        suggestion,
                        urgency,
                        borderColor
                    };
                },

                // Roll alert settings
                loadRollAlertSettings() {
                    try {
                        const saved = localStorage.getItem('rollAlertSettings');
                        if (saved) this.rollAlertSettings = JSON.parse(saved);
                    } catch (e) { /* use defaults */ }
                },

                async loadStrategyTargets() {
                    try {
                        const resp = await fetch('/api/settings/targets');
                        if (resp.ok) {
                            const targets = await resp.json();
                            this.strategyTargets = {};
                            targets.forEach(t => { this.strategyTargets[t.strategy_name] = t; });
                        }
                    } catch (e) { console.error('Failed to load strategy targets:', e); }
                },

                // Black-Scholes delta utilities
                _normalCDF(x) {
                    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
                    const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
                    const sign = x < 0 ? -1 : 1;
                    x = Math.abs(x) / Math.sqrt(2);
                    const t = 1.0 / (1.0 + p * x);
                    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                    return 0.5 * (1.0 + sign * y);
                },

                _bsDelta(S, K, T, r, sigma, optType) {
                    if (T <= 0 || sigma <= 0 || S <= 0 || K <= 0) return optType === 'C' ? 0.5 : -0.5;
                    const d1 = (Math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * Math.sqrt(T));
                    if (optType === 'C') return this._normalCDF(d1);
                    return this._normalCDF(d1) - 1;
                },

                _bsPrice(S, K, T, r, sigma, optType) {
                    if (T <= 0) return optType === 'C' ? Math.max(0, S - K) : Math.max(0, K - S);
                    if (sigma <= 0 || S <= 0 || K <= 0) return 0;
                    const sqrtT = Math.sqrt(T);
                    const d1 = (Math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * sqrtT);
                    const d2 = d1 - sigma * sqrtT;
                    if (optType === 'C') {
                        return S * this._normalCDF(d1) - K * Math.exp(-r * T) * this._normalCDF(d2);
                    }
                    return K * Math.exp(-r * T) * this._normalCDF(-d2) - S * this._normalCDF(-d1);
                },

                _getEffectiveIV(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    if (quote && quote.iv && quote.iv > 0) return quote.iv / 100;
                    return 0.30;
                },

                // Notes (DB-persisted)
                async loadComments() {
                    try {
                        const response = await fetch('/api/position-notes');
                        if (response.ok) {
                            const data = await response.json();
                            this.positionComments = data.notes || {};
                            this.chainNoteMap = data.chain_map || {};
                        } else {
                            this.positionComments = {};
                        }
                    } catch (error) {
                        console.error('Error loading position notes:', error);
                        this.positionComments = {};
                    }
                    // One-time migration from localStorage
                    try {
                        const stored = localStorage.getItem('positionComments');
                        if (stored) {
                            const local = JSON.parse(stored);
                            let migrated = false;
                            for (const [key, value] of Object.entries(local)) {
                                if (value && !this.positionComments[key]) {
                                    this.positionComments[key] = value;
                                    fetch(`/api/position-notes/${encodeURIComponent(key)}`, {
                                        method: 'PUT',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ note: value })
                                    }).catch(err => console.error('Migration save error:', err));
                                    migrated = true;
                                }
                            }
                            localStorage.removeItem('positionComments');
                            if (migrated) console.log('Migrated position notes from localStorage to DB');
                        }
                    } catch (e) { /* ignore migration errors */ }
                },
                getCommentKey(group) {
                    if (group.chainId && group.chainId !== 'unenriched') return `chain_${group.chainId}`;
                    const symbol = group.underlying;
                    const account = group.accountNumber || 'default';
                    const expiration = group.positions[0]?.expires_at || group.positions[0]?.expiration || 'noexp';
                    return `pos_${symbol}_${expiration}_${account}`;
                },
                getPositionComment(group) {
                    const key = this.getCommentKey(group);
                    if (this.positionComments[key]) return this.positionComments[key];
                    // Fallback: search chain_* notes matching this underlying/account
                    const underlying = group.underlying;
                    const account = group.accountNumber || 'default';
                    for (const [noteKey, noteValue] of Object.entries(this.positionComments)) {
                        if (noteKey.startsWith('chain_') && noteValue) {
                            const chainId = noteKey.substring(6);
                            const info = this.chainNoteMap[chainId];
                            if (info && info.underlying === underlying && info.account === account) {
                                return noteValue;
                            }
                        }
                    }
                    return '';
                },
                updatePositionComment(group, value) {
                    const key = this.getCommentKey(group);
                    this.positionComments[key] = value;
                    if (this._noteSaveTimers[key]) {
                        clearTimeout(this._noteSaveTimers[key]);
                    }
                    this._noteSaveTimers[key] = setTimeout(() => {
                        fetch(`/api/position-notes/${encodeURIComponent(key)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ note: value })
                        }).catch(err => console.error('Error saving position note:', err));
                        // Also save under matching chain_* key for cross-page sync
                        if (key.startsWith('pos_')) {
                            const underlying = group.underlying;
                            const account = group.accountNumber || 'default';
                            for (const [chainId, info] of Object.entries(this.chainNoteMap)) {
                                if (info.underlying === underlying && info.account === account) {
                                    const chainKey = `chain_${chainId}`;
                                    this.positionComments[chainKey] = value;
                                    fetch(`/api/position-notes/${encodeURIComponent(chainKey)}`, {
                                        method: 'PUT',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ note: value })
                                    }).catch(() => {});
                                    break;
                                }
                            }
                        }
                        delete this._noteSaveTimers[key];
                    }, 500);
                },

                // Get single-letter account symbol (R=Roth, I=Individual, T=Traditional)
                getAccountSymbol(accountNumber) {
                    const account = this.accounts.find(a => a.account_number === accountNumber);
                    if (!account) return '?';
                    const name = (account.account_name || '').toUpperCase();
                    if (name.includes('ROTH')) return 'R';
                    if (name.includes('INDIVIDUAL')) return 'I';
                    if (name.includes('TRADITIONAL')) return 'T';
                    return name.charAt(0) || '?';  // First letter fallback
                }
            };
        }
    </script>
</head>
<body class="min-h-screen tv-scrollbar" x-data="positionsApp()" x-init="init()">

    <!-- Compact Nav Bar -->
    <nav class="bg-tv-panel border-b border-tv-border sticky top-0 z-50">
        <div class="flex items-center justify-between h-16 px-4">
            <!-- Left: Logo & Nav -->
            <div class="flex items-center gap-8">
                <span class="text-tv-blue font-semibold text-2xl">
                    <i class="fas fa-chart-line mr-2"></i>OptionEdge
                </span>
                <div class="flex items-center border-l border-tv-border pl-8 gap-4">
                    <a href="/positions" class="text-tv-text bg-tv-border px-4 py-2 text-lg rounded-sm">Positions</a>
                    <a href="/chains" class="text-tv-muted hover:text-tv-text px-4 py-2 text-lg">Chains</a>
                    <a href="/reports" class="text-tv-muted hover:text-tv-text px-4 py-2 text-lg">Reports</a>
                    <a href="/risk" class="text-tv-muted hover:text-tv-text px-4 py-2 text-lg">Risk</a>
                </div>
            </div>

            <!-- Right: Account & User -->
            <div class="flex items-center gap-6 text-base">
                <select x-model="selectedAccount" @change="onAccountChange()"
                        class="bg-tv-bg border border-tv-border text-tv-text text-base px-4 py-2 focus:outline-none focus:border-tv-blue">
                    <option value="">All Accounts</option>
                    <template x-for="account in accounts" :key="account.account_number">
                        <option :value="account.account_number" x-text="'(' + getAccountSymbol(account.account_number) + ') ' + (account.account_name || account.account_number)"></option>
                    </template>
                </select>
                <a href="/settings" class="border-l border-tv-border pl-6 text-tv-muted hover:text-tv-text">
                    <i class="fas fa-cog"></i>
                </a>
            </div>
        </div>
    </nav>

    <!-- Action Bar -->
    <div class="bg-tv-panel border-b border-tv-border px-4 py-3 flex items-center justify-between">
        <div class="flex items-center gap-4">
            <button @click="fetchPositions(true)"
                    :disabled="isLoading"
                    class="bg-tv-green/20 hover:bg-tv-green/30 text-tv-green border border-tv-green/30 px-4 py-2 text-base disabled:opacity-50">
                <i class="fas fa-sync-alt mr-2" :class="{'animate-spin': isLoading}"></i>
                <span x-text="isLoading ? 'Syncing...' : 'Sync'"></span>
            </button>

            <!-- Account Balances -->
            <template x-if="currentAccountBalance">
                <div class="flex items-center gap-6 ml-6 text-base">
                    <div>
                        <span class="text-tv-muted text-sm">Net Liq:</span>
                        <span class="font-medium ml-1" x-text="'$' + formatNumber(currentAccountBalance.net_liquidating_value)"></span>
                    </div>
                    <div class="flex-grow"></div>
                    <div>
                        <span class="text-tv-muted text-sm">Cash:</span>
                        <span class="font-medium ml-1" x-text="'$' + formatNumber(currentAccountBalance.cash_balance)"></span>
                    </div>
                    <div>
                        <span class="text-tv-muted text-sm">Option BP:</span>
                        <span class="font-medium ml-1" x-text="'$' + formatNumber(currentAccountBalance.derivative_buying_power)"></span>
                    </div>
                    <div>
                        <span class="text-tv-muted text-sm">Stock BP:</span>
                        <span class="font-medium ml-1" x-text="'$' + formatNumber(currentAccountBalance.equity_buying_power)"></span>
                    </div>
                </div>
            </template>

            <span class="text-sm text-tv-muted ml-4" x-show="lastQuoteUpdate">
                Quotes: <span x-text="lastQuoteUpdate"></span>
                <span x-show="liveQuotesActive" class="text-tv-green ml-1">LIVE</span>
            </span>
        </div>

        <!-- Filters inline -->
        <div class="flex items-center gap-4 text-base">
            <select x-model="selectedInstrumentType" @change="filterPositions(); requestLiveQuotes()"
                    class="bg-tv-bg border border-tv-border text-tv-text text-base px-3 py-2">
                <option value="">All Types</option>
                <option value="EQUITY">Stocks</option>
                <option value="EQUITY_OPTION">Options</option>
            </select>
            <select x-model="selectedUnderlying" @change="filterPositions(); requestLiveQuotes()"
                    class="bg-tv-bg border border-tv-border text-tv-text text-base px-3 py-2 max-w-[140px]">
                <option value="">All Symbols</option>
                <template x-for="underlying in underlyings" :key="underlying">
                    <option :value="underlying" x-text="underlying"></option>
                </template>
            </select>
        </div>
    </div>

    <!-- Loading State -->
    <div x-show="isLoading" class="text-center py-12">
        <i class="fas fa-spinner fa-spin text-4xl text-tv-blue mb-4"></i>
        <p class="text-tv-muted">Loading positions...</p>
    </div>

    <!-- Empty State -->
    <div x-show="!isLoading && !error && filteredPositions.length === 0" class="text-center py-12">
        <i class="fas fa-layer-group text-4xl text-tv-muted mb-4"></i>
        <p class="text-tv-muted mb-4">No open positions found</p>
    </div>

    <!-- Main Content -->
    <main x-show="!isLoading && !error && filteredPositions.length > 0 && allPositions.length > 0" x-cloak class="p-2">
        <!-- Column Headers -->
        <div class="flex items-center px-4 py-2 text-sm text-tv-muted border-b border-tv-border bg-tv-panel/50 sticky top-16">
            <span class="w-8"></span>
            <span class="w-6 text-center" x-show="selectedAccount === ''"></span>
            <span class="w-24 cursor-pointer hover:text-tv-text flex items-center gap-1" @click="sortPositions('underlying')">
                Symbol
                <span x-show="sortColumn === 'underlying'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12 text-center cursor-pointer hover:text-tv-text flex items-center justify-center gap-1" @click="sortPositions('ivr')">
                IVR
                <span x-show="sortColumn === 'ivr'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-40 cursor-pointer hover:text-tv-text flex items-center gap-1" @click="sortPositions('price')">
                Price
                <span x-show="sortColumn === 'price'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12"></span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('cost_basis')">
                Cost Basis
                <span x-show="sortColumn === 'cost_basis'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('net_liq')">
                Net Liq
                <span x-show="sortColumn === 'net_liq'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('pnl')">
                P&L
                <span x-show="sortColumn === 'pnl'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-16 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('pnl_percent')">
                % Ret
                <span x-show="sortColumn === 'pnl_percent'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-14 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('max_percent')">
                % Max
                <span x-show="sortColumn === 'max_percent'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12 text-center cursor-pointer hover:text-tv-text flex items-center justify-center gap-1" @click="sortPositions('days')">
                Days
                <span x-show="sortColumn === 'days'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12 text-center cursor-pointer hover:text-tv-text flex items-center justify-center gap-1" @click="sortPositions('dte')">
                DTE
                <span x-show="sortColumn === 'dte'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-40 cursor-pointer hover:text-tv-text flex items-center gap-1" @click="sortPositions('strategy')">
                Strategy
                <span x-show="sortColumn === 'strategy'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
        </div>

        <!-- Position Groups -->
        <div class="divide-y divide-tv-border">
            <template x-for="(group, index) in groupedPositions" :key="group.groupKey">
                <div x-data="{ expanded: false }">
                    <!-- Group Row -->
                    <div class="flex items-center px-4 py-2 hover:bg-tv-border/30 cursor-pointer transition-colors"
                         @click="expanded = !expanded">
                        <!-- Chevron -->
                        <div class="w-8">
                            <i class="fas fa-chevron-right text-tv-muted transition-transform duration-200"
                               :class="{ 'rotate-90': expanded }"></i>
                        </div>

                        <!-- Account Symbol (only when All Accounts selected) -->
                        <div class="w-6 text-center text-tv-muted text-sm" x-show="selectedAccount === ''">
                            <span x-text="getAccountSymbol(group.accountNumber)"></span>
                        </div>

                        <!-- Symbol -->
                        <div class="w-24">
                            <div class="font-semibold text-base text-tv-text" x-text="group.displayKey || group.underlying"></div>
                        </div>

                        <!-- IVR -->
                        <div class="w-12 text-center"
                             :class="getUnderlyingIVR(group.underlying) >= 50 ? 'font-bold text-yellow-400' : 'text-tv-muted'"
                             x-text="getUnderlyingIVR(group.underlying) !== null ? getUnderlyingIVR(group.underlying) : ''"></div>

                        <!-- Price -->
                        <div class="w-40 flex items-center gap-2">
                            <template x-if="getUnderlyingQuote(group.underlying)">
                                <div class="flex items-center gap-2">
                                    <div class="px-2 py-1 rounded-sm text-base font-medium border"
                                         :class="(getUnderlyingQuote(group.underlying).change || 0) >= 0 ? 'bg-green-900/60 text-green-400 border-green-700/50' : 'bg-tv-border text-tv-muted border-tv-border'">
                                        <span x-text="formatNumber(getUnderlyingQuote(group.underlying).price || 0)"></span>
                                    </div>
                                    <div class="text-sm"
                                         :class="(getUnderlyingQuote(group.underlying).change || 0) >= 0 ? 'text-green-400' : 'text-tv-muted'">
                                        <span x-text="((getUnderlyingQuote(group.underlying).change || 0) >= 0 ? '+' : '') + (getUnderlyingQuote(group.underlying).changePercent || 0).toFixed(2) + '%'"></span>
                                    </div>
                                </div>
                            </template>
                            <template x-if="!getUnderlyingQuote(group.underlying)">
                                <span class="text-tv-muted text-sm"><i class="fas fa-spinner fa-spin"></i></span>
                            </template>
                        </div>

                        <!-- Chain Link -->
                        <div class="w-12">
                            <a :href="'/chains?underlying=' + encodeURIComponent(group.underlying) + '&status=open'"
                               @click.stop
                               class="text-tv-blue hover:text-blue-400"
                               title="View chains">
                                <i class="fas fa-link"></i>
                            </a>
                        </div>

                        <!-- Cost Basis -->
                        <div class="w-24 text-right"
                             :class="getGroupCostBasis(group.positions) >= 0 ? 'text-tv-green' : 'text-tv-red'">
                            <span x-show="getGroupCostBasis(group.positions) < 0">-</span>$<span x-text="formatNumber(Math.abs(getGroupCostBasis(group.positions)))"></span>
                        </div>

                        <!-- Net Liq -->
                        <div class="w-24 text-right font-medium"
                             :class="getGroupNetLiqWithLiveQuotes(group.positions) >= 0 ? 'text-tv-green' : 'text-tv-red'">
                            <span x-show="getGroupNetLiqWithLiveQuotes(group.positions) < 0">-</span>$<span x-text="formatNumber(Math.abs(getGroupNetLiqWithLiveQuotes(group.positions)))"></span>
                        </div>

                        <!-- P&L -->
                        <div class="w-24 text-right font-medium"
                             :class="getGroupPnLWithLiveQuotes(group.positions) >= 0 ? 'text-tv-green' : 'text-tv-red'">
                            <span x-show="getGroupPnLWithLiveQuotes(group.positions) < 0">-</span>$<span x-text="formatNumber(Math.abs(getGroupPnLWithLiveQuotes(group.positions)))"></span>
                        </div>

                        <!-- % Return -->
                        <div class="w-16 text-right"
                             :class="parseFloat(getGroupPnLPercent(group.positions)) >= 0 ? 'text-tv-green' : 'text-tv-red'">
                            <span x-text="getGroupPnLPercent(group.positions) ? getGroupPnLPercent(group.positions) + '%' : ''"></span>
                        </div>

                        <!-- % Max -->
                        <div class="w-14 text-right"
                             :class="getMaxPercentColor(getGroupMaxPercent(group.positions))"
                             x-text="shouldShowMaxPercent(group.positions) ? getGroupMaxPercent(group.positions) : '—'"></div>

                        <!-- Days -->
                        <div class="w-12 text-center text-tv-text" x-text="getGroupDaysOpen(group.positions) || ''"></div>

                        <!-- DTE -->
                        <div class="w-12 text-center"
                             :class="getMinDTE(group.positions) <= 21 ? 'font-bold text-yellow-400' : 'text-tv-text'"
                             x-text="getMinDTE(group.positions) || ''"></div>

                        <!-- Strategy -->
                        <div class="w-40">
                            <div class="text-sm text-tv-muted" x-text="getGroupStrategyLabel(group)"></div>
                            <template x-if="group.rollAnalysis && group.rollAnalysis.badges.length > 0">
                                <div class="flex flex-wrap gap-1 mt-0.5">
                                    <template x-for="badge in group.rollAnalysis.badges" :key="badge.label">
                                        <span class="text-[10px] px-1.5 py-0 rounded-sm border leading-4"
                                              :class="{
                                                  'bg-green-500/20 text-green-400 border-green-500/50': badge.color === 'green',
                                                  'bg-red-500/20 text-red-400 border-red-500/50': badge.color === 'red',
                                                  'bg-yellow-500/20 text-yellow-400 border-yellow-500/50': badge.color === 'yellow',
                                                  'bg-orange-500/20 text-orange-400 border-orange-500/50': badge.color === 'orange'
                                              }"
                                              x-text="badge.label"></span>
                                    </template>
                                </div>
                            </template>
                        </div>

                        <!-- Comment indicator -->
                        <div class="flex-1 text-tv-muted text-sm truncate pl-2"
                             x-show="getPositionComment(group)"
                             x-text="getPositionComment(group)"></div>

                    </div>

                    <!-- TT-style Expanded Positions -->
                    <div x-show="expanded" class="bg-tv-bg border-t border-tv-border">
                        <div class="mx-4 my-3 p-3 bg-tv-panel rounded border border-tv-border font-mono">
                            <div class="flex gap-4">
                                <!-- Leg data -->
                                <div class="flex-shrink-0 space-y-1">
                                    <!-- Header row -->
                                    <div class="flex items-center text-xs text-tv-muted pb-1 border-b border-tv-border/30">
                                        <span class="w-10 text-right">Qty</span>
                                        <span class="w-16 text-center mx-2">Exp</span>
                                        <span class="w-10">DTE</span>
                                        <span class="w-16 text-center mx-2">Strike</span>
                                        <span class="w-6">Type</span>
                                        <span class="w-24 text-right ml-4">Cost Basis</span>
                                        <span class="w-20 text-right">Net Liq</span>
                                        <span class="w-20 text-right">P&L</span>
                                        <span class="w-16 text-right">P&L %</span>
                                    </div>

                                    <!-- Data rows -->
                                    <template x-for="position in [...group.positions].sort((a, b) => {
                                        const expA = a.expires_at || '';
                                        const expB = b.expires_at || '';
                                        if (expA !== expB) return expA.localeCompare(expB);
                                        const strikeA = parseFloat(getStrikePrice(a)) || 0;
                                        const strikeB = parseFloat(getStrikePrice(b)) || 0;
                                        return strikeA - strikeB;
                                    })" :key="position.symbol + position.account_number">
                                        <div class="flex items-center text-sm py-0.5">
                                            <!-- Qty -->
                                            <span class="w-10 text-right font-medium"
                                                  :class="getSignedQuantity(position) > 0 ? 'text-tv-green' : 'text-tv-red'"
                                                  x-text="getSignedQuantity(position)"></span>
                                            <!-- Expiration (options only) -->
                                            <span class="w-16 text-center bg-tv-border/30 mx-2 py-0.5 rounded text-tv-text"
                                                  x-text="position.instrument_type?.includes('OPTION') ? getExpirationDate(position) : ''"></span>
                                            <!-- DTE (options only) -->
                                            <span class="w-10 text-tv-muted"
                                                  :class="getDTE(position) <= 7 ? 'text-tv-red' : getDTE(position) <= 30 ? 'text-yellow-400' : ''"
                                                  x-text="position.instrument_type?.includes('OPTION') && getDTE(position) !== null ? getDTE(position) + 'd' : ''"></span>
                                            <!-- Strike (options only) -->
                                            <span class="w-16 text-center bg-tv-border/30 mx-2 py-0.5 rounded text-tv-text"
                                                  x-text="position.instrument_type?.includes('OPTION') ? getStrikePrice(position) : ''"></span>
                                            <!-- Option Type (options only) -->
                                            <span class="w-6 text-tv-muted"
                                                  x-text="position.instrument_type?.includes('OPTION') ? getOptionType(position) : ''"></span>
                                            <!-- Cost Basis -->
                                            <span class="w-24 text-right ml-4"
                                                  :class="position.cost_basis >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                  x-text="'$' + formatNumber(position.cost_basis)"></span>
                                            <!-- Net Liq -->
                                            <span class="w-20 text-right text-tv-muted"
                                                  x-text="'$' + formatNumber(calculateLiveMarketValue(position))"></span>
                                            <!-- P&L -->
                                            <span class="w-20 text-right font-medium"
                                                  :class="calculateLivePositionPnL(position) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                  x-text="'$' + formatNumber(calculateLivePositionPnL(position))"></span>
                                            <!-- P&L % -->
                                            <span class="w-16 text-right"
                                                  :class="(calculateLivePositionPnL(position) / Math.abs(position.cost_basis || 1) * 100) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                  x-text="(calculateLivePositionPnL(position) / Math.abs(position.cost_basis || 1) * 100).toFixed(1) + '%'"></span>
                                        </div>
                                    </template>
                                </div>

                                <!-- Comments -->
                                <div class="flex-1 min-w-0">
                                    <div class="text-xs text-tv-muted pb-1 border-b border-tv-border/30 mb-1">Notes</div>
                                    <textarea :value="getPositionComment(group)"
                                              @input="updatePositionComment(group, $event.target.value)"
                                              @click.stop
                                              rows="3"
                                              class="w-full bg-transparent text-tv-text text-sm font-sans border border-tv-border/30 rounded px-2 py-1 resize-none outline-none focus:border-tv-blue/50"
                                              placeholder="Add notes..."></textarea>
                                </div>
                            </div>
                        </div>

                        <!-- Roll Analysis Panel -->
                        <template x-if="group.rollAnalysis">
                            <div class="mx-4 mb-3 p-3 bg-tv-panel rounded border-l-2"
                                 :class="{
                                     'border-green-500 border border-l-2 border-green-500/30': group.rollAnalysis.borderColor === 'green',
                                     'border-red-500 border border-l-2 border-red-500/30': group.rollAnalysis.borderColor === 'red',
                                     'border-yellow-500 border border-l-2 border-yellow-500/30': group.rollAnalysis.borderColor === 'yellow',
                                     'border-tv-blue border border-l-2 border-tv-blue/30': group.rollAnalysis.borderColor === 'blue'
                                 }">
                                <!-- Header -->
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-xs font-semibold text-tv-text">Roll Analysis</span>
                                    <span class="text-[10px] px-1.5 py-0 rounded-sm border leading-4"
                                          :class="{
                                              'bg-green-500/20 text-green-400 border-green-500/50': group.rollAnalysis.convexity === 'High' || group.rollAnalysis.convexity === 'Low Risk',
                                              'bg-yellow-500/20 text-yellow-400 border-yellow-500/50': group.rollAnalysis.convexity === 'Diminishing' || group.rollAnalysis.convexity === 'Elevated Risk',
                                              'bg-red-500/20 text-red-400 border-red-500/50': group.rollAnalysis.convexity === 'Low' || group.rollAnalysis.convexity === 'High Risk'
                                          }"
                                          x-text="group.rollAnalysis.isCredit ? group.rollAnalysis.convexity : (group.rollAnalysis.convexity + ' Convexity')"></span>
                                </div>

                                <!-- Metrics grid -->
                                <div class="grid grid-cols-6 gap-2 text-xs mb-2">
                                    <div class="text-center">
                                        <div class="text-tv-muted">% Max Profit</div>
                                        <div class="font-medium" :class="parseFloat(group.rollAnalysis.pctMaxProfit) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                             x-text="group.rollAnalysis.pctMaxProfit + '%'"></div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-tv-muted">% Max Loss</div>
                                        <div class="font-medium" :class="parseFloat(group.rollAnalysis.pctMaxLoss) > 0 ? 'text-tv-red' : 'text-tv-muted'"
                                             x-text="group.rollAnalysis.pctMaxLoss + '%'"></div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-tv-muted">Reward:Risk</div>
                                        <div class="font-medium" :class="parseFloat(group.rollAnalysis.rewardToRisk) < (group.rollAnalysis.isCredit ? 0.3 : 0.6) ? 'text-orange-400' : 'text-tv-text'"
                                             x-text="group.rollAnalysis.rewardToRisk"></div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-tv-muted">Delta Sat.</div>
                                        <div class="font-medium" :class="parseFloat(group.rollAnalysis.deltaSaturation) >= 65 ? (group.rollAnalysis.isCredit ? 'text-tv-red' : 'text-orange-400') : 'text-tv-text'"
                                             x-text="group.rollAnalysis.deltaSaturation + '%'"></div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-tv-muted">Near Short</div>
                                        <div class="font-medium" :class="parseFloat(group.rollAnalysis.proximityToShort) < 3 ? 'text-yellow-400' : 'text-tv-text'"
                                             x-text="group.rollAnalysis.proximityToShort + '%'"></div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-tv-muted">Max P / Max L</div>
                                        <div class="font-medium text-tv-text"
                                             x-text="'$' + group.rollAnalysis.maxProfit + ' / $' + group.rollAnalysis.maxLoss"></div>
                                    </div>
                                </div>

                                <!-- Suggestion box -->
                                <template x-if="group.rollAnalysis.suggestion">
                                    <div class="mt-2 pl-3 py-2 border-l-2 text-xs text-tv-text bg-tv-bg/50 rounded-r"
                                         :class="{
                                             'border-red-500': group.rollAnalysis.urgency === 'high',
                                             'border-yellow-500': group.rollAnalysis.urgency === 'medium',
                                             'border-tv-blue': group.rollAnalysis.urgency === 'low'
                                         }">
                                        <span x-text="group.rollAnalysis.suggestion"></span>

                                    </div>
                                </template>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>
    </main>
</body>
</html>
