<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OptionLedger - Positions</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%232962ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='22 12 18 12 15 21 9 3 6 12 2 12'></polyline></svg>">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        tv: {
                            bg: '#131722',
                            panel: '#1e222d',
                            border: '#2a2e39',
                            text: '#d1d4dc',
                            muted: '#787b86',
                            green: '#26a69a',
                            red: '#ef5350',
                            blue: '#2962ff',
                        }
                    }
                }
            }
        }
    </script>

    <!-- Alpine.js for interactivity -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * { font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif; }
        body { background: #131722; color: #d1d4dc; font-size: 16px; }
        .tv-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .tv-scrollbar::-webkit-scrollbar-track { background: #1e222d; }
        .tv-scrollbar::-webkit-scrollbar-thumb { background: #2a2e39; border-radius: 3px; }
        .tv-scrollbar::-webkit-scrollbar-thumb:hover { background: #363a45; }
        [x-cloak] { display: none !important; }
    </style>

    <!-- Shared utilities -->
    <script src="/static/js/utils.js"></script>

    <!-- Inline positions app -->
    <script>
        function buildOptionStratUrl(strategyType, underlying, legs) {
            const SLUGS = {
                'Bull Put Spread':  'bull-put-spread',
                'Bull Call Spread':  'bull-call-spread',
                'Bear Put Spread':  'bear-put-spread',
                'Bear Call Spread':  'bear-call-spread',
            };
            const slug = SLUGS[strategyType];
            if (!slug || !underlying || !legs || legs.length !== 2) return null;
            if (legs.some(l => !l.expiration || !l.option_type || l.strike == null)) return null;

            const encodeLeg = (leg) => {
                const sign = leg.isShort ? '-' : '';
                const d = leg.expiration.replace(/-/g, '').slice(2, 8);
                const type = leg.option_type.toUpperCase().startsWith('P') ? 'P' : 'C';
                const strike = leg.strike % 1 === 0 ? String(Math.trunc(leg.strike)) : String(leg.strike);
                return `${sign}.${underlying}${d}${type}${strike}`;
            };

            return `https://optionstrat.com/build/${slug}/${underlying}/${legs.map(encodeLeg).join(',')}`;
        }

        function positionsApp() {
            return {
                // State
                allChains: [],        // chain objects from /api/open-chains
                allItems: [],         // flat list of displayable items (chains)
                filteredItems: [],
                accounts: [],
                accountBalances: {},
                underlyingQuotes: {},
                quoteUpdateCounter: 0,
                positionComments: {},
                _noteSaveTimers: {},
                selectedAccount: '',
                selectedUnderlying: '',
                isLoading: false,
                error: null,
                liveQuotesActive: false,
                lastQuoteUpdate: null,
                lastSyncTimestamp: '',
                ws: null,
                // Roll analysis state
                strategyTargets: {},
                rollAlertSettings: { enabled: true, profitTarget: true, lossLimit: true, lateStage: true, deltaSaturation: true, lowRewardToRisk: true },
                privacyMode: 'off',

                // Reconciliation state
                reconciliation: null,

                // Sorting state
                sortColumn: 'underlying',
                sortDirection: 'asc',

                // Computed properties
                get currentAccountBalance() {
                    if (!this.selectedAccount || this.selectedAccount === '') {
                        const values = Object.values(this.accountBalances);
                        if (values.length === 0) return null;
                        return values.reduce((acc, balance) => ({
                            cash_balance: (acc.cash_balance || 0) + (balance.cash_balance || 0),
                            derivative_buying_power: (acc.derivative_buying_power || 0) + (balance.derivative_buying_power || 0),
                            equity_buying_power: (acc.equity_buying_power || 0) + (balance.equity_buying_power || 0),
                            net_liquidating_value: (acc.net_liquidating_value || 0) + (balance.net_liquidating_value || 0)
                        }), { cash_balance: 0, derivative_buying_power: 0, equity_buying_power: 0, net_liquidating_value: 0 });
                    }
                    return this.accountBalances[this.selectedAccount] || null;
                },

                get groupedPositions() {
                    try {
                        if (this.isLoading || !this.filteredItems || this.filteredItems.length === 0) return [];

                        // Each chain/share item IS already a group — no grouping logic needed
                        // Just apply sorting
                        this.quoteUpdateCounter; // ensure recompute on quote changes
                        const self = this;

                        const sorted = [...this.filteredItems].sort((a, b) => {
                            let aVal, bVal;

                            switch (self.sortColumn) {
                                case 'underlying':
                                    aVal = a.underlying.toLowerCase();
                                    bVal = b.underlying.toLowerCase();
                                    break;
                                case 'ivr':
                                    aVal = self.getUnderlyingIVR(a.underlying) ?? -1;
                                    bVal = self.getUnderlyingIVR(b.underlying) ?? -1;
                                    break;
                                case 'price':
                                    const aQuote = self.underlyingQuotes[a.underlying];
                                    const bQuote = self.underlyingQuotes[b.underlying];
                                    aVal = aQuote?.price || 0;
                                    bVal = bQuote?.price || 0;
                                    break;
                                case 'cost_basis':
                                    aVal = self.getGroupCostBasis(a);
                                    bVal = self.getGroupCostBasis(b);
                                    break;
                                case 'net_liq':
                                    aVal = self.getGroupNetLiqWithLiveQuotes(a);
                                    bVal = self.getGroupNetLiqWithLiveQuotes(b);
                                    break;
                                case 'pnl':
                                case 'total_pnl':
                                    aVal = self.getGroupTotalPnL(a);
                                    bVal = self.getGroupTotalPnL(b);
                                    break;
                                case 'realized_pnl':
                                    aVal = a.realized_pnl || 0;
                                    bVal = b.realized_pnl || 0;
                                    break;
                                case 'open_pnl':
                                    aVal = self.getGroupOpenPnL(a);
                                    bVal = self.getGroupOpenPnL(b);
                                    break;
                                case 'pnl_percent':
                                    aVal = parseFloat(self.getGroupPnLPercent(a)) || 0;
                                    bVal = parseFloat(self.getGroupPnLPercent(b)) || 0;
                                    break;
                                case 'max_percent':
                                    const aMax = self.getGroupMaxPercent(a);
                                    const bMax = self.getGroupMaxPercent(b);
                                    aVal = !aMax ? -1 : parseFloat(aMax) || 0;
                                    bVal = !bMax ? -1 : parseFloat(bMax) || 0;
                                    break;
                                case 'days':
                                    aVal = self.getGroupDaysOpen(a) || 0;
                                    bVal = self.getGroupDaysOpen(b) || 0;
                                    break;
                                case 'dte':
                                    aVal = self.getMinDTE(a) ?? 9999;
                                    bVal = self.getMinDTE(b) ?? 9999;
                                    break;
                                case 'strategy':
                                    aVal = self.getGroupStrategyLabel(a).toLowerCase();
                                    bVal = self.getGroupStrategyLabel(b).toLowerCase();
                                    break;
                                default:
                                    aVal = a.underlying.toLowerCase();
                                    bVal = b.underlying.toLowerCase();
                            }

                            if (aVal < bVal) return self.sortDirection === 'asc' ? -1 : 1;
                            if (aVal > bVal) return self.sortDirection === 'asc' ? 1 : -1;
                            return 0;
                        });

                        // Attach roll analysis to each group for reactive badge display
                        sorted.forEach(group => {
                            group.rollAnalysis = this.getRollAnalysis(group);
                        });

                        // Phase 3: Insert subtotal rows when sorted by underlying
                        if (this.sortColumn === 'underlying') {
                            return this._insertSubtotals(sorted);
                        }
                        return sorted;
                    } catch (error) {
                        console.error('Error in groupedPositions:', error);
                        return [];
                    }
                },

                get underlyings() {
                    return [...new Set(this.filteredItems.map(item => item.underlying).filter(s => s && s !== 'Unknown'))];
                },

                // Initialize
                async init() {
                    await this.loadComments();
                    this.loadRollAlertSettings();
                    this.privacyMode = localStorage.getItem('privacyMode') || 'off';
                    await this.fetchAccounts();
                    await this.loadStrategyTargets();
                    this.loadFilterPreferences();
                    await this.loadAccountBalances();
                    await this.fetchPositions();
                    await this.loadCachedQuotes();
                    this.initializeWebSocket();
                },

                async fetchAccounts() {
                    try {
                        const response = await fetch('/api/accounts');
                        const data = await response.json();
                        this.accounts = data.accounts || [];
                        this.accounts.sort((a, b) => {
                            const getOrder = (name) => {
                                const n = (name || '').toUpperCase();
                                if (n.includes('ROTH')) return 1;
                                if (n.includes('INDIVIDUAL')) return 2;
                                if (n.includes('TRADITIONAL')) return 3;
                                return 4;
                            };
                            return getOrder(a.account_name) - getOrder(b.account_name);
                        });
                    } catch (error) { console.error('Failed to load accounts:', error); }
                },

                async fetchPositions(includeSync = false) {
                    this.isLoading = true;
                    this.error = null;
                    try {
                        if (includeSync) {
                            const syncResp = await fetch('/api/sync', { method: 'POST' });
                            if (syncResp.ok) {
                                const syncData = await syncResp.json();
                                if (syncData.reconciliation) {
                                    this.reconciliation = syncData.reconciliation;
                                }
                            }
                        }

                        // Fetch from chain-based endpoint
                        const response = await fetch('/api/open-chains');
                        const data = await response.json();

                        this.allChains = [];
                        this.allItems = [];

                        if (typeof data === 'object' && !Array.isArray(data)) {
                            Object.entries(data).forEach(([accountNumber, accountData]) => {
                                const chains = accountData.chains || [];

                                chains.forEach(chain => {
                                    chain.account_number = accountNumber;
                                    this.allChains.push(chain);

                                    this.allItems.push({
                                        ...chain,
                                        groupKey: `${accountNumber}|${chain.chain_id}`,
                                        displayKey: chain.underlying,
                                        accountNumber: accountNumber,
                                        positions: chain.open_legs || [],
                                        equityLegs: chain.equity_legs || [],
                                        equitySummary: chain.equity_summary || null,
                                    });
                                });
                            });
                        }
                        // Migrate comment keys from chain_ to group_ prefix
                        this._migrateCommentKeys();

                        this.applyFilters();
                    } catch (error) {
                        console.error('Failed to load positions:', error);
                        this.error = 'Failed to load positions';
                    } finally {
                        this.isLoading = false;
                    }
                },

                async loadAccountBalances() {
                    try {
                        const response = await fetch('/api/account-balances');
                        const data = await response.json();
                        const balances = data.balances || data;
                        this.accountBalances = {};
                        if (Array.isArray(balances)) {
                            balances.forEach(balance => { this.accountBalances[balance.account_number] = balance; });
                        }
                    } catch (error) { console.error('Failed to load account balances:', error); }
                },

                async loadCachedQuotes() {
                    try {
                        const symbols = this._collectSymbols();
                        if (symbols.length === 0) return;

                        const response = await fetch(`/api/quotes?symbols=${encodeURIComponent(symbols.join(','))}`);
                        if (response.ok) {
                            const quotes = await response.json();
                            for (const [symbol, quoteData] of Object.entries(quotes)) {
                                if (quoteData && typeof quoteData === 'object') {
                                    this.underlyingQuotes[symbol] = {
                                        ...this.underlyingQuotes[symbol],
                                        ...quoteData
                                    };
                                }
                            }
                            this.lastQuoteUpdate = new Date().toLocaleTimeString();
                            this.quoteUpdateCounter++;
                        }
                    } catch (error) { console.error('Error loading cached quotes:', error); }
                },

                _collectSymbols() {
                    const symbolSet = new Set();
                    this.filteredItems.forEach(item => {
                        // Add underlying
                        if (item.underlying) symbolSet.add(item.underlying);
                        // Add option leg symbols
                        (item.positions || []).forEach(leg => {
                            if (leg.symbol) symbolSet.add(leg.symbol);
                        });
                    });
                    return Array.from(symbolSet).filter(s => s && s !== 'Unknown');
                },

                initializeWebSocket() {
                    try {
                        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                        const wsUrl = protocol + '//' + location.host + '/ws/quotes';
                        this.ws = new WebSocket(wsUrl);

                        this.ws.onopen = () => {
                            this.liveQuotesActive = true;
                            this.requestLiveQuotes();
                        };

                        this.ws.onmessage = (event) => {
                            const message = JSON.parse(event.data);
                            if (message.type === 'quotes' && message.data) {
                                let quotesUpdated = false;
                                for (const [symbol, quoteData] of Object.entries(message.data)) {
                                    if (quoteData && typeof quoteData === 'object') {
                                        this.underlyingQuotes[symbol] = {
                                            ...this.underlyingQuotes[symbol],
                                            ...quoteData
                                        };
                                        quotesUpdated = true;
                                    }
                                }
                                if (quotesUpdated) {
                                    this.underlyingQuotes = { ...this.underlyingQuotes };
                                }
                                this.quoteUpdateCounter++;
                                this.lastQuoteUpdate = new Date().toLocaleTimeString();
                            }
                        };

                        this.ws.onclose = () => {
                            this.liveQuotesActive = false;
                            setTimeout(() => this.initializeWebSocket(), 5000);
                        };
                    } catch (error) { console.error('WebSocket error:', error); }
                },

                requestLiveQuotes() {
                    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                    const symbols = this._collectSymbols();
                    if (symbols.length > 0) {
                        this.ws.send(JSON.stringify({ subscribe: symbols }));
                    }
                },

                applyFilters() {
                    this.filteredItems = this.allItems.filter(item => {
                        if (this.selectedAccount && item.accountNumber !== this.selectedAccount) return false;
                        if (this.selectedUnderlying) {
                            if (item.underlying !== this.selectedUnderlying) return false;
                        }
                        return true;
                    });

                    if (this.selectedAccount && this.filteredItems.length === 0 && this.allItems.length > 0) {
                        this.selectedAccount = '';
                        this.filteredItems = this.allItems.filter(item => {
                            if (this.selectedUnderlying) {
                                if (item.underlying !== this.selectedUnderlying) return false;
                            }
                            return true;
                        });
                    }
                },

                filterPositions() { this.applyFilters(); },

                saveFilterPreferences() {
                    localStorage.setItem('trade_journal_selected_account', this.selectedAccount || '');
                    localStorage.setItem('trade_journal_selected_underlying', this.selectedUnderlying || '');
                },

                loadFilterPreferences() {
                    const savedAccount = localStorage.getItem('trade_journal_selected_account');
                    if (savedAccount !== null) this.selectedAccount = savedAccount;

                    const savedUnderlying = localStorage.getItem('trade_journal_selected_underlying');
                    if (savedUnderlying) this.selectedUnderlying = savedUnderlying;

                    const savedSort = localStorage.getItem('positions_sort');
                    if (savedSort) {
                        try {
                            const parsed = JSON.parse(savedSort);
                            this.sortColumn = parsed.column || 'underlying';
                            this.sortDirection = parsed.direction || 'asc';
                        } catch (e) { /* Default sort */ }
                    }
                },

                async onAccountChange() {
                    this.applyFilters();
                    this.saveFilterPreferences();
                    await this.loadCachedQuotes();
                    this.requestLiveQuotes();
                },

                // Utility methods
                // Format dollar amounts: drop decimals for large numbers to prevent overflow
                formatDollar(value) {
                    const abs = Math.abs(value || 0);
                    return formatNumber(abs, abs >= 100000 ? 0 : 2);
                },
                // Return smaller font class for very large dollar amounts
                dollarSizeClass(value) {
                    return Math.abs(value || 0) >= 1000000 ? 'text-xs' : '';
                },

                // ===== P&L CALCULATIONS =====
                // Group = a chain item or share item from allItems

                getGroupCostBasis(group) {
                    if (group._isSubtotal) return group._subtotalCostBasis;
                    const optionTotal = (group.positions || []).reduce((s, l) => s + (l.cost_basis || 0), 0);
                    const equityTotal = (group.equityLegs || []).reduce((s, l) => s + (l.cost_basis || 0), 0);
                    return optionTotal + equityTotal;
                },

                // Open P/L: unrealized P&L on current legs (net_liq - cost_basis)
                getGroupOpenPnL(group) {
                    this.quoteUpdateCounter;
                    if (group._isSubtotal) return group._subtotalOpenPnL;
                    const optionPnL = (group.positions || []).reduce((sum, leg) => sum + this._calculateLegPnL(leg), 0);
                    const eqLegs = group.equityLegs || [];
                    if (eqLegs.length === 0) return optionPnL;
                    const eqCost = eqLegs.reduce((s, l) => s + (l.cost_basis || 0), 0);
                    const eqMV = this._calculateEquityMarketValue(group);
                    return optionPnL + eqMV + eqCost;
                },

                // Realized P/L: banked P&L from rolls/partial closes
                getGroupRealizedPnL(group) {
                    if (group._isSubtotal) return group._subtotalRealizedPnL;
                    return group.realized_pnl || 0;
                },

                // Total P/L = Realized + Open
                getGroupTotalPnL(group) {
                    if (group._isSubtotal) return group._subtotalTotalPnL;
                    return this.getGroupRealizedPnL(group) + this.getGroupOpenPnL(group);
                },

                getGroupNetLiqWithLiveQuotes(group) {
                    this.quoteUpdateCounter;
                    if (group._isSubtotal) return group._subtotalNetLiq;
                    const optionMV = (group.positions || []).reduce((sum, leg) => sum + this._calculateLegMarketValue(leg), 0);
                    const equityMV = this._calculateEquityMarketValue(group);
                    return optionMV + equityMV;
                },

                getGroupPnLPercent(group) {
                    const costBasis = this.getGroupCostBasis(group);
                    const openPnL = this.getGroupOpenPnL(group);
                    if (costBasis === 0) return null;
                    return ((openPnL / Math.abs(costBasis)) * 100).toFixed(1);
                },

                getGroupMaxPercent(group) {
                    if (this._isEquityOnly(group) || group._isSubtotal) return '';
                    const legs = group.positions || [];
                    const totalCostBasis = legs.reduce((sum, leg) => sum + (leg.cost_basis || 0), 0);
                    if (totalCostBasis === 0) return '';

                    const optionLegs = legs.filter(l => l.instrument_type && l.instrument_type.includes('OPTION'));
                    const strikes = optionLegs.map(l => l.strike).filter(s => s !== null && s > 0).sort((a, b) => a - b);
                    if (strikes.length < 2) return '';

                    const spreadWidth = strikes[strikes.length - 1] - strikes[0];
                    const numContracts = Math.abs(legs[0].quantity || 0);
                    const isCreditSpread = totalCostBasis > 0;

                    let maxProfit;
                    if (isCreditSpread) {
                        maxProfit = Math.abs(totalCostBasis);
                    } else {
                        maxProfit = (spreadWidth * 100 * numContracts) - Math.abs(totalCostBasis);
                    }
                    if (maxProfit <= 0) return '';

                    const currentPnL = this.getGroupOpenPnL(group);
                    if (!isCreditSpread && currentPnL <= 0) return '';

                    return ((currentPnL / maxProfit) * 100).toFixed(1) + '%';
                },

                shouldShowMaxPercent(group) {
                    if (this._hasEquity(group) || group._isSubtotal) return false;
                    const optionLegs = (group.positions || []).filter(l => l.instrument_type && l.instrument_type.includes('OPTION'));
                    return optionLegs.length === 2;
                },

                getMaxPercentColor(value) {
                    if (typeof value !== 'string' || !value) return 'text-tv-muted';
                    const numVal = parseFloat(value);
                    if (numVal >= 50) return 'text-yellow-400 font-bold';
                    if (numVal >= 30) return 'text-tv-text';
                    return 'text-tv-muted';
                },

                getGroupDaysOpen(group) {
                    if (group._isSubtotal) return null;
                    const openDate = group.opening_date;
                    if (!openDate) return null;
                    const d = new Date(openDate + 'T00:00:00');
                    const now = new Date();
                    const days = Math.floor((now - d) / (1000 * 60 * 60 * 24));
                    return days > 0 ? days : 0;
                },

                getMinDTE(group) {
                    if (group._isSubtotal) return null;
                    const legs = group.positions || [];
                    let minDTE = null;
                    for (const leg of legs) {
                        if (leg.expiration) {
                            const dateStr = leg.expiration.substring(0, 10);
                            const expDate = new Date(dateStr + 'T00:00:00');
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const dte = Math.ceil((expDate - today) / (1000 * 60 * 60 * 24));
                            if (minDTE === null || dte < minDTE) minDTE = dte;
                        }
                    }
                    return minDTE;
                },

                // ===== Live P&L for individual legs =====
                _calculateLegMarketValue(leg) {
                    this.quoteUpdateCounter;
                    const optionSymbol = (leg.symbol || '').trim();
                    const optionQuote = this.underlyingQuotes[optionSymbol];
                    if (optionQuote && optionQuote.mark !== undefined) {
                        const absValue = optionQuote.mark * leg.quantity * 100;
                        return leg.quantity_direction === 'Short' ? -absValue : absValue;
                    }
                    // Fallback: use opening price
                    const absValue = (leg.opening_price || 0) * leg.quantity * 100;
                    return leg.quantity_direction === 'Short' ? -absValue : absValue;
                },

                _calculateLegPnL(leg) {
                    const marketValue = this._calculateLegMarketValue(leg);
                    const costBasis = leg.cost_basis || 0;
                    const absMV = Math.abs(marketValue);
                    const absCB = Math.abs(costBasis);
                    if (leg.quantity_direction === 'Short') {
                        return absCB - absMV;
                    } else {
                        return absMV - absCB;
                    }
                },

                _hasEquity(group) {
                    return (group.equityLegs || []).length > 0;
                },
                _isEquityOnly(group) {
                    return this._hasEquity(group) && (group.positions || []).length === 0;
                },
                _calculateEquityMarketValue(group) {
                    const eqLegs = group.equityLegs || [];
                    if (eqLegs.length === 0) return 0;
                    const quote = this.underlyingQuotes[group.underlying];
                    if (!quote || !quote.price) return 0;
                    let total = 0;
                    eqLegs.forEach(leg => {
                        const signed = leg.quantity_direction === 'Short' ? -leg.quantity : leg.quantity;
                        total += quote.price * signed;
                    });
                    return total;
                },

                // ===== Sort =====
                sortPositions(column) {
                    if (this.sortColumn === column) {
                        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortColumn = column;
                        if (['pnl', 'total_pnl', 'realized_pnl', 'open_pnl', 'pnl_percent', 'net_liq', 'price', 'ivr', 'max_percent'].includes(column)) {
                            this.sortDirection = 'desc';
                        } else {
                            this.sortDirection = 'asc';
                        }
                    }
                    localStorage.setItem('positions_sort', JSON.stringify({
                        column: this.sortColumn,
                        direction: this.sortDirection
                    }));
                },

                getGroupStrategyLabel(group) {
                    if (group._isSubtotal) return '';
                    if (group.strategy_type && group.strategy_type !== 'Unknown') return group.strategy_type;
                    return 'Unknown';
                },

                getOptionStratUrl(group) {
                    if (!group.strategy_type || !group.underlying) return null;
                    const optionLegs = (group.positions || []).filter(l =>
                        l.instrument_type && l.instrument_type.includes('OPTION'));
                    if (optionLegs.length !== 2) return null;
                    const legs = optionLegs.map(l => ({
                        expiration: l.expiration,
                        option_type: l.option_type,
                        strike: l.strike,
                        isShort: l.quantity_direction === 'Short',
                    }));
                    return buildOptionStratUrl(group.strategy_type, group.underlying, legs);
                },

                // ===== Leg display helpers =====
                getOptionType(leg) {
                    if (leg.option_type === 'Call' || leg.option_type === 'C') return 'C';
                    if (leg.option_type === 'Put' || leg.option_type === 'P') return 'P';
                    if (leg.option_type) return leg.option_type.charAt(0).toUpperCase();
                    const match = (leg.symbol || '').match(/\d{6}([CP])/);
                    if (match) return match[1];
                    return '—';
                },
                getSignedQuantity(leg) {
                    const qty = leg.quantity || 0;
                    if (leg.quantity_direction === 'Short') return -qty;
                    return qty;
                },
                getExpirationDate(leg) {
                    if (!leg.expiration) return '';
                    const dateStr = leg.expiration.substring(0, 10);
                    const date = new Date(dateStr + 'T00:00:00');
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                },
                getStrikePrice(leg) {
                    if (leg.strike && leg.strike > 0) return parseFloat(leg.strike.toFixed(2)).toString();
                    const symbol = leg.symbol || '';
                    const match = symbol.match(/([CP])(\d+)/);
                    if (match && match[2].length >= 3) {
                        return parseFloat(parseFloat(match[2].slice(0, -3) + '.' + match[2].slice(-3)).toFixed(2)).toString();
                    }
                    return '';
                },
                getDTE(leg) {
                    if (!leg.expiration) return null;
                    const dateStr = leg.expiration.substring(0, 10);
                    const expDate = new Date(dateStr + 'T00:00:00');
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const dte = Math.ceil((expDate - today) / (1000 * 60 * 60 * 24));
                    return dte > 0 ? dte : 0;
                },

                getUnderlyingQuote(underlying) {
                    return this.underlyingQuotes[underlying] || null;
                },
                getUnderlyingIVR(underlying) {
                    const quote = this.getUnderlyingQuote(underlying);
                    if (!quote || !quote.ivr) return null;
                    return Math.round(quote.ivr * 100);
                },

                // ===== Phase 3: Subtotals =====
                _insertSubtotals(sorted) {
                    // Group items by underlying+account, insert subtotal rows for multi-item groups
                    const result = [];
                    let currentKey = null;
                    let currentGroup = [];

                    const flushGroup = () => {
                        if (currentGroup.length <= 1) {
                            result.push(...currentGroup);
                            return;
                        }
                        // Build subtotal row
                        const underlying = currentGroup[0].underlying;
                        const acct = currentGroup[0].accountNumber;
                        const subtotal = {
                            _isSubtotal: true,
                            groupKey: `subtotal_${acct}_${underlying}`,
                            displayKey: underlying,
                            underlying: underlying,
                            accountNumber: acct,
                            _subtotalCostBasis: 0,
                            _subtotalNetLiq: 0,
                            _subtotalOpenPnL: 0,
                            _subtotalRealizedPnL: 0,
                            _subtotalTotalPnL: 0,
                            _childCount: currentGroup.length,
                        };
                        currentGroup.forEach(item => {
                            subtotal._subtotalCostBasis += this.getGroupCostBasis(item);
                            subtotal._subtotalNetLiq += this.getGroupNetLiqWithLiveQuotes(item);
                            subtotal._subtotalOpenPnL += this.getGroupOpenPnL(item);
                            subtotal._subtotalRealizedPnL += this.getGroupRealizedPnL(item);
                            subtotal._subtotalTotalPnL += this.getGroupTotalPnL(item);
                        });
                        result.push(subtotal);
                        result.push(...currentGroup);
                    };

                    for (const item of sorted) {
                        const key = `${item.accountNumber}|${item.underlying}`;
                        if (key !== currentKey) {
                            if (currentGroup.length > 0) flushGroup();
                            currentKey = key;
                            currentGroup = [item];
                        } else {
                            currentGroup.push(item);
                        }
                    }
                    if (currentGroup.length > 0) flushGroup();
                    return result;
                },

                // ===== Roll Analysis (works on option legs) =====
                getRollAnalysis(group) {
                    const strategy = this.getGroupStrategyLabel(group);
                    const supportedStrategies = ['Bull Call Spread', 'Bear Put Spread', 'Bull Put Spread', 'Bear Call Spread'];
                    if (!supportedStrategies.includes(strategy)) return null;
                    if (!this.rollAlertSettings.enabled) return null;

                    const positions = group.positions || [];
                    const underlying = group.underlying;
                    const quote = this.underlyingQuotes[underlying];
                    if (!quote || !quote.price) return null;
                    const underlyingPrice = quote.price;

                    const getStrike = (p) => {
                        if (p.strike && p.strike > 0) return p.strike;
                        const match = (p.symbol || '').match(/([CP])(\d+)/);
                        if (match && match[2].length >= 3) return parseFloat(match[2].slice(0, -3) + '.' + match[2].slice(-3));
                        return null;
                    };
                    const isShort = (p) => p.quantity_direction === 'Short' || (p.quantity || 0) < 0;
                    const getOptionType = (p) => {
                        if (p.option_type === 'Call') return 'C';
                        if (p.option_type === 'Put') return 'P';
                        const match = (p.symbol || '').match(/\d{6}([CP])/);
                        return match ? match[1] : null;
                    };

                    const optionPositions = positions.filter(p => p.instrument_type && p.instrument_type.includes('OPTION'));
                    if (optionPositions.length < 2) return null;

                    let longLeg = null, shortLeg = null;
                    for (const p of optionPositions) {
                        if (isShort(p)) shortLeg = p;
                        else longLeg = p;
                    }
                    if (!longLeg || !shortLeg) return null;

                    const longStrike = getStrike(longLeg);
                    const shortStrike = getStrike(shortLeg);
                    if (!longStrike || !shortStrike) return null;

                    const spreadWidth = Math.abs(shortStrike - longStrike);
                    const numContracts = Math.abs(longLeg.quantity || 0);
                    const totalCostBasis = Math.abs(positions.reduce((sum, p) => sum + (p.cost_basis || 0), 0));

                    const isBullCall = strategy === 'Bull Call Spread';
                    const isBullPut = strategy === 'Bull Put Spread';
                    const isBearCall = strategy === 'Bear Call Spread';
                    const isCredit = isBullPut || isBearCall;

                    let maxProfit, maxLoss;
                    if (isCredit) {
                        maxProfit = totalCostBasis;
                        maxLoss = (spreadWidth * 100 * numContracts) - totalCostBasis;
                    } else {
                        maxProfit = (spreadWidth * 100 * numContracts) - totalCostBasis;
                        maxLoss = totalCostBasis;
                    }

                    if (maxProfit <= 0 || maxLoss <= 0) return null;

                    const currentPnL = this.getGroupOpenPnL(group);
                    const pctMaxProfit = ((currentPnL / maxProfit) * 100).toFixed(1);
                    const pctMaxLoss = currentPnL < 0 ? ((Math.abs(currentPnL) / maxLoss) * 100).toFixed(1) : '0.0';

                    const rewardRemaining = maxProfit - currentPnL;
                    const riskRemaining = maxLoss + currentPnL;
                    const rewardToRiskRaw = riskRemaining > 0 ? rewardRemaining / riskRemaining : 99;
                    const rewardToRisk = rewardToRiskRaw >= 10 ? '10+' : rewardToRiskRaw.toFixed(2);

                    const dte = this.getMinDTE(group) || 0;

                    // Delta saturation
                    let deltaSaturation = '0.0';
                    const iv = this._getEffectiveIV(underlying);
                    if (iv > 0 && dte > 0) {
                        const T = dte / 365;
                        const shortDelta = Math.abs(this._bsDelta(underlyingPrice, shortStrike, T, 0.04, iv, getOptionType(shortLeg) === 'C'));
                        deltaSaturation = (shortDelta * 100).toFixed(1);
                    }

                    // Proximity to short strike
                    const proximityToShort = ((Math.abs(underlyingPrice - shortStrike) / underlyingPrice) * 100).toFixed(1);

                    // Badges
                    const badges = [];
                    const targets = this.strategyTargets[strategy] || {};
                    const profitTarget = targets.profit_target_pct || 50;
                    const lossLimit = targets.loss_target_pct || 100;

                    if (this.rollAlertSettings.profitTarget && parseFloat(pctMaxProfit) >= profitTarget) {
                        badges.push({ label: 'Profit Target', color: 'green' });
                    }
                    if (this.rollAlertSettings.lossLimit) {
                        // Credit spreads: loss as % of credit received (|pctMaxProfit|)
                        // Debit spreads: loss as % of debit paid (pctMaxLoss)
                        const lossMetric = isCredit ? Math.abs(parseFloat(pctMaxProfit)) : parseFloat(pctMaxLoss);
                        if (currentPnL < 0 && lossMetric >= lossLimit) {
                            badges.push({ label: 'Loss Limit', color: 'red' });
                        }
                    }
                    if (this.rollAlertSettings.lateStage && dte <= 21 && dte > 0) {
                        badges.push({ label: `${dte}d Left`, color: 'yellow' });
                    }
                    if (this.rollAlertSettings.lowRewardToRisk && rewardToRiskRaw < (isCredit ? 0.3 : 0.6)) {
                        badges.push({ label: `R:R ${rewardToRisk}`, color: 'orange' });
                    }

                    let convexity;
                    if (isCredit) {
                        const lossRatio = parseFloat(pctMaxLoss);
                        if (lossRatio < 50) convexity = 'Low Risk';
                        else if (lossRatio < 100) convexity = 'Elevated Risk';
                        else convexity = 'High Risk';
                    } else {
                        if (rewardToRiskRaw > 2) convexity = 'High';
                        else if (rewardToRiskRaw > 0.8) convexity = 'Diminishing';
                        else convexity = 'Low';
                    }

                    let borderColor = 'blue';
                    if (badges.some(b => b.color === 'red')) borderColor = 'red';
                    else if (badges.some(b => b.color === 'yellow' || b.color === 'orange')) borderColor = 'yellow';
                    else if (badges.some(b => b.color === 'green')) borderColor = 'green';

                    let suggestion = null;
                    let urgency = 'low';
                    if (parseFloat(pctMaxProfit) >= profitTarget) {
                        suggestion = `Consider closing: ${pctMaxProfit}% of max profit captured.`;
                        urgency = 'medium';
                    }
                    const suggestionLossMetric = isCredit ? Math.abs(parseFloat(pctMaxProfit)) : parseFloat(pctMaxLoss);
                    if (currentPnL < 0 && suggestionLossMetric >= lossLimit) {
                        const lossDesc = isCredit ? 'of credit received' : 'of debit paid';
                        suggestion = `Loss limit hit: ${suggestionLossMetric.toFixed(1)}% ${lossDesc}. Consider closing or rolling.`;
                        urgency = 'high';
                    }

                    return {
                        pctMaxProfit, pctMaxLoss, rewardToRisk, rewardToRiskRaw,
                        deltaSaturation, proximityToShort, convexity, isCredit,
                        maxProfit: formatNumber(maxProfit, 0),
                        maxLoss: formatNumber(maxLoss, 0),
                        badges, borderColor, suggestion, urgency
                    };
                },

                _bsDelta(S, K, T, r, sigma, isCall) {
                    if (T <= 0 || sigma <= 0) return isCall ? (S > K ? 1 : 0) : (S < K ? -1 : 0);
                    const d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                    return isCall ? this._normalCDF(d1) : this._normalCDF(d1) - 1;
                },
                _normalCDF(x) {
                    const t = 1 / (1 + 0.2316419 * Math.abs(x));
                    const d = 0.3989422804014327;
                    const p = d * Math.exp(-x * x / 2) * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
                    return x > 0 ? 1 - p : p;
                },
                _getEffectiveIV(underlying) {
                    const quote = this.underlyingQuotes[underlying];
                    if (quote && quote.iv && quote.iv > 0) return quote.iv / 100;
                    return 0.30;
                },

                // ===== Strategy Targets =====
                async loadStrategyTargets() {
                    try {
                        const response = await fetch('/api/settings/targets');
                        if (response.ok) {
                            const data = await response.json();
                            // API returns a list of {strategy_name, profit_target_pct, loss_target_pct}
                            const list = Array.isArray(data) ? data : (data.targets || []);
                            const mapped = {};
                            list.forEach(t => { if (t.strategy_name) mapped[t.strategy_name] = t; });
                            this.strategyTargets = mapped;
                        }
                    } catch (error) { console.error('Failed to load strategy targets:', error); }
                },
                loadRollAlertSettings() {
                    try {
                        const saved = localStorage.getItem('rollAlertSettings');
                        if (saved) this.rollAlertSettings = { ...this.rollAlertSettings, ...JSON.parse(saved) };
                    } catch (e) { /* use defaults */ }
                },

                // ===== Notes (DB-persisted) =====
                async loadComments() {
                    try {
                        const response = await fetch('/api/position-notes');
                        if (response.ok) {
                            const data = await response.json();
                            this.positionComments = data.notes || {};
                        } else {
                            this.positionComments = {};
                        }
                    } catch (error) {
                        console.error('Error loading position notes:', error);
                        this.positionComments = {};
                    }
                    // One-time migration from localStorage
                    try {
                        const stored = localStorage.getItem('positionComments');
                        if (stored) {
                            const local = JSON.parse(stored);
                            let migrated = false;
                            for (const [key, value] of Object.entries(local)) {
                                if (value && !this.positionComments[key]) {
                                    this.positionComments[key] = value;
                                    fetch(`/api/position-notes/${encodeURIComponent(key)}`, {
                                        method: 'PUT',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ note: value })
                                    }).catch(err => console.error('Migration save error:', err));
                                    migrated = true;
                                }
                            }
                            localStorage.removeItem('positionComments');
                            if (migrated) console.log('Migrated position notes from localStorage to DB');
                        }
                    } catch (e) { /* ignore migration errors */ }
                },
                _migrateCommentKeys() {
                    // Migrate notes from old chain_{source_chain_id} keys to new group_{group_id} keys
                    try {
                        for (const item of this.allItems) {
                            if (item._isSubtotal) continue;
                            const groupId = item.group_id || item.chain_id;
                            const sourceChainId = item.source_chain_id;
                            if (!groupId || !sourceChainId || groupId === sourceChainId) continue;

                            const newKey = `group_${groupId}`;
                            const oldKey = `chain_${sourceChainId}`;

                            // If note exists under old key but not new key, migrate it
                            if (this.positionComments[oldKey] && !this.positionComments[newKey]) {
                                this.positionComments[newKey] = this.positionComments[oldKey];
                                fetch(`/api/position-notes/${encodeURIComponent(newKey)}`, {
                                    method: 'PUT',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ note: this.positionComments[oldKey] })
                                }).catch(err => console.error('Comment key migration error:', err));
                            }

                            // Also check the old chain_{chain_id} key (chain_id === group_id now)
                            const oldChainKey = `chain_${groupId}`;
                            if (this.positionComments[oldChainKey] && !this.positionComments[newKey]) {
                                this.positionComments[newKey] = this.positionComments[oldChainKey];
                                fetch(`/api/position-notes/${encodeURIComponent(newKey)}`, {
                                    method: 'PUT',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ note: this.positionComments[oldChainKey] })
                                }).catch(err => console.error('Comment key migration error:', err));
                            }
                        }
                    } catch (e) { /* ignore migration errors */ }
                },
                getCommentKey(group) {
                    if (group._isSubtotal) return null;
                    const groupId = group.group_id || group.chain_id || group.chainId;
                    if (groupId) return `group_${groupId}`;
                    return `pos_${group.underlying}_${group.accountNumber || 'default'}`;
                },
                getPositionComment(group) {
                    const key = this.getCommentKey(group);
                    if (!key) return '';
                    return this.positionComments[key] || '';
                },
                updatePositionComment(group, value) {
                    const key = this.getCommentKey(group);
                    if (!key) return;
                    this.positionComments[key] = value;
                    if (this._noteSaveTimers[key]) {
                        clearTimeout(this._noteSaveTimers[key]);
                    }
                    this._noteSaveTimers[key] = setTimeout(() => {
                        fetch(`/api/position-notes/${encodeURIComponent(key)}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ note: value })
                        }).catch(err => console.error('Error saving position note:', err));
                        delete this._noteSaveTimers[key];
                    }, 500);
                },

                // Get single-letter account symbol (R=Roth, I=Individual, T=Traditional)
                getAccountSymbol(accountNumber) {
                    const account = this.accounts.find(a => a.account_number === accountNumber);
                    if (!account) return '?';
                    const name = (account.account_name || '').toUpperCase();
                    if (name.includes('ROTH')) return 'R';
                    if (name.includes('INDIVIDUAL')) return 'I';
                    if (name.includes('TRADITIONAL')) return 'T';
                    return name.charAt(0) || '?';
                }
            };
        }
    </script>
</head>
<body class="min-h-screen tv-scrollbar" x-data="positionsApp()" x-init="init()">

    {% include 'partials/nav.html' %}

    <!-- Action Bar -->
    <div class="bg-tv-panel border-b border-tv-border px-4 py-3 flex items-center justify-between">
        <div class="flex items-center gap-4">
            <button @click="fetchPositions(true)"
                    :disabled="isLoading"
                    class="bg-tv-green/20 hover:bg-tv-green/30 text-tv-green border border-tv-green/30 px-4 py-2 text-base disabled:opacity-50">
                <i class="fas fa-sync-alt mr-2" :class="{'animate-spin': isLoading}"></i>
                <span x-text="isLoading ? 'Syncing...' : 'Sync'"></span>
            </button>

            <!-- Symbol Filter -->
            <div class="relative">
                <input type="text"
                       x-model="selectedUnderlying"
                       @focus="$event.target.select()"
                       @keyup.enter="filterPositions(); requestLiveQuotes(); saveFilterPreferences()"
                       @blur="filterPositions(); requestLiveQuotes(); saveFilterPreferences()"
                       @input="selectedUnderlying = selectedUnderlying.toUpperCase()"
                       placeholder="Symbol"
                       class="bg-tv-bg border border-tv-border text-tv-text text-base px-3 py-2 w-28 uppercase placeholder:normal-case placeholder:text-tv-muted"
                       :class="selectedUnderlying ? 'pr-8' : ''">
                <button x-show="selectedUnderlying"
                        @click="selectedUnderlying = ''; filterPositions(); requestLiveQuotes(); saveFilterPreferences()"
                        class="absolute right-2 top-1/2 -translate-y-1/2 text-tv-muted hover:text-tv-text"
                        title="Clear symbol filter">
                    <i class="fas fa-times-circle"></i>
                </button>
            </div>

            <!-- Account Balances -->
            <template x-if="currentAccountBalance">
                <div class="flex items-center gap-6 ml-6 text-base">
                    <div>
                        <span class="text-tv-muted text-sm">Net Liq:</span>
                        <span class="font-medium ml-1" x-text="privacyMode !== 'off' ? '••••••' : '$' + formatNumber(currentAccountBalance.net_liquidating_value)"></span>
                    </div>
                    <div class="flex-grow"></div>
                    <div>
                        <span class="text-tv-muted text-sm">Cash:</span>
                        <span class="font-medium ml-1" x-text="privacyMode === 'high' ? '••••••' : '$' + formatNumber(currentAccountBalance.cash_balance)"></span>
                    </div>
                    <div>
                        <span class="text-tv-muted text-sm">Option BP:</span>
                        <span class="font-medium ml-1" x-text="privacyMode === 'high' ? '••••••' : '$' + formatNumber(currentAccountBalance.derivative_buying_power)"></span>
                    </div>
                    <div>
                        <span class="text-tv-muted text-sm">Stock BP:</span>
                        <span class="font-medium ml-1" x-text="privacyMode === 'high' ? '••••••' : '$' + formatNumber(currentAccountBalance.equity_buying_power)"></span>
                    </div>
                </div>
            </template>

            <span class="text-sm text-tv-muted ml-4" x-show="lastQuoteUpdate">
                Quotes: <span x-text="lastQuoteUpdate"></span>
                <span x-show="liveQuotesActive" class="text-tv-green ml-1">LIVE</span>
            </span>
        </div>
    </div>

    <!-- Loading State -->
    <div x-show="isLoading" class="text-center py-12">
        <i class="fas fa-spinner fa-spin text-4xl text-tv-blue mb-4"></i>
        <p class="text-tv-muted">Loading positions...</p>
    </div>

    <!-- Empty State -->
    <div x-show="!isLoading && !error && filteredItems.length === 0" class="text-center py-12">
        <i class="fas fa-layer-group text-4xl text-tv-muted mb-4"></i>
        <p class="text-tv-muted mb-4">No open positions found</p>
    </div>

    <!-- Reconciliation Banner -->
    <div x-show="reconciliation && !isLoading" x-cloak class="mx-2 mt-2">
        <div class="px-4 py-2 rounded text-sm flex items-center justify-between"
             :class="(reconciliation.unlinked?.length || reconciliation.quantity_mismatch?.length || reconciliation.stale?.length)
                     ? 'bg-yellow-500/10 border border-yellow-500/30 text-yellow-400'
                     : 'bg-tv-green/10 border border-tv-green/30 text-tv-green'">
            <span>
                <i class="fas fa-check-circle mr-1" x-show="!reconciliation.unlinked?.length && !reconciliation.quantity_mismatch?.length && !reconciliation.stale?.length"></i>
                <i class="fas fa-exclamation-triangle mr-1" x-show="reconciliation.unlinked?.length || reconciliation.quantity_mismatch?.length || reconciliation.stale?.length"></i>
                <span x-text="reconciliation.matched + '/' + reconciliation.total + ' options matched'"></span>
                <span x-show="reconciliation.unlinked?.length" class="ml-2" x-text="reconciliation.unlinked.length + ' unlinked'"></span>
                <span x-show="reconciliation.stale?.length" class="ml-2" x-text="reconciliation.stale.length + ' stale'"></span>
                <span x-show="reconciliation.auto_closed?.length" class="ml-2 text-tv-green" x-text="reconciliation.auto_closed.length + ' auto-closed'"></span>
            </span>
            <button @click="reconciliation = null" class="text-tv-muted hover:text-tv-text text-xs ml-4">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <main x-show="!isLoading && !error && filteredItems.length > 0 && allItems.length > 0" x-cloak class="p-2">
        <!-- Column Headers -->
        <div class="flex items-center px-4 py-2 text-sm text-tv-muted border-b border-tv-border bg-tv-panel/50 sticky top-16">
            <span class="w-8"></span>
            <span class="w-6 text-center" x-show="selectedAccount === ''"></span>
            <span class="w-14 cursor-pointer hover:text-tv-text flex items-center gap-1" @click="sortPositions('underlying')">
                Symbol
                <span x-show="sortColumn === 'underlying'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-8 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1 mr-1" @click="sortPositions('ivr')">
                IVR
                <span x-show="sortColumn === 'ivr'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-40 cursor-pointer hover:text-tv-text flex items-center gap-1" @click="sortPositions('price')">
                Price
                <span x-show="sortColumn === 'price'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12"></span>
            <span class="w-36 cursor-pointer hover:text-tv-text flex items-center gap-1" @click="sortPositions('strategy')">
                Strategy
                <span x-show="sortColumn === 'strategy'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12 text-center cursor-pointer hover:text-tv-text flex items-center justify-center gap-1" @click="sortPositions('dte')">
                DTE
                <span x-show="sortColumn === 'dte'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-12 text-center cursor-pointer hover:text-tv-text flex items-center justify-center gap-1" @click="sortPositions('days')">
                Days
                <span x-show="sortColumn === 'days'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('cost_basis')">
                Cost Basis
                <span x-show="sortColumn === 'cost_basis'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('net_liq')">
                Net Liq
                <span x-show="sortColumn === 'net_liq'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('realized_pnl')">
                Realized
                <span x-show="sortColumn === 'realized_pnl'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('open_pnl')">
                Open
                <span x-show="sortColumn === 'open_pnl'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-24 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('total_pnl')">
                Total
                <span x-show="sortColumn === 'total_pnl'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-14 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('pnl_percent')">
                % Rtn
                <span x-show="sortColumn === 'pnl_percent'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
            <span class="w-14 text-right cursor-pointer hover:text-tv-text flex items-center justify-end gap-1" @click="sortPositions('max_percent')">
                % Max
                <span x-show="sortColumn === 'max_percent'" x-text="sortDirection === 'asc' ? '▲' : '▼'" class="text-tv-blue"></span>
            </span>
        </div>

        <!-- Position Groups -->
        <div class="divide-y divide-tv-border">
            <template x-for="(group, index) in groupedPositions" :key="group.groupKey">
                <div>
                    <!-- Subtotal Row -->
                    <template x-if="group._isSubtotal">
                        <div class="flex items-center px-4 py-2 bg-blue-500/10 border-l-2 border-tv-blue">
                            <div class="w-8"></div>
                            <div class="w-6" x-show="selectedAccount === ''"></div>
                            <div class="w-14">
                                <div class="font-bold text-base text-tv-text" x-text="group.displayKey"></div>
                            </div>
                            <div class="w-8 mr-1"></div>
                            <div class="w-40"></div>
                            <div class="w-12"></div>
                            <!-- Strategy -->
                            <div class="w-36 text-xs text-tv-muted" x-text="group._childCount + ' positions'"></div>
                            <!-- DTE -->
                            <div class="w-12"></div>
                            <!-- Days -->
                            <div class="w-12"></div>
                            <!-- Cost Basis -->
                            <div class="w-24 text-right font-medium"
                                 :class="(group._subtotalCostBasis >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(group._subtotalCostBasis)">
                                <span x-show="group._subtotalCostBasis < 0">-</span>$<span x-text="formatDollar(group._subtotalCostBasis)"></span>
                            </div>
                            <!-- Net Liq -->
                            <div class="w-24 text-right font-medium"
                                 :class="(group._subtotalNetLiq >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(group._subtotalNetLiq)">
                                <span x-show="group._subtotalNetLiq < 0">-</span>$<span x-text="formatDollar(group._subtotalNetLiq)"></span>
                            </div>
                            <!-- Realized -->
                            <div class="w-24 text-right font-medium"
                                 :class="(group._subtotalRealizedPnL >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(group._subtotalRealizedPnL)">
                                <span x-show="group._subtotalRealizedPnL !== 0">
                                    <span x-show="group._subtotalRealizedPnL < 0">-</span>$<span x-text="formatDollar(group._subtotalRealizedPnL)"></span>
                                </span>
                            </div>
                            <!-- Open P/L -->
                            <div class="w-24 text-right font-medium"
                                 :class="(group._subtotalOpenPnL >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(group._subtotalOpenPnL)">
                                <span x-show="group._subtotalOpenPnL < 0">-</span>$<span x-text="formatDollar(group._subtotalOpenPnL)"></span>
                            </div>
                            <!-- Total P/L -->
                            <div class="w-24 text-right font-bold"
                                 :class="(group._subtotalTotalPnL >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(group._subtotalTotalPnL)">
                                <span x-show="group._subtotalTotalPnL < 0">-</span>$<span x-text="formatDollar(group._subtotalTotalPnL)"></span>
                            </div>
                            <!-- % Rtn -->
                            <div class="w-14"></div>
                            <!-- % Max -->
                            <div class="w-14"></div>
                        </div>
                    </template>

                    <!-- Regular Row (Chain or Share) -->
                    <template x-if="!group._isSubtotal">
                        <div x-data="{ expanded: false }">
                            <!-- Group Row -->
                            <div class="flex items-center px-4 py-2 hover:bg-tv-border/30 cursor-pointer transition-colors"
                                 @click="expanded = !expanded"
                                <!-- Chevron -->
                                <div class="w-8">
                                    <i class="fas fa-chevron-right text-tv-muted transition-transform duration-200"
                                       :class="{ 'rotate-90': expanded }"></i>
                                </div>

                                <!-- Account Symbol (only when All Accounts selected) -->
                                <div class="w-6 text-center text-tv-muted text-sm" x-show="selectedAccount === ''">
                                    <span x-text="getAccountSymbol(group.accountNumber)"></span>
                                </div>

                                <!-- Symbol -->
                                <div class="w-14">
                                    <div class="font-semibold text-base text-tv-text">
                                        <span x-text="group.displayKey || group.underlying"></span>
                                        <span x-show="_hasEquity(group) && (group.positions || []).length > 0" class="text-[10px] text-tv-muted ml-1 bg-tv-border/50 px-1 rounded">+stk</span>
                                    </div>
                                </div>

                                <!-- IVR -->
                                <div class="w-8 text-right mr-1"
                                     :class="getUnderlyingIVR(group.underlying) >= 50 ? 'font-bold text-yellow-400' : 'text-tv-muted'"
                                     x-text="getUnderlyingIVR(group.underlying) !== null ? getUnderlyingIVR(group.underlying) : ''"></div>

                                <!-- Price -->
                                <div class="w-40 flex items-center gap-2">
                                    <template x-if="getUnderlyingQuote(group.underlying)">
                                        <div class="flex items-center gap-2">
                                            <div class="w-20 px-2 py-1 rounded-sm text-base font-medium border text-right"
                                                 style="font-variant-numeric: tabular-nums"
                                                 :class="(getUnderlyingQuote(group.underlying).change || 0) >= 0 ? 'bg-green-900/60 text-green-400 border-green-700/50' : 'bg-tv-border text-tv-muted border-tv-border'">
                                                <span x-text="formatNumber(getUnderlyingQuote(group.underlying).price || 0)"></span>
                                            </div>
                                            <div class="w-16 text-right text-sm"
                                                 style="font-variant-numeric: tabular-nums"
                                                 :class="(getUnderlyingQuote(group.underlying).change || 0) >= 0 ? 'text-green-400' : 'text-tv-muted'">
                                                <span x-text="((getUnderlyingQuote(group.underlying).change || 0) >= 0 ? '+' : '') + (getUnderlyingQuote(group.underlying).changePercent || 0).toFixed(2) + '%'"></span>
                                            </div>
                                        </div>
                                    </template>
                                    <template x-if="!getUnderlyingQuote(group.underlying)">
                                        <span class="text-tv-muted text-sm"><i class="fas fa-spinner fa-spin"></i></span>
                                    </template>
                                </div>

                                <!-- Ledger Link -->
                                <div class="w-12">
                                    <a :href="'/ledger?underlying=' + encodeURIComponent(group.underlying)"
                                       @click.stop
                                       class="text-tv-blue hover:text-blue-400"
                                       title="View in Ledger">
                                        <i class="fas fa-book"></i>
                                        <span x-show="group.roll_count > 0" class="text-xs text-tv-muted ml-0.5" x-text="'R' + group.roll_count"></span>
                                    </a>
                                </div>

                                <!-- Strategy -->
                                <div class="w-36">
                                    <div class="text-sm text-tv-muted" x-text="getGroupStrategyLabel(group)"></div>
                                    <template x-if="group.rollAnalysis && group.rollAnalysis.badges.length > 0">
                                        <div class="flex flex-wrap gap-1 mt-0.5">
                                            <template x-for="badge in group.rollAnalysis.badges" :key="badge.label">
                                                <span class="text-[10px] px-1.5 py-0 rounded-sm border leading-4"
                                                      :class="{
                                                          'bg-green-500/20 text-green-400 border-green-500/50': badge.color === 'green',
                                                          'bg-red-500/20 text-red-400 border-red-500/50': badge.color === 'red',
                                                          'bg-yellow-500/20 text-yellow-400 border-yellow-500/50': badge.color === 'yellow',
                                                          'bg-orange-500/20 text-orange-400 border-orange-500/50': badge.color === 'orange'
                                                      }"
                                                      x-text="badge.label"></span>
                                            </template>
                                        </div>
                                    </template>
                                </div>

                                <!-- DTE -->
                                <div class="w-12 text-center"
                                     :class="getMinDTE(group) !== null && getMinDTE(group) <= 21 ? 'font-bold text-yellow-400' : 'text-tv-text'"
                                     x-text="getMinDTE(group) !== null ? getMinDTE(group) : ''"></div>

                                <!-- Days -->
                                <div class="w-12 text-center text-tv-text" x-text="getGroupDaysOpen(group) || ''"></div>

                                <!-- Cost Basis -->
                                <div class="w-24 text-right"
                                     :class="(getGroupCostBasis(group) >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(getGroupCostBasis(group))">
                                    <span x-show="getGroupCostBasis(group) < 0">-</span>$<span x-text="formatDollar(getGroupCostBasis(group))"></span>
                                </div>

                                <!-- Net Liq -->
                                <div class="w-24 text-right font-medium"
                                     :class="(getGroupNetLiqWithLiveQuotes(group) >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(getGroupNetLiqWithLiveQuotes(group))">
                                    <span x-show="getGroupNetLiqWithLiveQuotes(group) < 0">-</span>$<span x-text="formatDollar(getGroupNetLiqWithLiveQuotes(group))"></span>
                                </div>

                                <!-- Realized P/L -->
                                <div class="w-24 text-right"
                                     :class="(getGroupRealizedPnL(group) >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(getGroupRealizedPnL(group))">
                                    <template x-if="getGroupRealizedPnL(group) !== 0">
                                        <span>
                                            <span x-show="getGroupRealizedPnL(group) < 0">-</span>$<span x-text="formatDollar(getGroupRealizedPnL(group))"></span>
                                        </span>
                                    </template>
                                    <template x-if="getGroupRealizedPnL(group) === 0">
                                        <span></span>
                                    </template>
                                </div>

                                <!-- Open P/L -->
                                <div class="w-24 text-right font-medium"
                                     :class="(getGroupOpenPnL(group) >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(getGroupOpenPnL(group))">
                                    <span x-show="getGroupOpenPnL(group) < 0">-</span>$<span x-text="formatDollar(getGroupOpenPnL(group))"></span>
                                </div>

                                <!-- Total P/L -->
                                <div class="w-24 text-right font-bold"
                                     :class="(getGroupTotalPnL(group) >= 0 ? 'text-tv-green' : 'text-tv-red') + ' ' + dollarSizeClass(getGroupTotalPnL(group))">
                                    <span x-show="getGroupTotalPnL(group) < 0">-</span>$<span x-text="formatDollar(getGroupTotalPnL(group))"></span>
                                </div>

                                <!-- % Rtn -->
                                <div class="w-14 text-right"
                                     :class="getGroupPnLPercent(group) !== null ? (parseFloat(getGroupPnLPercent(group)) >= 0 ? 'text-tv-green' : 'text-tv-red') : 'text-tv-muted'"
                                     x-text="getGroupPnLPercent(group) !== null ? getGroupPnLPercent(group) + '%' : ''"></div>

                                <!-- % Max -->
                                <div class="w-14 text-right"
                                     :class="getMaxPercentColor(getGroupMaxPercent(group))"
                                     x-text="shouldShowMaxPercent(group) ? getGroupMaxPercent(group) : ''"></div>

                                <!-- Comment indicator -->
                                <div class="flex-1 text-tv-muted text-sm truncate pl-2"
                                     x-show="getPositionComment(group)"
                                     x-text="getPositionComment(group)"></div>

                            </div>

                            <!-- Expanded Detail Panel -->
                            <div x-show="expanded" class="bg-tv-bg border-t border-tv-border">
                                <div class="mx-4 my-3 p-3 bg-tv-panel rounded border border-tv-border font-mono">
                                    <div class="flex gap-4">
                                        <div class="flex-shrink-0 space-y-1">
                                            <!-- Option legs section -->
                                            <template x-if="(group.positions || []).length > 0">
                                                <div>
                                                    <!-- Header row -->
                                                    <div class="flex items-center text-xs text-tv-muted pb-1 border-b border-tv-border/30">
                                                        <span class="w-10 text-right">Qty</span>
                                                        <span class="w-16 text-center mx-2">Exp</span>
                                                        <span class="w-10">DTE</span>
                                                        <span class="w-16 text-center mx-2">Strike</span>
                                                        <span class="w-6">Type</span>
                                                        <span class="w-24 text-right ml-4">Cost Basis</span>
                                                        <span class="w-20 text-right">Net Liq</span>
                                                        <span class="w-20 text-right">Open P/L</span>
                                                    </div>

                                                    <!-- Option legs -->
                                                    <template x-for="leg in [...(group.positions || [])].sort((a, b) => {
                                                        const expA = a.expiration || '';
                                                        const expB = b.expiration || '';
                                                        if (expA !== expB) return expA.localeCompare(expB);
                                                        return (a.strike || 0) - (b.strike || 0);
                                                    })" :key="leg.symbol">
                                                        <div class="flex items-center text-sm py-0.5">
                                                            <span class="w-10 text-right font-medium"
                                                                  :class="getSignedQuantity(leg) > 0 ? 'text-tv-green' : 'text-tv-red'"
                                                                  x-text="getSignedQuantity(leg)"></span>
                                                            <span class="w-16 text-center bg-tv-border/30 mx-2 py-0.5 rounded text-tv-text"
                                                                  x-text="getExpirationDate(leg)"></span>
                                                            <span class="w-10 text-tv-muted"
                                                                  :class="getDTE(leg) <= 7 ? 'text-tv-red' : getDTE(leg) <= 30 ? 'text-yellow-400' : ''"
                                                                  x-text="getDTE(leg) !== null ? getDTE(leg) + 'd' : ''"></span>
                                                            <span class="w-16 text-center bg-tv-border/30 mx-2 py-0.5 rounded text-tv-text"
                                                                  x-text="getStrikePrice(leg)"></span>
                                                            <span class="w-6 text-tv-muted"
                                                                  x-text="getOptionType(leg)"></span>
                                                            <span class="w-24 text-right ml-4"
                                                                  :class="(leg.cost_basis || 0) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                                  x-text="'$' + formatNumber(leg.cost_basis || 0)"></span>
                                                            <span class="w-20 text-right text-tv-muted"
                                                                  x-text="'$' + formatNumber(_calculateLegMarketValue(leg))"></span>
                                                            <span class="w-20 text-right font-medium"
                                                                  :class="_calculateLegPnL(leg) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                                  x-text="'$' + formatNumber(_calculateLegPnL(leg))"></span>
                                                        </div>
                                                    </template>
                                                </div>
                                            </template>

                                            <!-- Equity section -->
                                            <template x-if="(group.equityLegs || []).length > 0">
                                                <div :class="(group.positions || []).length > 0 ? 'mt-2 pt-2 border-t border-tv-border/30' : ''">
                                                    <div class="flex items-center text-xs text-tv-muted pb-1 border-b border-tv-border/30">
                                                        <span class="w-16">Shares</span>
                                                        <span class="w-20 text-right">Avg Price</span>
                                                        <span class="w-24 text-right ml-4">Cost Basis</span>
                                                        <span class="w-20 text-right">Mkt Value</span>
                                                        <span class="w-20 text-right">Open P/L</span>
                                                    </div>
                                                    <div class="flex items-center text-sm py-0.5">
                                                        <span class="w-16 font-medium text-tv-text" x-text="group.equitySummary?.quantity || 0"></span>
                                                        <span class="w-20 text-right text-tv-muted" x-text="'$' + formatNumber(group.equitySummary?.average_price || 0)"></span>
                                                        <span class="w-24 text-right ml-4 text-tv-muted"
                                                              x-text="'$' + formatNumber(group.equitySummary?.cost_basis || 0)"></span>
                                                        <span class="w-20 text-right text-tv-muted"
                                                              x-text="'$' + formatNumber(_calculateEquityMarketValue(group))"></span>
                                                        <span class="w-20 text-right font-medium"
                                                              :class="(_calculateEquityMarketValue(group) + (group.equityLegs || []).reduce((s, l) => s + (l.cost_basis || 0), 0)) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                              x-text="'$' + formatNumber(_calculateEquityMarketValue(group) + (group.equityLegs || []).reduce((s, l) => s + (l.cost_basis || 0), 0))"></span>
                                                    </div>
                                                </div>
                                            </template>

                                            <!-- No legs message for assigned chains -->
                                            <template x-if="(group.positions || []).length === 0 && (group.equityLegs || []).length === 0">
                                                <div class="text-xs text-tv-muted py-1">
                                                    <span x-show="group.has_assignment">All positions assigned/exercised</span>
                                                    <span x-show="!group.has_assignment">No open legs</span>
                                                </div>
                                            </template>

                                            <!-- Chain summary -->
                                            <div class="flex items-center text-xs text-tv-muted mt-2 pt-1 border-t border-tv-border/30 gap-4">
                                                <span x-text="'Opened: ' + (group.opening_date || 'N/A')"></span>
                                                <span x-text="'Orders: ' + (group.order_count || 1)"></span>
                                                <span x-show="group.roll_count > 0" x-text="'Rolls: ' + group.roll_count" class="text-tv-blue"></span>
                                                <span x-show="group.realized_pnl !== 0"
                                                      :class="group.realized_pnl >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                      x-text="'Realized: $' + formatNumber(group.realized_pnl)"></span>
                                            </div>
                                        </div>

                                        <!-- Comments -->
                                        <div class="flex-1 min-w-0">
                                            <div class="text-xs text-tv-muted pb-1 border-b border-tv-border/30 mb-1">Notes</div>
                                            <textarea :value="getPositionComment(group)"
                                                      @input="updatePositionComment(group, $event.target.value)"
                                                      @click.stop
                                                      rows="3"
                                                      class="w-full bg-transparent text-tv-text text-sm font-sans border border-tv-border/30 rounded px-2 py-1 resize-none outline-none focus:border-tv-blue/50"
                                                      placeholder="Add notes..."></textarea>
                                        </div>
                                    </div>
                                </div>

                                <!-- Roll Analysis Panel -->
                                <template x-if="group.rollAnalysis">
                                    <div class="mx-4 mb-3 p-3 bg-tv-panel rounded border-l-2"
                                         :class="{
                                             'border-green-500 border border-l-2 border-green-500/30': group.rollAnalysis.borderColor === 'green',
                                             'border-red-500 border border-l-2 border-red-500/30': group.rollAnalysis.borderColor === 'red',
                                             'border-yellow-500 border border-l-2 border-yellow-500/30': group.rollAnalysis.borderColor === 'yellow',
                                             'border-tv-blue border border-l-2 border-tv-blue/30': group.rollAnalysis.borderColor === 'blue'
                                         }">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="text-xs font-semibold text-tv-text">Roll Analysis</span>
                                            <span class="text-[10px] px-1.5 py-0 rounded-sm border leading-4"
                                                  :class="{
                                                      'bg-green-500/20 text-green-400 border-green-500/50': group.rollAnalysis.convexity === 'High' || group.rollAnalysis.convexity === 'Low Risk',
                                                      'bg-yellow-500/20 text-yellow-400 border-yellow-500/50': group.rollAnalysis.convexity === 'Diminishing' || group.rollAnalysis.convexity === 'Elevated Risk',
                                                      'bg-red-500/20 text-red-400 border-red-500/50': group.rollAnalysis.convexity === 'Low' || group.rollAnalysis.convexity === 'High Risk'
                                                  }"
                                                  x-text="group.rollAnalysis.isCredit ? group.rollAnalysis.convexity : (group.rollAnalysis.convexity + ' Convexity')"></span>
                                        </div>
                                        <div class="grid grid-cols-6 gap-2 text-xs mb-2">
                                            <div class="text-center">
                                                <div class="text-tv-muted">% Max Profit</div>
                                                <div class="font-medium" :class="parseFloat(group.rollAnalysis.pctMaxProfit) >= 0 ? 'text-tv-green' : 'text-tv-red'"
                                                     x-text="group.rollAnalysis.pctMaxProfit + '%'"></div>
                                            </div>
                                            <div class="text-center">
                                                <div class="text-tv-muted">% Max Loss</div>
                                                <div class="font-medium" :class="parseFloat(group.rollAnalysis.pctMaxLoss) > 0 ? 'text-tv-red' : 'text-tv-muted'"
                                                     x-text="group.rollAnalysis.pctMaxLoss + '%'"></div>
                                            </div>
                                            <div class="text-center">
                                                <div class="text-tv-muted">Reward:Risk</div>
                                                <div class="font-medium" :class="group.rollAnalysis.rewardToRiskRaw < (group.rollAnalysis.isCredit ? 0.3 : 0.6) ? 'text-orange-400' : 'text-tv-text'"
                                                     x-text="group.rollAnalysis.rewardToRisk"></div>
                                            </div>
                                            <div class="text-center">
                                                <div class="text-tv-muted">Delta Sat.</div>
                                                <div class="font-medium" :class="parseFloat(group.rollAnalysis.deltaSaturation) >= 65 ? (group.rollAnalysis.isCredit ? 'text-tv-red' : 'text-orange-400') : 'text-tv-text'"
                                                     x-text="group.rollAnalysis.deltaSaturation + '%'"></div>
                                            </div>
                                            <div class="text-center">
                                                <div class="text-tv-muted">Near Short</div>
                                                <div class="font-medium" :class="parseFloat(group.rollAnalysis.proximityToShort) < 3 ? 'text-yellow-400' : 'text-tv-text'"
                                                     x-text="group.rollAnalysis.proximityToShort + '%'"></div>
                                            </div>
                                            <div class="text-center">
                                                <div class="text-tv-muted">Max P / Max L</div>
                                                <div class="font-medium text-tv-text"
                                                     x-text="'$' + group.rollAnalysis.maxProfit + ' / $' + group.rollAnalysis.maxLoss"></div>
                                            </div>
                                        </div>
                                        <template x-if="group.rollAnalysis.suggestion">
                                            <div class="mt-2 pl-3 py-2 border-l-2 text-xs text-tv-text bg-tv-bg/50 rounded-r"
                                                 :class="{
                                                     'border-red-500': group.rollAnalysis.urgency === 'high',
                                                     'border-yellow-500': group.rollAnalysis.urgency === 'medium',
                                                     'border-tv-blue': group.rollAnalysis.urgency === 'low'
                                                 }">
                                                <span x-text="group.rollAnalysis.suggestion"></span>
                                            </div>
                                        </template>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </template>
        </div>
    </main>
</body>
</html>
